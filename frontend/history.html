<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FoxESS Reports</title>
    <link rel="manifest" href="/manifest.webmanifest">
    <link rel="apple-touch-icon" href="/icons/apple-touch-icon.png">
    <meta name="theme-color" content="#0d1117">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="FoxESS Automation">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <!-- Firebase Auth Configuration -->
    <script src="js/firebase-config.js"></script>
    <script src="js/firebase-auth.js"></script>
    <script src="js/api-client.js"></script>
    <script src="js/shared-utils.js"></script>
    <script src="js/app-shell.js?v=9"></script>
    <script src="js/tour.js?v=7"></script>
    <link rel="stylesheet" href="css/shared-styles.css?v=7">
    <script src="js/theme-init.js"></script>
    <link rel="stylesheet" href="css/tour.css">
    <style>
        /* Page-specific styles */
        /* Main content */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .page-header {
            margin-bottom: 24px;
        }
        .page-header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--accent);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .page-header p {
            color: var(--text-muted);
            margin-top: 8px;
            font-size: 14px;
        }
        
        /* Cards */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            background: var(--bg-overlay);
        }
        .card-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .card-body {
            padding: 20px;
        }
        
        /* Controls row */
        .controls-row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            /* Align controls to the bottom so buttons line up with inputs */
            align-items: flex-end;
            margin-bottom: 16px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .control-group label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Inputs */
        .input, select {
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s;
        }
        .input:focus, select:focus {
            border-color: var(--accent);
        }
        select {
            cursor: pointer;
        }
        
        /* Buttons */
        .btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px 18px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .btn:hover { background: var(--border-primary); }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            background: var(--gradient-success);
            border-color: var(--color-success-dark);
            color: #fff;
        }
        .btn-primary:hover { filter: brightness(1.1); }
        .btn-accent {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: #fff;
        }
        .btn-accent:hover { filter: brightness(1.1); }
        
        /* Status messages */
        .status {
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            margin-bottom: 16px;
            display: none;
        }
        .status.loading {
            display: block;
            background: var(--color-info-bg);
            border: 1px solid color-mix(in srgb, var(--accent-blue) 30%, transparent);
            color: var(--accent);
        }
        .status.error {
            display: block;
            background: var(--color-danger-bg, color-mix(in srgb, var(--color-danger) 10%, transparent));
            border: 1px solid color-mix(in srgb, var(--color-danger) 30%, transparent);
            color: var(--danger);
        }
        .status.success {
            display: block;
            background: var(--color-success-bg);
            border: 1px solid color-mix(in srgb, var(--color-success-dark) 30%, transparent);
            color: var(--success);
        }
        
        /* Chart container */
        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
            margin-top: 16px;
        }
        .chart-container canvas {
            width: 100% !important;
            height: 100% !important;
        }
        
        /* Data table */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 16px;
            font-size: 13px;
        }
        .data-table th, .data-table td {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        .data-table th {
            background: var(--bg-overlay);
            color: var(--text-muted);
            font-weight: 600;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .data-table tr:hover {
            background: color-mix(in srgb, var(--accent-blue) 5%, transparent);
        }
        .data-table .value {
            font-weight: 600;
            color: var(--accent);
        }
        .data-table .positive { color: var(--success); }
        .data-table .negative { color: var(--danger); }
        
        /* Stats grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-bottom: 16px;
        }
        .stat-box {
            background: var(--bg-overlay);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 14px;
            text-align: center;
        }
        .stat-box .label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }
        .stat-box .value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text);
        }
        .stat-box .unit {
            font-size: 12px;
            color: var(--text-muted);
            margin-left: 2px;
        }
        .stat-box.generation .value { color: var(--color-yellow); }
        .stat-box.feedin .value { color: var(--success); }
        .stat-box.consumption .value { color: var(--accent); }
        .stat-box.houseload .value { color: var(--color-danger); }
        .stat-box.charge .value { color: var(--color-purple); }
        .stat-box.discharge .value { color: var(--color-orange); }
        
        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }
        .empty-state .icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }
        .empty-state p {
            font-size: 14px;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 16px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 4px;
        }
        .tab {
            padding: 8px 16px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 6px 6px 0 0;
            transition: all 0.2s;
        }
        .tab:hover { color: var(--text); background: color-mix(in srgb, var(--text-primary) 5%, transparent); }
        .tab.active {
            color: var(--accent);
            background: var(--accent-blue-bg);
            border-bottom: 2px solid var(--accent);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .controls-row { flex-direction: column; align-items: stretch; }
            .chart-container { height: 250px; }
            nav { flex-wrap: wrap; gap: 8px; }
        }
        
        /* Info banner */
        .info-banner {
            background: var(--accent-blue-bg);
            border: 1px solid color-mix(in srgb, var(--accent-blue) 20%, transparent);
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 13px;
        }
        .info-banner .icon { font-size: 18px; }
        .info-banner .text { color: var(--text-muted); }
        .info-banner strong { color: var(--text); }
        
        /* Automation History Timeline */
        .automation-timeline {
            position: relative;
            padding-left: 30px;
            margin-top: 20px;
            max-height: 600px;
            overflow-y: auto;
            padding-right: 12px;
        }
        
        .automation-timeline::-webkit-scrollbar {
            width: 8px;
        }
        
        .automation-timeline::-webkit-scrollbar-track {
            background: var(--bg-overlay);
            border-radius: 4px;
        }
        
        .automation-timeline::-webkit-scrollbar-thumb {
            background: color-mix(in srgb, var(--accent-blue) 30%, transparent);
            border-radius: 4px;
        }
        
        .automation-timeline::-webkit-scrollbar-thumb:hover {
            background: color-mix(in srgb, var(--accent-blue) 50%, transparent);
        }
        
        .timeline-event {
            position: relative;
            margin-bottom: 24px;
            background: var(--bg-overlay);
            border-left: 3px solid var(--accent-blue);
            border-radius: 8px;
            padding: 16px;
            transition: all 0.2s;
        }
        
        .timeline-event:hover {
            background: color-mix(in srgb, var(--bg-primary) 30%, transparent);
            transform: translateX(2px);
        }
        
        .timeline-event.ongoing {
            border-left-color: var(--accent);
            background: color-mix(in srgb, var(--color-success) 8%, transparent);
        }
        
        .timeline-event.complete {
            border-left-color: var(--text-muted);
        }
        
        .event-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
            gap: 12px;
        }
        
        .event-title {
            font-weight: 600;
            font-size: 14px;
            color: var(--text);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .event-badge {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .event-badge.ongoing {
            background: var(--accent);
            color: #000;
        }
        
        .event-badge.complete {
            background: var(--text-muted);
            color: #000;
        }
        
        .event-duration {
            font-size: 12px;
            color: var(--text-muted);
            white-space: nowrap;
        }
        
        .event-times {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 8px 12px;
            font-size: 12px;
            margin-bottom: 12px;
            padding: 8px;
            background: var(--bg-overlay);
            border-radius: 4px;
        }
        
        .event-time-label {
            color: var(--text-muted);
            font-weight: 500;
        }
        
        .event-time-value {
            color: var(--text);
        }
        
        .event-conditions {
            margin-top: 12px;
        }
        
        .event-conditions-title {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .condition-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            max-height: 200px;
            overflow-y: auto;
            padding-right: 8px;
        }
        
        .condition-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .condition-list::-webkit-scrollbar-track {
            background: var(--bg-overlay);
            border-radius: 3px;
        }
        
        .condition-list::-webkit-scrollbar-thumb {
            background: color-mix(in srgb, var(--accent-blue) 30%, transparent);
            border-radius: 3px;
        }
        
        .condition-list::-webkit-scrollbar-thumb:hover {
            background: color-mix(in srgb, var(--accent-blue) 50%, transparent);
        }
        
        .condition-chip {
            background: color-mix(in srgb, var(--accent-blue) 12%, transparent);
            border: 1px solid color-mix(in srgb, var(--accent-blue) 30%, transparent);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            color: var(--accent-blue);
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .condition-chip.met {
            background: color-mix(in srgb, var(--color-success) 12%, transparent);
            border-color: color-mix(in srgb, var(--color-success-dark) 30%, transparent);
            color: var(--accent);
        }
        
        .condition-chip.not-met {
            background: color-mix(in srgb, var(--color-danger) 12%, transparent);
            border-color: color-mix(in srgb, var(--color-danger) 30%, transparent);
            color: var(--color-danger);
        }
        
        .event-action {
            margin-top: 12px;
            padding: 8px 12px;
            background: var(--accent-blue-bg);
            border-left: 3px solid var(--accent-blue);
            border-radius: 4px;
            font-size: 12px;
        }
        
        .event-action-label {
            color: var(--text-muted);
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .event-action-value {
            color: var(--text);
            font-weight: 500;
        }
        
        .timeline-empty {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }
        
        .timeline-empty .icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <nav class="nav-main">
        <button type="button" class="nav-toggle" data-nav-toggle="1" aria-label="Toggle navigation menu" aria-expanded="false">‚ò∞</button>
        <div class="nav-links">
            <a href="/" class="nav-link">üè† Overview</a>
            <a href="/roi.html" class="nav-link">üí≤ Automation ROI</a>
            <a href="/test.html" class="nav-link">üß™ Automation Lab</a>
            <a href="/history.html" class="nav-link">üìä Reports</a>
            <a href="/control.html" class="nav-link">üéÆ Controls</a>
            <a href="/settings.html" class="nav-link">‚öôÔ∏è Settings</a>
            <a href="/curtailment-discovery.html" class="nav-link" id="topologyNavLink" style="display: none;">üî¨ WIP - Topology Discovery</a>
            <a href="/tesla-integration.html" class="nav-link" id="teslaNavLink" style="display: none;">‚ö° WIP - Tesla Integration</a>
            <a href="/admin.html" class="nav-link" id="adminNavLink" style="display: none;">üõ°Ô∏è Admin</a>
        </div>
        <div class="nav-right">
            <div class="user-menu" data-user-menu>
                <button class="user-avatar" type="button" data-user-avatar>
                    <span data-user-initials>?</span>
                </button>
                <div class="user-dropdown" data-user-dropdown>
                    <div class="user-dropdown-header">
                        <div class="user-name" data-user-name>Guest</div>
                        <div class="user-email" data-user-email>Not signed in</div>
                    </div>
                    <button class="user-dropdown-item" type="button" data-go-settings>‚öôÔ∏è Settings</button>
                    <button class="user-dropdown-item" type="button" data-contact-us>üí¨ Contact Us</button>
                    <button class="user-dropdown-item danger" type="button" data-signout>üö™ Sign Out</button>
                </div>
            </div>
        </div>
    </nav>

    <!-- API call metrics footer -->
    <div id="apiMetricsFooter" class="api-metrics-footer">
        <div class="metrics-icon">üìä</div>
        <div id="metricsDate" class="metrics-date">‚Äî</div>
        <div id="metricsCounts" class="metrics-counts">
            <div class="metric-fox">Fox: <span id="countFox" class="metric-value">0</span></div>
            <div class="metric-amber">Amb: <span id="countAmber" class="metric-value">0</span></div>
            <div class="metric-weather">Wea: <span id="countWeather" class="metric-value">0</span></div>
        </div>
        <button class="btn btn-sm" onclick="loadApiMetrics(1)" title="Refresh metrics">üîÑ</button>
    </div>

    <div class="container page-shell">
        <div class="page-header">
            <h1>üìä Reports</h1>
            <p>View historical inverter data, generation reports, and energy statistics. Data is fetched on-demand to respect API limits.</p>
        </div>

        <div class="info-banner">
            <span class="icon">‚ÑπÔ∏è</span>
            <div class="text">
                <strong>Manual fetch only:</strong> Click the buttons below to load data. No automatic API calls are made on this page to conserve your API quotas.
            </div>
        </div>
        
        <!-- Removed duplicate API Usage Note (kept lower in the page near History section) -->

        <!-- Amber Historical Prices Info Banner -->
        <div class="info-banner" style="background: linear-gradient(135deg, color-mix(in srgb, var(--color-orange) 10%, transparent), var(--accent-blue-bg)); border-color: color-mix(in srgb, var(--accent-blue) 20%, transparent);">
            <span class="icon">üí°</span>
            <div class="text">
                <strong>Amber Price Analysis:</strong> View historical electricity prices to find patterns. Orange = buy price (cost to import), Blue = feed-in price (earnings from export). Use these insights to optimize your battery charging and solar export strategy.
            </div>
        </div>

        <!-- Amber Historical Prices Section -->
        <div class="card">
            <div class="card-header">
                <div class="card-title">üí∞ Amber Price History</div>
                <div style="font-size:11px;color:var(--text-muted)" id="pricesTimestamp">Not loaded</div>
            </div>
            <div class="card-body">
                <div class="controls-row">
                    <div class="control-group" style="min-width:120px">
                        <label>Start Date</label>
                        <input type="date" id="priceStartDate" class="input" />
                    </div>
                    <div class="control-group" style="min-width:120px">
                        <label>End Date</label>
                        <input type="date" id="priceEndDate" class="input" />
                    </div>
                    <div class="control-group">
                        <label>Resolution</label>
                        <select id="priceResolution" class="input">
                            <option value="5">5-minute</option>
                            <option value="30" selected>30-minute</option>
                        </select>
                    </div>
                    <button class="btn btn-primary" onclick="fetchAmberHistoricalPrices()" id="btnFetchPrices">
                        üìà Fetch Prices
                    </button>
                </div>

                <div id="pricesStatus" class="status"></div>

                <div id="pricesStats" style="display:none;margin-bottom:16px">
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="label">Buy Price (Min)</div>
                            <div><span class="value" id="statBuyMin" style="color:var(--color-success)">‚Äî</span><span class="unit">¬¢</span></div>
                        </div>
                        <div class="stat-box">
                            <div class="label">Buy Price (Avg)</div>
                            <div><span class="value" id="statBuyAvg">‚Äî</span><span class="unit">¬¢</span></div>
                        </div>
                        <div class="stat-box">
                            <div class="label">Buy Price (Max)</div>
                            <div><span class="value" id="statBuyMax" style="color:var(--color-danger)">‚Äî</span><span class="unit">¬¢</span></div>
                        </div>
                        <div class="stat-box">
                            <div class="label">Feed-in (Min)</div>
                            <div><span class="value" id="statFeedMin" style="color:var(--color-danger)">‚Äî</span><span class="unit">¬¢</span></div>
                        </div>
                        <div class="stat-box">
                            <div class="label">Feed-in (Avg)</div>
                            <div><span class="value" id="statFeedAvg">‚Äî</span><span class="unit">¬¢</span></div>
                        </div>
                        <div class="stat-box">
                            <div class="label">Feed-in (Max)</div>
                            <div><span class="value" id="statFeedMax" style="color:var(--color-success)">‚Äî</span><span class="unit">¬¢</span></div>
                        </div>
                    </div>
                </div>

                <div class="chart-container">
                    <canvas id="amberHistoricalChart"></canvas>
                </div>

                <div id="pricesContent">
                    <div class="empty-state">
                        <div class="icon">üí∞</div>
                        <p>Select a date range and click "Fetch Prices" to view historical Amber prices</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- History Section (24h time-series) -->
        <div class="card">
            <div class="card-header">
                <div class="card-title">‚ö° Real-Time History (Last 24 Hours)</div>
                <div style="font-size:11px;color:var(--text-muted)" id="historyTimestamp">Not loaded</div>
            </div>
            <div class="card-body">
                <div style="padding: 12px; background: color-mix(in srgb, var(--color-warning) 15%, transparent); border: 1px solid color-mix(in srgb, var(--color-warning) 30%, transparent); border-radius: 6px; margin-bottom: 16px; font-size: 13px; color: var(--color-warning);">
                    <strong>‚ö†Ô∏è API Usage Note:</strong> Ranges >24h require multiple API calls (48h=2, 7 days=7). Results are cached for 30 days to minimize repeat calls.
                </div>
                <div class="controls-row">
                    <div class="control-group">
                        <label>Time Range</label>
                        <select id="historyRange">
                            <option value="6">Last 6 hours</option>
                            <option value="12">Last 12 hours</option>
                            <option value="24" selected>Last 24 hours</option>
                            <option value="48">Last 48 hours</option>
                            <option value="168">Last 7 days ‚ö†Ô∏è</option>
                        </select>
                    </div>
                    <button class="btn btn-primary" onclick="fetchHistory()" id="btnFetchHistory">
                        üìà Fetch History Data
                    </button>
                    <button class="btn btn-secondary" onclick="toggleHistoryVariables()" id="btnToggleVariables" style="display:none;">
                        üîç Show All Variables
                    </button>
                    <!-- Test Data button removed (mock endpoint disabled) -->
                </div>
                
                <div id="historyStatus" class="status"></div>
                
                <div id="historyContent">
                    <div class="empty-state">
                        <div class="icon">üìä</div>
                        <p>Click "Fetch History Data" to load inverter time-series data</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Reports Section (Aggregated) -->
        <div class="card">
            <div class="card-header">
                <div class="card-title">üìÖ Energy Reports</div>
                <div style="font-size:11px;color:var(--text-muted)" id="reportTimestamp">Not loaded</div>
            </div>
            <div class="card-body">
                <div class="controls-row">
                    <div class="control-group">
                        <label>Report Type</label>
                        <select id="reportDimension">
                            <option value="month">Daily (this month)</option>
                            <option value="year">Monthly (this year)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Year</label>
                        <select id="reportYear"></select>
                    </div>
                    <div class="control-group" id="reportMonthGroup">
                        <label>Month</label>
                        <select id="reportMonth">
                            <option value="1">January</option>
                            <option value="2">February</option>
                            <option value="3">March</option>
                            <option value="4">April</option>
                            <option value="5">May</option>
                            <option value="6">June</option>
                            <option value="7">July</option>
                            <option value="8">August</option>
                            <option value="9">September</option>
                            <option value="10">October</option>
                            <option value="11">November</option>
                            <option value="12">December</option>
                        </select>
                    </div>
                    <button class="btn btn-accent" onclick="fetchReport()" id="btnFetchReport">
                        üìä Fetch Report
                    </button>
                </div>
                
                <div id="reportStatus" class="status"></div>
                
                <div id="reportContent">
                    <div class="empty-state">
                        <div class="icon">üìÖ</div>
                        <p>Click "Fetch Report" to load aggregated energy data</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Generation Summary -->
        <div class="card">
            <div class="card-header">
                <div class="card-title">üåû Generation Summary</div>
                <div style="font-size:11px;color:var(--text-muted)" id="generationTimestamp">Not loaded</div>
            </div>
            <div class="card-body">
                <div class="controls-row">
                    <button class="btn btn-primary" onclick="fetchGeneration()" id="btnFetchGeneration">
                        üîã Fetch Generation Data
                    </button>
                </div>
                
                <div id="generationStatus" class="status"></div>
                
                <div id="generationContent">
                    <div class="empty-state">
                        <div class="icon">üåû</div>
                        <p>Click "Fetch Generation Data" to load lifetime generation statistics</p>
                    </div>
                </div>
            </div>
        </div>



        <!-- Raw Data Viewer -->
        <div class="card">
            <div class="card-header">
                <div class="card-title">üîç Raw Data Viewer</div>
                <button class="btn" onclick="toggleRawData()" style="font-size:11px;padding:6px 12px">
                    Toggle Raw JSON
                </button>
            </div>
            <div class="card-body">
                <div id="rawDataContent" style="display:none">
                    <pre id="rawDataPre" style="background:var(--bg-terminal);padding:16px;border-radius:8px;overflow:auto;max-height:400px;font-size:12px;color:var(--text-muted)">No data loaded yet</pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Chart.js CDN (loaded on demand) -->
    <script>
        // CSS variable helper for theme-aware chart colors
        function cssVar(name) {
            return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        }

        // Global state
        let chartJsLoaded = false;
        let historyChart = null;
        let reportChart = null;
        let lastRawData = null;
        let historyVariables = null;
        let deviceSn = null;
        let cachedTopologyContext = null;
        let cachedTopologyFetchedAt = 0;

        const TOPOLOGY_CACHE_MS = 10 * 60 * 1000;
        const DEFAULT_TOPOLOGY_REFRESH_MS = 4 * 60 * 60 * 1000;

        // apiClient is declared in api-client.js and initialized after Firebase auth is ready

        /**
         * Helper function to make authenticated API calls.
         * Uses apiClient.fetch to include the Authorization header and normalize responses.
         */
        async function authenticatedFetch(url, options = {}) {
            if (window.AppShell && typeof AppShell.authFetch === 'function') {
                return AppShell.authFetch(url, options);
            }
            try {
                if (typeof waitForAPIClient === 'function') {
                    await waitForAPIClient(3000);
                } else {
                    const start = Date.now();
                    while (!apiClient && (Date.now() - start) < 3000) {
                        await new Promise(r => setTimeout(r, 50));
                    }
                }
            } catch (e) {
                console.warn('[API] apiClient not initialized yet');
                throw new Error('API client not ready');
            }
            return apiClient.fetch(url, options);
        }

        // Initialize page (NO automatic API calls - those happen after auth)
        document.addEventListener('DOMContentLoaded', () => {
            // Populate year dropdown
            const yearSelect = document.getElementById('reportYear');
            const currentYear = new Date().getFullYear();
            for (let y = currentYear; y >= currentYear - 5; y--) {
                const opt = document.createElement('option');
                opt.value = y;
                opt.textContent = y;
                yearSelect.appendChild(opt);
            }
            
            // Set current month
            document.getElementById('reportMonth').value = new Date().getMonth() + 1;
            
            // Initialize month group visibility (show by default since default is "Daily")
            const monthGroup = document.getElementById('reportMonthGroup');
            monthGroup.style.display = 'flex';
            
            // Handle dimension change
            document.getElementById('reportDimension').addEventListener('change', (e) => {
                monthGroup.style.display = e.target.value === 'month' ? 'none' : 'flex';
            });
            
            // Try to get device SN from localStorage (no API call)
            try {
                const savedSn = localStorage.getItem('deviceSn');
                if (savedSn) {
                    deviceSn = savedSn;
                }
            } catch (e) {}
            // NOTE: loadDeviceSn() is called from initFirebaseAuth after auth is ready
        });

        async function loadDeviceSn() {
            try {
                const resp = await authenticatedFetch('/api/config');
                const data = await resp.json();
                if (data.errno === 0 && data.result?.deviceSn) {
                    deviceSn = data.result.deviceSn;
                    try { localStorage.setItem('deviceSn', deviceSn); } catch (e) {}
                }
            } catch (e) {
                console.warn('Could not load device SN:', e);
            }
        }

        // Load Chart.js on demand
        async function ensureChartJs() {
            if (chartJsLoaded) return;
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
                script.onload = () => {
                    chartJsLoaded = true;
                    resolve();
                };
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // Format date/time
        function formatDateTime(ts) {
            const d = new Date(ts);
            return d.toLocaleString('en-AU', { 
                day: '2-digit', month: 'short', hour: '2-digit', minute: '2-digit',
                hour12: false
            });
        }
        
        function formatTime(ts) {
            const d = new Date(ts);
            return d.toLocaleTimeString('en-AU', { hour: '2-digit', minute: '2-digit', hour12: false });
        }

        function normalizePowerToKW(rawValue) {
            const n = Number(rawValue);
            if (isNaN(n)) return 0;
            return Math.abs(n) > 100 ? (n / 1000) : n;
        }

        function parseHistoryTimeMs(rawTime) {
            if (rawTime === null || rawTime === undefined) return NaN;
            if (typeof rawTime === 'number') {
                return rawTime < 1e12 ? rawTime * 1000 : rawTime;
            }
            if (typeof rawTime === 'string') {
                const parsed = Date.parse(rawTime);
                if (!isNaN(parsed)) return parsed;
                const parts = rawTime.split(' ');
                if (parts.length >= 2) {
                    const fallback = Date.parse(`${parts[0]}T${parts[1]}`);
                    if (!isNaN(fallback)) return fallback;
                }
            }
            const n = Number(rawTime);
            if (!isNaN(n)) return n < 1e12 ? n * 1000 : n;
            return NaN;
        }

        function extractRealtimeDatas(realtimePayload) {
            const result = realtimePayload?.result;
            if (Array.isArray(result) && result.length > 0) {
                if (Array.isArray(result[0]?.datas)) return result[0].datas;
                return result;
            }
            if (result && Array.isArray(result.datas)) return result.datas;
            return [];
        }

        function findRealtimeVar(datas, key) {
            const item = datas.find(d => d.variable === key || d.key === key);
            return item ? item.value : null;
        }

        function normalizeCouplingValue(value) {
            const raw = String(value || '').toLowerCase().trim();
            if (raw === 'ac' || raw === 'ac-coupled' || raw === 'ac_coupled') return 'ac';
            if (raw === 'dc' || raw === 'dc-coupled' || raw === 'dc_coupled') return 'dc';
            return 'unknown';
        }

        async function getStoredTopologyContext(forceRefresh = false) {
            if (!forceRefresh && cachedTopologyContext && (Date.now() - cachedTopologyFetchedAt) < TOPOLOGY_CACHE_MS) {
                return cachedTopologyContext;
            }

            try {
                const resp = await authenticatedFetch('/api/config/system-topology');
                const data = await resp.json();
                if (data?.errno !== 0) {
                    cachedTopologyContext = null;
                    cachedTopologyFetchedAt = Date.now();
                    return null;
                }

                const result = data?.result || {};
                const coupling = normalizeCouplingValue(result.coupling);
                const isLikelyAcCoupled = coupling === 'ac' ? true : (coupling === 'dc' ? false : false);
                const hasStoredCoupling = coupling === 'ac' || coupling === 'dc';
                const source = String(result.source || 'unknown').toLowerCase();
                const lastDetectedAt = Number(result.lastDetectedAt) || 0;
                const refreshAfterMs = Number(result.refreshAfterMs) > 0
                    ? Number(result.refreshAfterMs)
                    : DEFAULT_TOPOLOGY_REFRESH_MS;
                const isStale = !lastDetectedAt || (Date.now() - lastDetectedAt) > refreshAfterMs;

                cachedTopologyContext = {
                    coupling,
                    source,
                    isLikelyAcCoupled,
                    hasStoredCoupling,
                    lastDetectedAt,
                    refreshAfterMs,
                    isStale
                };
                cachedTopologyFetchedAt = Date.now();
                return cachedTopologyContext;
            } catch (error) {
                console.warn('[History] Failed to load stored topology:', error);
                cachedTopologyContext = null;
                cachedTopologyFetchedAt = Date.now();
                return null;
            }
        }

        async function persistTopologyDetection(isLikelyAcCoupled, pvPower, meterPower2, confidence = 0.7) {
            try {
                const coupling = isLikelyAcCoupled ? 'ac' : 'dc';
                const resp = await authenticatedFetch('/api/config/system-topology', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        coupling,
                        source: 'auto',
                        confidence,
                        refreshAfterMs: DEFAULT_TOPOLOGY_REFRESH_MS,
                        lastDetectedAt: Date.now(),
                        evidence: {
                            pvPower,
                            meterPower2,
                            heuristic: 'pvPower~0 && meterPower2>0'
                        }
                    })
                });
                const data = await resp.json();
                if (data?.errno === 0) {
                    cachedTopologyContext = {
                        coupling,
                        source: 'auto',
                        isLikelyAcCoupled,
                        hasStoredCoupling: true,
                        lastDetectedAt: Date.now(),
                        refreshAfterMs: DEFAULT_TOPOLOGY_REFRESH_MS,
                        isStale: false
                    };
                    cachedTopologyFetchedAt = Date.now();
                }
            } catch (error) {
                console.warn('[History] Failed to persist topology detection:', error);
            }
        }

        async function detectAcCoupledContext() {
            const stored = await getStoredTopologyContext(false);
            if (stored?.hasStoredCoupling && stored.source === 'manual') {
                return {
                    isLikelyAcCoupled: stored.isLikelyAcCoupled,
                    source: 'stored-manual'
                };
            }
            if (stored?.hasStoredCoupling && !stored.isStale) {
                return {
                    isLikelyAcCoupled: stored.isLikelyAcCoupled,
                    source: 'stored-auto'
                };
            }

            try {
                const resp = await authenticatedFetch('/api/inverter/real-time');
                const data = await resp.json();
                if (data?.errno !== 0) {
                    if (stored?.hasStoredCoupling) {
                        return {
                            isLikelyAcCoupled: stored.isLikelyAcCoupled,
                            source: 'stored-fallback'
                        };
                    }
                    return { isLikelyAcCoupled: false, source: 'default' };
                }

                const datas = extractRealtimeDatas(data);
                const pvPower = normalizePowerToKW(findRealtimeVar(datas, 'pvPower'));
                const meterPower2 = normalizePowerToKW(findRealtimeVar(datas, 'meterPower2'));
                const isLikelyAcCoupled = Math.abs(pvPower) < 0.05 && meterPower2 > 0.05;

                const shouldPersist =
                    !stored?.hasStoredCoupling ||
                    stored.isStale ||
                    stored.isLikelyAcCoupled !== isLikelyAcCoupled;

                if (shouldPersist) {
                    const confidence = isLikelyAcCoupled
                        ? (meterPower2 > 0.3 ? 0.9 : 0.75)
                        : (Math.abs(pvPower) > 0.2 ? 0.8 : 0.65);
                    await persistTopologyDetection(isLikelyAcCoupled, pvPower, meterPower2, confidence);
                }

                return { isLikelyAcCoupled, pvPower, meterPower2, source: 'realtime' };
            } catch (error) {
                console.warn('[History] AC detection failed:', error);
                if (stored?.hasStoredCoupling) {
                    return {
                        isLikelyAcCoupled: stored.isLikelyAcCoupled,
                        source: 'stored-fallback'
                    };
                }
                return { isLikelyAcCoupled: false, source: 'default' };
            }
        }

        async function fetchHistoryVariableSeries(beginSec, endSec, variableCandidates = ['meterPower2']) {
            const resp = await authenticatedFetch(`/api/inverter/history?begin=${beginSec}&end=${endSec}`);
            const data = await resp.json();
            if (data?.errno && data.errno !== 0) {
                throw new Error(data.msg || data.error || 'History API error');
            }

            const datas = data?.result?.[0]?.datas || [];
            let selected = null;
            for (const variable of variableCandidates) {
                selected = datas.find(d => d.variable === variable);
                if (selected?.data?.length) break;
            }
            return selected?.data || [];
        }

        function integratePowerSeriesToBuckets(series, bucketCount, bucketIndexFromMs) {
            const buckets = Array.from({ length: bucketCount }, () => 0);
            if (!Array.isArray(series) || series.length < 2) return buckets;

            const sorted = series
                .map(point => ({
                    t: parseHistoryTimeMs(point.time),
                    v: normalizePowerToKW(point.value)
                }))
                .filter(point => Number.isFinite(point.t))
                .sort((a, b) => a.t - b.t);

            for (let i = 1; i < sorted.length; i++) {
                const prev = sorted[i - 1];
                const cur = sorted[i];
                const dtHours = (cur.t - prev.t) / 3600000;
                if (!Number.isFinite(dtHours) || dtHours <= 0 || dtHours > 6) continue;

                const bucketIndex = bucketIndexFromMs(prev.t);
                if (bucketIndex < 0 || bucketIndex >= bucketCount) continue;

                const kw = Math.max(0, prev.v);
                buckets[bucketIndex] += kw * dtHours;
            }

            return buckets.map(value => Number(value.toFixed(3)));
        }

        function getMonthRangeSeconds(year, month) {
            const start = new Date(year, month - 1, 1, 0, 0, 0, 0);
            const end = new Date(year, month, 0, 23, 59, 59, 999);
            return {
                beginSec: Math.floor(start.getTime() / 1000),
                endSec: Math.floor(end.getTime() / 1000),
                daysInMonth: new Date(year, month, 0).getDate()
            };
        }

        function getTodayRangeSeconds() {
            const now = new Date();
            const start = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
            return {
                beginSec: Math.floor(start.getTime() / 1000),
                endSec: Math.floor(Date.now() / 1000)
            };
        }

        // ==================== HISTORY ====================
        // fetchHistoryMock() removed ‚Äî mock endpoint disabled and Test Data UI removed.
        
        async function fetchHistory() {
            const btn = document.getElementById('btnFetchHistory');
            const status = document.getElementById('historyStatus');
            const content = document.getElementById('historyContent');
            const timestamp = document.getElementById('historyTimestamp');
            
            btn.disabled = true;
            btn.innerHTML = '‚è≥ Loading...';
            status.className = 'status loading';
            status.textContent = 'Fetching history data from FoxESS...';
            
            try {
                const hours = parseInt(document.getElementById('historyRange').value);
                const end = Math.floor(Date.now() / 1000); // Convert ms to Unix seconds
                const begin = end - (hours * 60 * 60); // hours to seconds
                
                const resp = await authenticatedFetch(`/api/inverter/history?begin=${begin}&end=${end}`);
                const data = await resp.json();
                
                if (data.errno && data.errno !== 0) {
                    throw new Error(data.msg || 'API error');
                }
                
                lastRawData = { type: 'history', data };
                updateRawDataViewer();
                
                await renderHistoryData(data, hours);
                
                status.className = 'status success';
                status.textContent = `‚úì History loaded successfully (${hours}h range)`;
                timestamp.textContent = `Updated: ${new Date().toLocaleTimeString('en-AU', { hour: '2-digit', minute: '2-digit', hour12: false })}`;
                
                setTimeout(() => { status.style.display = 'none'; }, 3000);
            } catch (e) {
                status.className = 'status error';
                status.textContent = `‚úó Error: ${e.message}`;
                content.innerHTML = `<div class="empty-state"><div class="icon">‚ùå</div><p>Failed to load history: ${e.message}</p></div>`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'üìà Fetch History Data';
            }
        }

        async function renderHistoryData(data, hours) {
            const content = document.getElementById('historyContent');
            
            // Parse the FoxESS response format - data.result[0].datas contains the variables
            const result = data.result;
            if (!result || !Array.isArray(result) || result.length === 0) {
                content.innerHTML = '<div class="empty-state"><div class="icon">üì≠</div><p>No history data available for this period</p></div>';
                return;
            }
            
            // Extract datas array from the first result item
            const datas = result[0].datas || [];
            if (datas.length === 0) {
                content.innerHTML = '<div class="empty-state"><div class="icon">üì≠</div><p>No history data available for this period</p></div>';
                return;
            }
            
            // FoxESS returns: {datas: [{variable: 'xxx', data: [{time: ts, value: v}, ...]}]}
            const variables = {};
            datas.forEach(item => {
                if (item.variable && item.data) {
                    variables[item.variable] = item;
                }
            });
            
            // Store all variables for debugging
            historyVariables = {};
            Object.entries(variables).forEach(([name, item]) => {
                if (item.data) {
                    historyVariables[name] = item.data;
                }
            });
            
            // Show the "Show All Variables" button
            document.getElementById('btnToggleVariables').style.display = 'inline-block';
            
            // Debug: log available variables with sample values
            const debugInfo = {};
            Object.entries(variables).forEach(([name, item]) => {
                if (item.data && item.data.length > 0) {
                    const samples = item.data.slice(0, 3).map(d => `${d.time}: ${d.value}`);
                    debugInfo[name] = {count: item.data.length, samples};
                }
            });
            console.log('[History] Variables detail:', debugInfo);
            
            // Choose solar source with AC-coupled awareness:
            // prefer pvPower for DC systems, but if pvPower is missing/near-zero
            // and meterPower2 has meaningful values, use meterPower2.
            const pvData = variables.pvPower?.data || [];
            const meter2Data = variables.meterPower2?.data || [];
            const generationData = variables.generationPower?.data || [];

            const maxAbs = (arr) => arr.length ? Math.max(...arr.map(d => Math.abs(Number(d?.value) || 0))) : 0;
            const pvPeak = maxAbs(pvData);
            const meter2Peak = maxAbs(meter2Data);

            let genData = [];
            let solarSource = 'generationPower';
            if (pvData.length > 0 && pvPeak >= 0.05) {
                genData = pvData;
                solarSource = 'pvPower';
            } else if (meter2Data.length > 0 && meter2Peak >= 0.05) {
                genData = meter2Data;
                solarSource = 'meterPower2';
            } else {
                genData = generationData;
                solarSource = 'generationPower';
            }

            const feedData = variables.feedinPower?.data || [];
            const gridData = variables.gridConsumptionPower?.data || [];
            const loadsData = variables.loadsPower?.data || [];
            
            console.log('[History] Solar source selected:', solarSource, 'pvPeak:', pvPeak, 'meter2Peak:', meter2Peak);
            console.log('[History] genData length:', genData.length, 'feedData length:', feedData.length, 'gridData length:', gridData.length, 'loadsData length:', loadsData.length);
            
            if (genData.length === 0) {
                content.innerHTML = `<div class="empty-state"><div class="icon">‚ö†Ô∏è</div><p>No generation data available. Available variables: ${Object.keys(variables).join(', ')}</p></div>`;
                return;
            }
            
            // Sort all data arrays by time to ensure chronological order
            const parseTime = (timeStr) => {
                if (typeof timeStr === 'string') {
                    // Format: "2025-12-01 23:20:14 AEDT+1100"
                    const [date, time] = timeStr.split(' ');
                    return new Date(`${date}T${time}`).getTime();
                }
                return timeStr;
            };
            
            genData.sort((a, b) => parseTime(a.time) - parseTime(b.time));
            feedData.sort((a, b) => parseTime(a.time) - parseTime(b.time));
            gridData.sort((a, b) => parseTime(a.time) - parseTime(b.time));
            
            // Create time-based lookup maps for house load calculation
            const feedinMap = {};
            const gridMap = {};
            const loadsMap = {};
            feedData.forEach(d => feedinMap[d.time] = d.value || 0);
            gridData.forEach(d => gridMap[d.time] = d.value || 0);
            loadsData.forEach(d => loadsMap[d.time] = d.value || 0);
            
            const avgGen = genData.length ? (genData.reduce((s, d) => s + (d.value || 0), 0) / genData.length) : 0;
            const avgFeed = feedData.length ? (feedData.reduce((s, d) => s + (d.value || 0), 0) / feedData.length) : 0;
            const avgGrid = gridData.length ? (gridData.reduce((s, d) => s + (d.value || 0), 0) / gridData.length) : 0;
            const maxGen = genData.length ? Math.max(...genData.map(d => d.value || 0)) : 0;
            
            // Calculate house load stats
            const houseLoadValues = genData.map(d => {
                if (loadsMap[d.time] !== undefined) {
                    return loadsMap[d.time];
                }
                const gen = d.value || 0;
                const feedin = feedinMap[d.time] || 0;
                const grid = gridMap[d.time] || 0;
                return gen + grid - feedin;
            });
            const avgHouseLoad = houseLoadValues.length ? (houseLoadValues.reduce((s, v) => s + v, 0) / houseLoadValues.length) : 0;
            const maxHouseLoad = houseLoadValues.length ? Math.max(...houseLoadValues) : 0;
            
            let html = `
                <div class="stats-grid">
                    <div class="stat-box generation">
                        <div class="label">Avg Solar Generation</div>
                        <div class="value">${avgGen.toFixed(2)}<span class="unit">kW</span></div>
                    </div>
                    <div class="stat-box generation">
                        <div class="label">Peak Solar Generation</div>
                        <div class="value">${maxGen.toFixed(2)}<span class="unit">kW</span></div>
                    </div>
                    <div class="stat-box feedin">
                        <div class="label">Avg Feed-in</div>
                        <div class="value">${avgFeed.toFixed(2)}<span class="unit">kW</span></div>
                    </div>
                    <div class="stat-box consumption">
                        <div class="label">Avg Grid Import</div>
                        <div class="value">${avgGrid.toFixed(2)}<span class="unit">kW</span></div>
                    </div>
                    <div class="stat-box houseload">
                        <div class="label">Avg House Load</div>
                        <div class="value">${avgHouseLoad.toFixed(2)}<span class="unit">kW</span></div>
                    </div>
                    <div class="stat-box houseload">
                        <div class="label">Peak House Load</div>
                        <div class="value">${maxHouseLoad.toFixed(2)}<span class="unit">kW</span></div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="historyChartCanvas"></canvas>
                </div>
            `;
            
            content.innerHTML = html;
            
            // Render chart
            await ensureChartJs();
            
            if (historyChart) {
                historyChart.destroy();
            }
            
            const ctx = document.getElementById('historyChartCanvas').getContext('2d');
            
            // Prepare datasets - parse time strings from the response
            const labels = genData.map(d => {
                // Parse time format: "2025-12-01 23:20:14 AEDT+1100"
                // For better clarity, show date + time for boundary crossing
                if (typeof d.time === 'string') {
                    const parts = d.time.split(' ');
                    const [year, month, day] = parts[0].split('-');
                    const timeStr = parts[1];
                    // Just show HH:MM, date is implicit from chart context
                    return timeStr.substring(0, 5);
                }
                return formatTime(d.time);
            });
            
            // Use actual house loads power from inverter instead of calculated value
            // loadsPower represents the actual power consumption in the house
            const houseLoad = genData.map(d => {
                // Prefer actual loadsPower measurement if available
                if (loadsMap[d.time] !== undefined) {
                    return loadsMap[d.time];
                }
                // Fallback to calculation: Gen + Grid - FeedIn
                const gen = d.value || 0;
                const feedin = feedinMap[d.time] || 0;
                const grid = gridMap[d.time] || 0;
                return gen + grid - feedin;
            });
            
            historyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Solar Generation (kW)',
                            data: genData.map(d => d.value || 0),
                            borderColor: cssVar('--color-yellow'),
                            backgroundColor: 'rgba(255, 212, 59, 0.1)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 1
                        },
                        {
                            label: 'Feed-in (kW)',
                            data: feedData.map(d => d.value || 0),
                            borderColor: cssVar('--color-success'),
                            backgroundColor: 'rgba(126, 231, 135, 0.1)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 1
                        },
                        {
                            label: 'Grid Import (kW)',
                            data: gridData.map(d => d.value || 0),
                            borderColor: cssVar('--accent-blue'),
                            backgroundColor: 'rgba(88, 166, 255, 0.1)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 1
                        },
                        {
                            label: 'House Load (kW)',
                            data: houseLoad,
                            borderColor: cssVar('--color-danger'),
                            backgroundColor: 'rgba(255, 123, 114, 0.1)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { 
                            labels: { color: cssVar('--text-secondary'), usePointStyle: true }
                        },
                        tooltip: {
                            backgroundColor: cssVar('--bg-secondary'),
                            titleColor: cssVar('--text-primary'),
                            bodyColor: cssVar('--text-secondary'),
                            borderColor: cssVar('--border-primary'),
                            borderWidth: 1
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: cssVar('--text-secondary'), maxTicksLimit: 12 },
                            grid: { color: cssVar('--border-secondary') }
                        },
                        y: {
                            ticks: { color: cssVar('--text-secondary') },
                            grid: { color: cssVar('--border-secondary') },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // ==================== REPORTS ======================================
        async function fetchReport() {
            const btn = document.getElementById('btnFetchReport');
            const status = document.getElementById('reportStatus');
            const content = document.getElementById('reportContent');
            const timestamp = document.getElementById('reportTimestamp');
            
            btn.disabled = true;
            btn.innerHTML = '‚è≥ Loading...';
            status.className = 'status loading';
            status.textContent = 'Fetching report data from FoxESS...';
            
            try {
                const dimension = document.getElementById('reportDimension').value;
                const year = document.getElementById('reportYear').value;
                const month = document.getElementById('reportMonth').value;
                const acContext = await detectAcCoupledContext();
                
                let url = `/api/inverter/report?dimension=${dimension}&year=${year}&month=${month}`;
                
                const resp = await authenticatedFetch(url);
                const data = await resp.json();
                
                if (data.errno && data.errno !== 0) {
                    throw new Error(data.msg || 'API error');
                }

                const reportOptions = {};
                if (acContext.isLikelyAcCoupled) {
                    if (dimension === 'month') {
                        try {
                            const { beginSec, endSec, daysInMonth } = getMonthRangeSeconds(Number(year), Number(month));
                            const meterSeries = await fetchHistoryVariableSeries(beginSec, endSec, ['meterPower2', 'meterPower']);
                            const bucketed = integratePowerSeriesToBuckets(
                                meterSeries,
                                daysInMonth,
                                (ms) => new Date(ms).getDate() - 1
                            );
                            if (bucketed.some(v => v > 0)) {
                                reportOptions.generationValues = bucketed;
                                reportOptions.generationSourceLabel = 'meterPower2 estimate (AC-coupled)';
                            }
                        } catch (fallbackErr) {
                            console.warn('[Report] AC fallback generation from meterPower2 failed:', fallbackErr);
                        }
                    } else if (dimension === 'year') {
                        reportOptions.note = 'AC-coupled detected: yearly generation remains from FoxESS report API (meterPower2 remap currently applied to daily/monthly view).';
                    }
                }
                
                lastRawData = { type: 'report', data };
                updateRawDataViewer();
                
                await renderReportData(data, dimension, reportOptions);
                
                status.className = 'status success';
                status.textContent = reportOptions.generationSourceLabel
                    ? `‚úì Report loaded successfully (${reportOptions.generationSourceLabel})`
                    : `‚úì Report loaded successfully`;
                timestamp.textContent = `Updated: ${new Date().toLocaleTimeString('en-AU', { hour: '2-digit', minute: '2-digit', hour12: false })}`;
                
                setTimeout(() => { status.style.display = 'none'; }, 3000);
            } catch (e) {
                status.className = 'status error';
                status.textContent = `‚úó Error: ${e.message}`;
                content.innerHTML = `<div class="empty-state"><div class="icon">‚ùå</div><p>Failed to load report: ${e.message}</p></div>`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'üìä Fetch Report';
            }
        }

        async function renderReportData(data, dimension, options = {}) {
            const content = document.getElementById('reportContent');
            
            const result = data.result || data;
            if (!result || !Array.isArray(result) || result.length === 0) {
                content.innerHTML = '<div class="empty-state"><div class="icon">üì≠</div><p>No report data available</p></div>';
                return;
            }
            
            // Parse variables - API returns {variable, values: [...], unit}
            const variables = {};
            result.forEach(item => {
                if (item.variable && item.values && Array.isArray(item.values)) {
                    // Convert values array to objects with value and index
                    variables[item.variable] = {
                        ...item,
                        data: item.values.map((value, index) => ({
                            value: value,
                            index: index + 1  // 1-indexed
                        }))
                    };
                }
            });
            
            console.log('[Report] Parsed variables:', Object.keys(variables));
            console.log('[Report] Generation data count:', variables.generation?.data.length, 'values:', variables.generation?.values.slice(0, 5));
            
            let genData = variables.generation?.data || [];
            if (Array.isArray(options.generationValues) && options.generationValues.length > 0) {
                genData = options.generationValues.map((value, index) => ({
                    value: value || 0,
                    index: index + 1
                }));
            }
            const feedData = variables.feedin?.data || [];
            const gridData = variables.gridConsumption?.data || [];
            const chargeData = variables.chargeEnergyToTal?.data || [];
            const dischargeData = variables.dischargeEnergyToTal?.data || [];
            
            // Calculate totals
            const totalGen = genData.reduce((s, d) => s + (d.value || 0), 0);
            const totalFeed = feedData.reduce((s, d) => s + (d.value || 0), 0);
            const totalGrid = gridData.reduce((s, d) => s + (d.value || 0), 0);
            const totalCharge = chargeData.reduce((s, d) => s + (d.value || 0), 0);
            const totalDischarge = dischargeData.reduce((s, d) => s + (d.value || 0), 0);
            
            const labelMap = { day: 'Day', month: 'Month', year: 'Year' };
            const periodLabel = labelMap[dimension] || 'Period';
            
            let html = `
                <div class="stats-grid">
                    <div class="stat-box generation">
                        <div class="label">Total Generation${options.generationSourceLabel ? ' (AC est.)' : ''}</div>
                        <div class="value">${totalGen.toFixed(1)}<span class="unit">kWh</span></div>
                    </div>
                    <div class="stat-box feedin">
                        <div class="label">Total Feed-in</div>
                        <div class="value">${totalFeed.toFixed(1)}<span class="unit">kWh</span></div>
                    </div>
                    <div class="stat-box consumption">
                        <div class="label">Total Grid Import</div>
                        <div class="value">${totalGrid.toFixed(1)}<span class="unit">kWh</span></div>
                    </div>
                    <div class="stat-box charge">
                        <div class="label">Battery Charged</div>
                        <div class="value">${totalCharge.toFixed(1)}<span class="unit">kWh</span></div>
                    </div>
                    <div class="stat-box discharge">
                        <div class="label">Battery Discharged</div>
                        <div class="value">${totalDischarge.toFixed(1)}<span class="unit">kWh</span></div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="reportChartCanvas"></canvas>
                </div>
            `;

            if (options.generationSourceLabel || options.note) {
                html += `
                    <div style="margin-top:10px;padding:10px 12px;border-radius:8px;background:${cssVar('--accent-blue-bg')};border:1px solid ${cssVar('--border-primary')};color:${cssVar('--accent-blue')};font-size:12px;">
                        ${options.generationSourceLabel ? `Source: <strong>${options.generationSourceLabel}</strong>. ` : ''}
                        ${options.note ? options.note : ''}
                    </div>
                `;
            }
            
            content.innerHTML = html;
            
            // Render chart
            await ensureChartJs();
            
            if (reportChart) {
                reportChart.destroy();
            }
            
            // Wait for canvas to be available in DOM
            await new Promise(resolve => setTimeout(resolve, 50));
            
            const canvas = document.getElementById('reportChartCanvas');
            if (!canvas) {
                console.error('Chart canvas not found in DOM');
                content.innerHTML += '<div style="color:red">Error: Chart canvas not available</div>';
                return;
            }
            const ctx = canvas.getContext('2d');
            
            // Labels based on dimension
            let labels = [];
            if (dimension === 'month') {
                // For month view, show day numbers (1-31)
                labels = genData.map((d, i) => `Day ${i + 1}`);
            } else if (dimension === 'day') {
                // For day view, show hour numbers (0-23)
                labels = genData.map((d, i) => `${String(i).padStart(2, '0')}:00`);
            } else {
                // For year view, show month names
                labels = genData.map((d, i) => ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][i] || `M${i + 1}`);
            }
            
            reportChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: options.generationSourceLabel ? 'Generation (kWh, AC estimate)' : 'Generation (kWh)',
                            data: genData.map(d => d.value || 0),
                            borderColor: cssVar('--color-yellow'),
                            backgroundColor: 'rgba(255, 212, 59, 0.1)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            pointBackgroundColor: cssVar('--color-yellow')
                        },
                        {
                            label: 'Feed-in (kWh)',
                            data: feedData.map(d => d.value || 0),
                            borderColor: cssVar('--color-success'),
                            backgroundColor: 'rgba(126, 231, 135, 0.1)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            pointBackgroundColor: cssVar('--color-success')
                        },
                        {
                            label: 'Grid Import (kWh)',
                            data: gridData.map(d => d.value || 0),
                            borderColor: cssVar('--accent-blue'),
                            backgroundColor: 'rgba(88, 166, 255, 0.1)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            pointBackgroundColor: cssVar('--accent-blue')
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { 
                            labels: { color: cssVar('--text-secondary'), usePointStyle: true }
                        },
                        tooltip: {
                            backgroundColor: cssVar('--bg-secondary'),
                            titleColor: cssVar('--text-primary'),
                            bodyColor: cssVar('--text-secondary'),
                            borderColor: cssVar('--border-primary'),
                            borderWidth: 1
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: cssVar('--text-secondary'), maxTicksLimit: 12 },
                            grid: { color: cssVar('--border-secondary') }
                        },
                        y: {
                            ticks: { color: cssVar('--text-secondary') },
                            grid: { color: cssVar('--border-secondary') },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // ==================== GENERATION ======================================
        async function fetchGeneration() {
            const btn = document.getElementById('btnFetchGeneration');
            const status = document.getElementById('generationStatus');
            const content = document.getElementById('generationContent');
            const timestamp = document.getElementById('generationTimestamp');
            
            btn.disabled = true;
            btn.innerHTML = '‚è≥ Loading...';
            status.className = 'status loading';
            status.textContent = 'Fetching generation data from FoxESS...';
            
            try {
                const acContext = await detectAcCoupledContext();
                const resp = await authenticatedFetch('/api/inverter/generation');
                const data = await resp.json();
                
                if (data.errno && data.errno !== 0) {
                    throw new Error(data.msg || 'API error');
                }

                const generationOptions = {};
                if (acContext.isLikelyAcCoupled) {
                    try {
                        const now = new Date();
                        const { beginSec: todayBeginSec, endSec: todayEndSec } = getTodayRangeSeconds();
                        const { beginSec: monthBeginSec, endSec: monthEndSec } = getMonthRangeSeconds(now.getFullYear(), now.getMonth() + 1);

                        const [todaySeries, monthSeries] = await Promise.all([
                            fetchHistoryVariableSeries(todayBeginSec, todayEndSec, ['meterPower2', 'meterPower']),
                            fetchHistoryVariableSeries(monthBeginSec, monthEndSec, ['meterPower2', 'meterPower'])
                        ]);

                        const todayKwh = integratePowerSeriesToBuckets(todaySeries, 1, () => 0)[0] || 0;
                        const monthKwh = integratePowerSeriesToBuckets(monthSeries, 1, () => 0)[0] || 0;

                        if (todayKwh > 0 || monthKwh > 0) {
                            generationOptions.today = todayKwh;
                            generationOptions.month = monthKwh;
                            generationOptions.sourceLabel = 'meterPower2 estimate (AC-coupled)';
                        }
                    } catch (fallbackErr) {
                        console.warn('[Generation] AC fallback from meterPower2 failed:', fallbackErr);
                    }
                }
                
                lastRawData = { type: 'generation', data };
                updateRawDataViewer();
                
                renderGenerationData(data, generationOptions);
                
                status.className = 'status success';
                status.textContent = generationOptions.sourceLabel
                    ? `‚úì Generation data loaded (${generationOptions.sourceLabel})`
                    : `‚úì Generation data loaded successfully`;
                timestamp.textContent = `Updated: ${new Date().toLocaleTimeString('en-AU', { hour: '2-digit', minute: '2-digit', hour12: false })}`;
                
                setTimeout(() => { status.style.display = 'none'; }, 3000);
            } catch (e) {
                status.className = 'status error';
                status.textContent = `‚úó Error: ${e.message}`;
                content.innerHTML = `<div class="empty-state"><div class="icon">‚ùå</div><p>Failed to load generation: ${e.message}</p></div>`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'üîã Fetch Generation Data';
            }
        }

        // ==================== RENDER GENERATION DATA ====================
        function renderGenerationData(data, options = {}) {
            const content = document.getElementById('generationContent');
            
            const result = data.result || data;
            if (!result) {
                content.innerHTML = '<div class="empty-state"><div class="icon">üì≠</div><p>No generation data available</p></div>';
                return;
            }
            
            // FoxESS generation response includes cumulative values
            const today = options.today ?? result.today ?? result.todayGeneration ?? 0;
            const month = options.month ?? result.month ?? result.monthGeneration ?? 0;
            const year = result.year || result.yearGeneration || 0;
            const total = result.cumulative || result.cumulativeGeneration || result.total || 0;
            
            let html = `
                <div class="stats-grid">
                    <div class="stat-box generation">
                        <div class="label">Today</div>
                        <div class="value">${Number(today).toFixed(1)}<span class="unit">kWh</span></div>
                    </div>
                    <div class="stat-box generation">
                        <div class="label">This Month</div>
                        <div class="value">${Number(month).toFixed(1)}<span class="unit">kWh</span></div>
                    </div>
                    <div class="stat-box generation">
                        <div class="label">Lifetime Total</div>
                        <div class="value">${Number(total).toFixed(0)}<span class="unit">kWh</span></div>
                    </div>
                </div>
            `;

            if (options.sourceLabel) {
                html += `
                    <div style="margin-top:10px;padding:10px 12px;border-radius:8px;background:${cssVar('--accent-blue-bg')};border:1px solid ${cssVar('--border-primary')};color:${cssVar('--accent-blue')};font-size:12px;">
                        Source: <strong>${options.sourceLabel}</strong>. Year and lifetime values remain from FoxESS generation API.
                    </div>
                `;
            }
            
            // Add any additional fields from the response
            const knownKeys = ['today', 'month', 'year', 'cumulative', 'todayGeneration', 'monthGeneration', 'yearGeneration', 'cumulativeGeneration', 'total'];
            const extraFields = Object.entries(result).filter(([k, v]) => !knownKeys.includes(k) && typeof v === 'number');
            
            if (extraFields.length > 0) {
                html += `
                    <table class="data-table">
                        <thead>
                            <tr><th>Metric</th><th>Value</th></tr>
                        </thead>
                        <tbody>
                            ${extraFields.map(([k, v]) => `
                                <tr>
                                    <td>${k}</td>
                                    <td class="value">${typeof v === 'number' ? v.toFixed(2) : v}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            }
            
            content.innerHTML = html;
        }

        // ==================== INITIALIZATION ====================
        // Initialize price datepickers on page load
        document.addEventListener('DOMContentLoaded', () => {
            try { initPriceDatepickers(); } catch (error) { console.warn('Failed to init price datepickers', error); }
        });

        // Initialize Firebase on page load
        AppShell.init({
            pageName: 'history',
            autoMetrics: true,
            onReady: () => {
                try { TourEngine.init(window.apiClient); TourEngine.resume(); } catch(e) {}
                try { loadDeviceSn(); } catch (error) { console.warn('Failed to load device SN', error); }
            }
        });

        // ==================== RAW DATA ====================
        function toggleRawData() {
            const el = document.getElementById('rawDataContent');
            el.style.display = el.style.display === 'none' ? 'block' : 'none';
        }

        function updateRawDataViewer() {
            const pre = document.getElementById('rawDataPre');
            if (lastRawData) {
                pre.textContent = JSON.stringify(lastRawData, null, 2);
            }
        }

        function toggleHistoryVariables() {
            if (!historyVariables) {
                alert('No history data loaded yet');
                return;
            }

            // Create a table showing all variables with sample values
            let html = `<div style="background: ${cssVar('--bg-terminal')}; padding: 16px; border-radius: 8px; margin: 16px 0; font-size: 12px;">`;
            html += `<h3 style="margin-top: 0; color: ${cssVar('--color-yellow')};">Available Variables in Last Fetch:</h3>`;
            html += `<table style="width: 100%; border-collapse: collapse; color: ${cssVar('--text-primary')};">`;
            html += `<tr style="border-bottom: 1px solid ${cssVar('--border-primary')};"><th style="text-align: left; padding: 8px;">Variable</th><th style="text-align: left; padding: 8px;">Count</th><th style="text-align: left; padding: 8px;">Sample Values (first 5)</th></tr>`;
            
            Object.entries(historyVariables).forEach(([name, data]) => {
                if (data && data.length > 0) {
                    const samples = data.slice(0, 5).map(d => `${d.time}: ${d.value.toFixed(2)}`).join(' | ');
                    html += `<tr style="border-bottom: 1px solid ${cssVar('--border-primary')};"><td style="padding: 8px; color: ${cssVar('--accent-blue')}; font-weight: bold;">${name}</td><td style="padding: 8px;">${data.length}</td><td style="padding: 8px; font-family: monospace; font-size: 11px;">${samples}</td></tr>`;
                }
            });
            
            html += '</table></div>';
            
            // Show in a modal or alert
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 9999;';
            modal.innerHTML = `
                <div style="background: ${cssVar('--bg-secondary')}; border: 1px solid ${cssVar('--border-primary')}; border-radius: 12px; padding: 24px; max-width: 900px; max-height: 80vh; overflow: auto; color: ${cssVar('--text-primary')};">
                    ${html}
                    <button class="btn btn-primary" onclick="this.closest('div').parentElement.remove()" style="margin-top: 16px;">Close</button>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Load API call metrics (per-day) and display in footer
        async function loadApiMetrics(days = 1) {
            try {
                // Use scope=user to show per-user metrics, not global platform totals
                const resp = await authenticatedFetch(`/api/metrics/api-calls?days=${encodeURIComponent(days)}&scope=user`);
                const data = await resp.json();
                if (!data || data.errno !== 0 || !data.result) return;
                const keys = Object.keys(data.result).sort().reverse();
                const todayKey = keys[0];
                const today = data.result[todayKey] || {};

                document.getElementById('metricsDate').textContent = formatDate(new Date(todayKey), false);
                document.getElementById('countFox').textContent = today.foxess ?? 0;
                document.getElementById('countAmber').textContent = today.amber ?? 0;
                document.getElementById('countWeather').textContent = today.weather ?? 0;
            } catch (e) {
                console.warn('Failed to load api metrics', e.message);
            }
        }

        // Helper function for date formatting
        function formatDate(date, includeTime = true) {
            const dateStr = date.toLocaleDateString('en-AU', { month: 'short', day: 'numeric' });
            if (includeTime) {
                const timeStr = date.toLocaleTimeString('en-AU', { hour: '2-digit', minute: '2-digit', hour12: false });
                return `${dateStr} ${timeStr}`;
            }
            return dateStr;
        }

        // ==================== AMBER HISTORICAL PRICES ====================

        let amberHistoricalChart = null;

        // Initialize date pickers with sensible defaults (last 7 days)
        function initPriceDatepickers() {
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 7);
            
            document.getElementById('priceStartDate').value = startDate.toISOString().split('T')[0];
            document.getElementById('priceEndDate').value = endDate.toISOString().split('T')[0];
        }

        // Validate date inputs and return structured validation result
        function validatePriceDateRange() {
            const startInput = document.getElementById('priceStartDate').value;
            const endInput = document.getElementById('priceEndDate').value;

            if (!startInput) return { valid: false, error: 'Start date is required' };
            if (!endInput) return { valid: false, error: 'End date is required' };

            // Parse dates in local timezone without timezone shift
            // HTML5 date input gives YYYY-MM-DD in local timezone
            const [startYear, startMonth, startDay] = startInput.split('-').map(Number);
            const [endYear, endMonth, endDay] = endInput.split('-').map(Number);
            
            const startDate = new Date(startYear, startMonth - 1, startDay, 0, 0, 0, 0);
            const endDate = new Date(endYear, endMonth - 1, endDay, 0, 0, 0, 0);
            
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Start of today in local time

            if (startDate > endDate) {
                return { valid: false, error: 'Start date must be before end date' };
            }

            // Allow today's date (tomorrow is when it becomes future)
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);
            if (endDate >= tomorrow) {
                return { valid: false, error: 'End date cannot be in the future' };
            }

            // Check maximum range (Amber API chunks at 14 days, we allow up to 60 days = ~5 chunks)
            // Count days inclusively: if start=Nov 1 and end=Nov 5, that's 5 days
            const maxRangeDays = 60;
            const rangeDays = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
            console.log('[Prices] Date range calculation:', { 
                startDate: startDate.toISOString(), 
                endDate: endDate.toISOString(), 
                msecDiff: endDate - startDate,
                daysDiff: (endDate - startDate) / (1000 * 60 * 60 * 24),
                rangeDays 
            });
            if (rangeDays > maxRangeDays) {
                return { valid: false, error: `Maximum range is ${maxRangeDays} days (you selected ${rangeDays} days). Please narrow the date range.` };
            }

            // Warn if range is large (>30 days = multiple chunks)
            if (rangeDays > 30) {
                return { 
                    valid: true, 
                    warning: `Large range (${rangeDays} days) will be fetched in multiple 14-day chunks`,
                    dates: { startDate, endDate, rangeDays }
                };
            }

            return { valid: true, dates: { startDate, endDate, rangeDays } };
        }

        async function fetchAmberHistoricalPrices() {
            const btn = document.getElementById('btnFetchPrices');
            const status = document.getElementById('pricesStatus');
            const content = document.getElementById('pricesContent');
            const statsContainer = document.getElementById('pricesStats');
            const timestamp = document.getElementById('pricesTimestamp');

            // Validate inputs
            const validation = validatePriceDateRange();
            if (!validation.valid) {
                status.className = 'status error';
                status.style.display = 'block';
                status.textContent = `‚úó ${validation.error}`;
                console.log('[Prices] Validation failed:', validation.error);
                btn.disabled = false;
                btn.innerHTML = 'üìà Fetch Prices';
                return;
            }

            if (validation.warning) {
                console.log(`[Prices] Warning: ${validation.warning}`);
            }

            btn.disabled = true;
            btn.innerHTML = '‚è≥ Loading prices...';
            status.className = 'status loading';
            status.style.display = 'block';
            status.textContent = '‚è≥ Fetching historical prices...';
            statsContainer.style.display = 'none';
            content.innerHTML = '';

            try {
                // Ensure Chart.js is loaded before rendering
                await ensureChartJs();
                
                // Get site ID first (with debug info)
                const sitesResp = await apiClient.getAmberSites();
                console.log('[Prices] getAmberSites response:', sitesResp);
                
                // Extract sites from response - handle both array and {errno, result} formats
                let sites = [];
                if (Array.isArray(sitesResp)) {
                    sites = sitesResp;
                } else if (sitesResp && sitesResp.result && Array.isArray(sitesResp.result)) {
                    sites = sitesResp.result;
                } else if (sitesResp && sitesResp.errno === 401) {
                    throw new Error('Not authenticated. Please log in first.');
                }
                
                if (sites.length === 0) {
                    // Try to get more debug info
                    const debugResp = await apiClient.fetch('/api/amber/sites?debug=true');
                    const debugJson = await debugResp.json();
                    console.log('[Prices] Debug response:', debugJson);
                    throw new Error('No Amber sites available. Please configure your Amber API key in Settings ‚Üí Integrations ‚Üí Amber API.');
                }
                
                const siteId = sites[0].id;
                const { dates } = validation;
                const resolution = document.getElementById('priceResolution').value;

                // Format dates as YYYY-MM-DD (keep in local timezone, no UTC conversion)
                const startDate = dates.startDate.getFullYear() + '-' + 
                    String(dates.startDate.getMonth() + 1).padStart(2, '0') + '-' + 
                    String(dates.startDate.getDate()).padStart(2, '0');
                const endDate = dates.endDate.getFullYear() + '-' + 
                    String(dates.endDate.getMonth() + 1).padStart(2, '0') + '-' + 
                    String(dates.endDate.getDate()).padStart(2, '0');

                console.log('[Prices] Date conversion check:', {
                    inputStart: document.getElementById('priceStartDate').value,
                    inputEnd: document.getElementById('priceEndDate').value,
                    parsedStartDate: dates.startDate.toString(),
                    parsedEndDate: dates.endDate.toString(),
                    formattedStart: startDate,
                    formattedEnd: endDate
                });

                status.textContent = `‚è≥ Fetching prices for ${dates.rangeDays} days at ${resolution}-minute resolution...`;
                status.textContent += ` [Requesting: ${startDate} to ${endDate}]`;
                console.log('[Prices] Request details:', { siteId, startDate, endDate, resolution });

                // Fetch historical prices (actual only, no forecasts)
                const pricesResp = await apiClient.getAmberHistoricalPrices(siteId, startDate, endDate, resolution, true);
                
                console.log('[Prices] Response from API:', pricesResp);
                console.log('[Prices] First 3 price timestamps:', pricesResp.result?.slice(0, 3).map(p => ({ startTime: p.startTime, channel: p.channelType })));
                
                if (pricesResp.errno && pricesResp.errno !== 0) {
                    throw new Error(pricesResp.error || `API Error ${pricesResp.errno}`);
                }

                const prices = Array.isArray(pricesResp) ? pricesResp : pricesResp.result || [];
                console.log('[Prices] Parsed prices array:', { count: prices.length, sample: prices.slice(0, 2) });
                
                if (prices.length === 0) {
                    throw new Error('No price data available for this date range');
                }

                // Process and display data
                renderAmberHistoricalChart(prices);
                
                // Render statistics with error handling
                try {
                    renderPriceStatistics(prices);
                } catch (statsErr) {
                    console.warn('[Prices] Statistics rendering failed (non-critical):', statsErr);
                    // Continue even if stats fail - chart is more important
                }

                // Clear any previous error and show success
                const errorMessage = document.querySelector('#pricesContent .empty-state');
                if (errorMessage) {
                    errorMessage.remove();
                }
                
                status.className = 'status success';
                status.textContent = `‚úì Loaded ${prices.length} price intervals`;
                timestamp.textContent = `Updated: ${new Date().toLocaleTimeString('en-AU', { hour: '2-digit', minute: '2-digit', hour12: false })}`;

                setTimeout(() => { status.style.display = 'none'; }, 3000);
            } catch (e) {
                status.className = 'status error';
                status.textContent = `‚úó Error: ${e.message}`;
                content.innerHTML = `<div class="empty-state"><div class="icon">‚ùå</div><p>${e.message}</p></div>`;
                console.error('[Prices] Error:', e);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'üìà Fetch Prices';
            }
        }

        function renderPriceStatistics(prices) {
            console.log('[Prices] renderPriceStatistics called with', prices.length, 'prices');
            
            // Log unique channel types to debug
            const uniqueChannels = [...new Set(prices.map(p => p.channelType))];
            console.log('[Prices] Unique channel types:', uniqueChannels);
            
            // Separate buy and feed-in prices
            const buyPrices = prices
                .filter(p => p.channelType === 'general')
                .map(p => p.perKwh)
                .filter(v => typeof v === 'number');

            const feedPrices = prices
                .filter(p => p.channelType === 'feedIn')
                .map(p => -Math.round(p.perKwh)) // Convert to display format (negative = you earn)
                .filter(v => typeof v === 'number');

            console.log('[Prices] Separated data:', { buyCount: buyPrices.length, feedCount: feedPrices.length });

            if (buyPrices.length === 0 || feedPrices.length === 0) {
                console.warn('[Prices] Insufficient data for statistics - buy:', buyPrices.length, 'feed:', feedPrices.length);
                return;
            }

            // Calculate statistics
            const calc = {
                buyMin: Math.min(...buyPrices),
                buyMax: Math.max(...buyPrices),
                buyAvg: (buyPrices.reduce((a, b) => a + b, 0) / buyPrices.length),
                feedMin: Math.min(...feedPrices),
                feedMax: Math.max(...feedPrices),
                feedAvg: (feedPrices.reduce((a, b) => a + b, 0) / feedPrices.length)
            };

            // Update stat boxes with coloring
            document.getElementById('statBuyMin').textContent = calc.buyMin.toFixed(1);
            document.getElementById('statBuyAvg').textContent = calc.buyAvg.toFixed(1);
            document.getElementById('statBuyMax').textContent = calc.buyMax.toFixed(1);
            document.getElementById('statFeedMin').textContent = calc.feedMin.toFixed(1);
            document.getElementById('statFeedAvg').textContent = calc.feedAvg.toFixed(1);
            document.getElementById('statFeedMax').textContent = calc.feedMax.toFixed(1);

            document.getElementById('pricesStats').style.display = 'block';
            console.log('[Prices] Statistics rendered successfully');
        }

        function renderAmberHistoricalChart(prices) {
            console.log('[Prices] renderAmberHistoricalChart called with', prices.length, 'prices');
            
            // Separate data by channel type
            const generalPrices = prices.filter(p => p.channelType === 'general');
            const feedinPrices = prices.filter(p => p.channelType === 'feedIn');

            console.log('[Prices] Chart data - general:', generalPrices.length, 'feedIn:', feedinPrices.length);

            // Build a unified, sorted list of timestamps from all prices so each dataset aligns
            const allTimestamps = Array.from(new Set(prices.map(p => p.startTime))).sort((a, b) => new Date(a) - new Date(b));

            // Create labels with both date and time for every interval
            const timestamps = allTimestamps.map(ts => {
                const date = new Date(ts);
                const dateStr = date.toLocaleDateString('en-AU', { 
                    weekday: 'short',
                    day: '2-digit',
                    month: 'short',
                    timeZone: 'Australia/Sydney'
                });
                const timeStr = date.toLocaleTimeString('en-AU', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false,
                    timeZone: 'Australia/Sydney'
                });
                // Always include date and time (date on first line, time on second)
                return `${dateStr}\n${timeStr}`;
            });

            // Build maps for fast lookup so we can align values to the unified timestamps
            const generalMap = new Map(generalPrices.map(p => [p.startTime, p.perKwh]));
            const feedMap = new Map(feedinPrices.map(p => [p.startTime, -Math.round(p.perKwh)])); // Display as positive

            // Extract price data aligned with timestamps; use null for missing points
            const buyData = allTimestamps.map(ts => generalMap.has(ts) ? generalMap.get(ts) : null);
            const feedData = allTimestamps.map(ts => feedMap.has(ts) ? feedMap.get(ts) : null);

            console.log('[Prices] Price data - buy samples:', buyData.slice(0, 3), 'feed samples:', feedData.slice(0, 3));

            // Get canvas element
            const canvas = document.getElementById('amberHistoricalChart');
            const ctx = canvas.getContext('2d');

            // Destroy previous chart if exists
            if (amberHistoricalChart) {
                amberHistoricalChart.destroy();
            }

            // Create new chart
            amberHistoricalChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timestamps,
                    datasets: [
                        {
                            label: 'Buy Price (¬¢/kWh)',
                            data: buyData,
                            borderColor: cssVar('--color-orange'),
                            backgroundColor: 'rgba(240, 136, 62, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.3,
                            pointRadius: 1,
                            pointHoverRadius: 4,
                            pointBackgroundColor: cssVar('--color-orange'),
                            pointBorderColor: '#fff',
                            pointBorderWidth: 1,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Feed-in Price (¬¢/kWh)',
                            data: feedData,
                            borderColor: cssVar('--accent-blue'),
                            backgroundColor: 'rgba(88, 166, 255, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.3,
                            pointRadius: 1,
                            pointHoverRadius: 4,
                            pointBackgroundColor: cssVar('--accent-blue'),
                            pointBorderColor: '#fff',
                            pointBorderWidth: 1,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                color: cssVar('--text-secondary'),
                                boxWidth: 12,
                                padding: 12,
                                font: { size: 12, weight: '500' }
                            }
                        },
                        tooltip: {
                            backgroundColor: cssVar('--bg-secondary'),
                            titleColor: cssVar('--text-primary'),
                            bodyColor: cssVar('--text-primary'),
                            borderColor: cssVar('--border-primary'),
                            borderWidth: 1,
                            padding: 8,
                            displayColors: true,
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(2)}¬¢`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            ticks: {
                                color: cssVar('--text-secondary'),
                                font: { size: 11 },
                                callback: function(value) {
                                    return value.toFixed(1) + '¬¢';
                                }
                            },
                            grid: {
                                color: cssVar('--border-secondary'),
                                drawBorder: false
                            },
                            title: {
                                display: true,
                                text: 'Buy Price',
                                color: cssVar('--text-primary')
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            ticks: {
                                color: cssVar('--text-secondary'),
                                font: { size: 11 },
                                callback: function(value) {
                                    return value.toFixed(1) + '¬¢';
                                }
                            },
                            grid: {
                                drawOnChartArea: false,
                                drawBorder: false
                            },
                            title: {
                                display: true,
                                text: 'Feed-in Price',
                                color: cssVar('--text-primary')
                            }
                        },
                        x: {
                            ticks: {
                                color: cssVar('--text-secondary'),
                                font: { size: 10 },
                                maxTicksLimit: 15,
                                maxRotation: 45,
                                minRotation: 0
                            },
                            grid: {
                                color: cssVar('--border-secondary'),
                                drawBorder: false
                            }
                        }
                    }
                }
            });
        }

        // Initialize price datepickers on page load
        document.addEventListener('DOMContentLoaded', () => {
            try { initPriceDatepickers(); } catch (error) { console.warn('Failed to init price datepickers', error); }
        });

        // Initialize Firebase on page load
        AppShell.init({
            pageName: 'history',
            autoMetrics: true,
            onReady: () => {
                try { loadDeviceSn(); } catch (error) { console.warn('Failed to load device SN', error); }
            }
        });

        // WIP Pages visibility - Tesla & Topology Discovery (admin only)
        if (typeof window.auth !== 'undefined' && window.auth) {
            window.auth.onAuthStateChanged((user) => {
                if (user && user.email === 'sardanapalos928@hotmail.com') {
                    const teslaLink = document.getElementById('teslaNavLink');
                    const topologyLink = document.getElementById('topologyNavLink');
                    if (teslaLink) teslaLink.style.display = '';
                    if (topologyLink) topologyLink.style.display = '';
                }
            });
        }
    </script>
</body>
</html>
