<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FoxESS Solar Dashboard</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <!-- Firebase Auth Configuration -->
    <script src="js/firebase-config.js"></script>
    <script src="js/firebase-auth.js"></script>
    <script src="js/api-client.js"></script>
    <script src="js/shared-utils.js"></script>
    <script src="js/app-shell.js"></script>
    <link rel="stylesheet" href="css/shared-styles.css" />
    <style>
        
        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 24px;
            background: rgba(13, 17, 23, 0.8);
            border-bottom: 1px solid rgba(48, 54, 61, 0.6);
            backdrop-filter: blur(10px);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .header h1 {
            font-size: 1.4rem;
            font-weight: 600;
            color: #58a6ff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .header h1 .logo {
            font-size: 1.6rem;
        }
        .device-input {
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(33, 38, 45, 0.8);
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid rgba(48, 54, 61, 0.8);
        }
        .device-input label {
            font-size: 12px;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .device-input input {
            background: transparent;
            border: none;
            color: #e6edf3;
            font-size: 13px;
            width: 200px;
            outline: none;
        }
        .device-input input::placeholder {
            color: #484f58;
        }

        .auth-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            flex-direction: column;
            gap: 16px;
        }
        .auth-loading .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(88, 166, 255, 0.2);
            border-top-color: #58a6ff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Main Layout */
        .main-layout {
            display: flex;
            height: calc(100vh - 65px);
        }
        .left-panel {
            flex: 1;
            padding: 20px;
            /* Allow child panels to manage their own scrolling. This prevents the
               left-panel's scrollbar from capturing scroll events intended for the
               automation panel's internal scroller (FAQ worked because it set its
               inner card-body to scroll). */
            overflow-y: visible;
            transition: margin-right 0.3s ease;
        }
        .left-panel.panel-open {
            margin-right: 0;
        }

        /* Priority Row - Weather, Prices, Inverter */
        .priority-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 20px;
        }
        @media (max-width: 1400px) {
            .priority-row {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        @media (max-width: 900px) {
            .priority-row {
                grid-template-columns: 1fr;
            }
        }

        /* Priority Badge for Automation Rules */
        .priority-badge {
            display: inline-flex;
            align-items: center;

        }

        /* Small info tooltip icon used next to location headers when fallback coords are used */
        .info-tip {
            display: inline-block;
            width:18px;
            height:18px;
            line-height:18px;
            text-align:center;
            border-radius:50%;
            background:rgba(88,166,255,0.08);
            color:#58a6ff;
            font-size:12px;
            margin-left:8px;
            cursor:help;
            border:1px solid rgba(88,166,255,0.06);
        }
            justify-content: center;
            font-weight: 700;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            min-width: 24px;
        }
        .priority-badge.p1 { background: #ff6b6b; color: #fff; } /* High priority - Red */
        .priority-badge.p2 { background: #ff922b; color: #000; } /* Medium-high - Orange */
        .priority-badge.p3 { background: #ffd43b; color: #000; } /* Medium - Yellow */
        .priority-badge.p4, .priority-badge.p5 { background: #51cf66; color: #000; } /* Lower - Green */
        .priority-badge.p-low { background: #30363d; color: #8b949e; } /* Very low */

        /* Secondary Grid */
        .secondary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 16px;
        }

        /* Cards */
        .card {
            background: linear-gradient(145deg, rgba(33, 38, 45, 0.9), rgba(22, 27, 34, 0.95));
            border-radius: 12px;
            border: 1px solid rgba(48, 54, 61, 0.6);
            overflow: hidden;
            transition: all 0.2s ease;
        }
        .card:hover {
            border-color: rgba(88, 166, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 18px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(48, 54, 61, 0.4);
        }
        .card-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            font-weight: 600;
            color: #e6edf3;
        }
        .card-title .icon {
            font-size: 18px;
        }
        .card-badge {
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 12px;
            background: rgba(88, 166, 255, 0.15);
            color: #58a6ff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .card-body {
            padding: 16px 18px;
        }

        /* Priority Card Variants */
        .card.priority {
            border-color: rgba(88, 166, 255, 0.2);
        }
        .card.priority .card-header {
            background: linear-gradient(135deg, rgba(88, 166, 255, 0.08), transparent);
        }

        /* Buttons */
        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 14px;
            background: rgba(33, 38, 45, 0.8);
            border: 1px solid rgba(48, 54, 61, 0.8);
            border-radius: 8px;
            color: #e6edf3;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
            margin-bottom: 6px;
        }
        .btn:hover {
            background: rgba(48, 54, 61, 0.8);
            border-color: rgba(88, 166, 255, 0.4);
            transform: translateY(-1px);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn-primary {
            background: linear-gradient(135deg, #238636, #1a7f37);
            border-color: #238636;
        }
        .btn-primary:hover {
            background: linear-gradient(135deg, #2ea043, #238636);
            border-color: #2ea043;
        }
        .btn-sm {
            padding: 8px 12px;
            font-size: 12px;
        }
        .btn-icon {
            width: auto;
            padding: 8px 12px;
        }

        /* Inputs */
        .input {
            width: 100%;
            padding: 10px 12px;
            background: rgba(13, 17, 23, 0.6);
            border: 1px solid rgba(48, 54, 61, 0.8);
            border-radius: 8px;
            color: #e6edf3;
            font-size: 13px;
            transition: all 0.2s ease;
        }
        .input:focus {
            outline: none;
            border-color: #58a6ff;
            box-shadow: 0 0 0 3px rgba(88, 166, 255, 0.1);
        }
        .input::placeholder {
            color: #484f58;
        }
        .input-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        .input-group {
            flex: 1;
        }
        .input-group label {
            display: block;
            font-size: 11px;
            color: #8b949e;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        select.input {
            cursor: pointer;
        }

        /* Data Display Cards */
        .data-card {
            background: rgba(13, 17, 23, 0.5);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
            min-height: 80px;
        }
        .data-card.success {
            border-left: 3px solid #238636;
        }
        .data-card.info {
            border-left: 3px solid #58a6ff;
        }

        /* Live Data Display */
        .live-stat {
            display: flex;
            align-items: baseline;
            gap: 8px;
            padding: 8px 0;
        }
        .live-stat .value {
            font-size: 28px;
            font-weight: 700;
            color: #58a6ff;
        }
        .live-stat .unit {
            font-size: 14px;
            color: #8b949e;
        }
        .live-stat .label {
            font-size:12px;
            color: #8b949e;
            margin-left: 6px;
        }
        .stat-row {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }
        .stat-item {
            flex: 1;
            min-width: 100px;
            padding: 12px;
            background: rgba(13, 17, 23, 0.5);
            border-radius: 8px;
            text-align: center;
            position: relative;
        }
        .stat-item .value {
            font-size: 20px;
            font-weight: 600;
            color: #7ee787;
        }
        /* Smaller inline status (e.g. "(discharging)") shown next to main value */
        .stat-item .value .substatus {
            font-size: 0.55em;
            font-weight: 400;
            color: #8b949e;
            margin-left: 6px;
            vertical-align: baseline;
        }
        .stat-item .label {
            font-size: 11px;
            color: #8b949e;
            margin-top: 4px;
        }
        .stat-item .tile-icon {
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 6px auto;
            width: 30px;
            height: 30px;
            border-radius: 6px;
            color: inherit;
            background: rgba(255,255,255,0.02);
        }
        /* Battery SVG sizing and charging animation */
        /* Larger battery tile for improved alignment */
        .stat-item.battery-tile { min-width: 180px; padding: 12px 18px; display:flex; flex-direction:column; align-items:center; justify-content:center; }
        .tile-icon.battery { width: 54px; height: 60px; padding-top: 2px; }
        .tile-icon.battery svg { width: 36px; height: 52px; display:block; }
        .tile-icon.battery .level { transition: all 600ms cubic-bezier(.2,.9,.2,1); }
        .tile-icon.battery.charging { box-shadow: 0 6px 18px rgba(88,166,255,0.12); }
        .tile-icon.battery.charging svg { filter: drop-shadow(0 4px 8px rgba(88,166,255,0.18)); }
        @keyframes batt-pulse { 0% { opacity: 0.95 } 50% { opacity: 1 } 100% { opacity: 0.95 } }
        .tile-icon.battery.charging { animation: batt-pulse 1.2s infinite ease-in-out; }
        .stat-item.warning .value { color: #d29922; }
        .stat-item.danger .value { color: #f85149; }

        /* Extreme daily forecast tiles (stronger amber tint for visibility) */
        .stat-item.extreme {
            border: 1px solid rgba(255,176,32,0.45);
            background: linear-gradient(180deg, rgba(255,176,32,0.14), rgba(22,27,34,0.60));
            box-shadow: 0 8px 28px rgba(255,176,32,0.12), inset 0 1px 0 rgba(255,255,255,0.02);
        }

        /* Weather days specific layout: override default .stat-item flex for day tiles */
        .weather-days {
            display:flex;
            gap:6px;
            flex-wrap:wrap;
            margin-top:10px;
        }
        .weather-days .stat-item {
            box-sizing: border-box;
            /* Allow forecast tiles to grow slightly so the last row doesn't leave
               a large empty gap when there are many items. Also restrict maximum
               width so items remain card-like on very wide screens. */
            flex: 1 1 140px;
            max-width: 180px;
            min-width: 0;
            padding: 8px;
            text-align: left;
            position: relative; /* allow icon overlay */
        }

        /* Money bag indicator for very large feed-in prices */
        .money-bag {
            display:inline-block;
            font-size:14px;
            margin-left:6px;
            filter: drop-shadow(0 1px 0 rgba(0,0,0,0.6));
            line-height:1;
        }
        @media (max-width: 600px) {
            .weather-days .stat-item { flex: 0 0 120px; }
        }

        /* Price Colors */
        .price-low { color: #7ee787 !important; }
        .price-mid { color: #d29922 !important; }
        .price-high { color: #f85149 !important; }
        .price-neutral { color: #8b949e !important; }
        .price-darkgreen { color: #238636 !important; }

        /* Feed-in highlight for very large export prices (bright green tile) */
        .stat-item.feedin-highlight {
            background: linear-gradient(180deg, #e6ffef, #bff6d4);
            border: 1px solid rgba(34,139,34,0.35);
            box-shadow: 0 8px 20px rgba(34,139,34,0.06);
            color: #053012;
        }
        .stat-item.feedin-highlight .value { color: #053012 !important; }

        /* Button Grid */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }
        .btn-grid .btn {
            margin-bottom: 0;
        }

        /* Right Panel */
        .right-panel {
            width: 480px;
            min-width: 380px;
            max-width: 600px;
            background: rgba(22, 27, 34, 0.95);
            border-left: 1px solid rgba(48, 54, 61, 0.6);
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease, min-width 0.3s ease;
            position: relative;
            flex-shrink: 0;
        }
        /* Left panel split: main content + automation panel */
        .left-panel {
            display: flex;
            gap: 16px;
            /* Stretch children so the automation panel can fill available height
               and its internal scrollbar becomes reachable when content is long. */
            align-items: stretch;
        }
        .main-content {
            flex: 1 1 auto;
            min-width: 320px;
        }
        .automation-panel {
            width: 520px;
            min-width: 280px;
            max-width: 900px;
            transition: width 0.12s ease;
            display: flex;
            flex-direction: column;
            gap: 12px;
            /* Fixed height panel that doesn't scroll itself; children scroll */
            position: -webkit-sticky;
            position: sticky;
            top: 80px;
            /* Increase the available vertical space by 20% so cards appear larger */
            height: calc((100vh - 100px) * 1.2);
            overflow: hidden; /* panel itself doesn't scroll */
            padding-bottom: 12px;
        }
        .automation-panel.collapsed {
            width: 0 !important;
            min-width: 0 !important;
            overflow: hidden;
            transform: translateX(100%);
        }
        /* Make the Active Automation card expand to fill available space and scroll internally */
        .automation-panel > .card:first-child {
            flex: 1 1 auto;
            min-height: 0; /* critical for flex child to shrink and enable scrolling */
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .automation-panel > .card:first-child > .card-body {
            flex: 1 1 auto;
            min-height: 0;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
            padding-right: 6px;
        }
        /* Keep the FAQ card at fixed small size */
        .automation-panel > .card.faq-card {
            flex: 0 0 auto;
        }

        /* FAQ card in automation panel - small default size and scrollable content */
        .automation-panel .faq-card {
            /* Make the FAQ card considerably taller so 'How It Works' can display
               more content without requiring the user to open the modal or scroll
               the entire page. Keep a reasonable maximum so the panel doesn't
               dominate the layout on very tall screens. */
            max-height: 520px; /* increased from 264px -> gives about twice the height */
            min-height: 200px; /* slightly taller minimum */
            overflow: hidden; /* prevent the FAQ card from expanding the automation panel */
        }
        .automation-panel .faq-card .card-body {
            /* Allow only the inner FAQ area to scroll ‚Äî height adjusted to match
               the larger FAQ card container so content inside has more room */
            max-height: calc(520px - 50px); /* account for header height */
            overflow-y: auto;
            padding-right: 6px;
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch;
        }
        /* Force Manual Scheduler into row 2 and span full width */
        .manual-scheduler-card {
            grid-column: 1 / -1 !important; /* take whole row */
            grid-row: 2; /* ensure it is placed on the second row */
        }
        .automation-toggle-btn {
            align-self: center;
            margin-left: -46px;
            margin-top: 190px;
            width: 56px;
            height: 100px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 1px solid rgba(255,255,255,0.15);
            border-left: none;
            border-radius: 16px 0 0 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            font-size: 16px;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 10001;
            box-shadow: 0 10px 40px rgba(102,126,234,0.25), inset 0 1px 0 rgba(255,255,255,0.2);
        }
        @media (max-height: 900px) {
            .automation-toggle-btn { margin-top: 150px; }
        }
        @media (max-height: 700px) {
            .automation-toggle-btn { margin-top: 100px; }
        }
        .automation-toggle-btn:hover { transform: translateY(-8px); box-shadow: 0 16px 52px rgba(102,126,234,0.35), inset 0 1px 0 rgba(255,255,255,0.2); }
        .automation-toggle-btn:active { transform: translateY(-2px); }

        /* Inline icon & arrow inside the toggle */
        .automation-toggle-btn .automation-toggle-icon { display:flex; align-items:center; justify-content:center; width:38px; height:38px; border-radius:12px; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .automation-toggle-btn .automation-toggle-icon svg { width:28px; height:28px; display:block; }
        .automation-toggle-btn .automation-toggle-arrow { font-size:20px; margin-left:6px; color: rgba(255,255,255,0.9); font-weight: 600; }
        .automation-toggle-btn:hover .automation-toggle-arrow { color: #fff; }
        .panel-resizer {
            width: 20px; /* larger hit area */
            cursor: col-resize;
            touch-action: none; /* allow pointer events to control dragging */
            background: transparent;
            transition: background 0.12s ease;
            align-self: stretch;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999; /* make sure it's on top */
            pointer-events: auto;
        }
        .panel-resizer:hover { background: rgba(88,166,255,0.06); }
        .panel-resizer::before {
            content: '';
            width: 2px;
            height: 48%;
            background: linear-gradient(180deg, rgba(255,255,255,0.15), rgba(255,255,255,0.06));
            border-radius: 3px;
            box-shadow: 0 0 0 1px rgba(255,255,255,0.01) inset;
            opacity: 0.9;
        }
        .right-panel.collapsed {
            width: 0;
            min-width: 0;
            border-left: none;
            overflow: hidden;
        }
        .right-panel.collapsed .result-container {
            display: none;
        }
        .toggle-panel {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 36px;
            height: 72px;
            background: rgba(33, 38, 45, 0.95);
            border: 1px solid rgba(48, 54, 61, 0.8);
            border-right: none;
            border-radius: 8px 0 0 8px;
            color: #8b949e;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: right 0.3s ease;
            z-index: 1000;
        }
        .toggle-panel:hover {
            background: rgba(48, 54, 61, 0.95);
            color: #e6edf3;
        }
        .result-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 18px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(48, 54, 61, 0.4);
        }
        .result-header h2 {
            font-size: 14px;
            font-weight: 600;
            color: #e6edf3;
        }
        .header-btns {
            display: flex;
            gap: 8px;
        }
        .header-btns button {
            padding: 6px 12px;
            border: 1px solid rgba(48, 54, 61, 0.8);
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .copy-btn {
            background: rgba(88, 166, 255, 0.1);
            color: #58a6ff;
        }
        .copy-btn:hover {
            background: rgba(88, 166, 255, 0.2);
        }
        .clear-btn {
            background: rgba(248, 81, 73, 0.1);
            color: #f85149;
        }
        .clear-btn:hover {
            background: rgba(248, 81, 73, 0.2);
        }
        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 8px 18px;
            background: rgba(0, 0, 0, 0.2);
            font-size: 11px;
            border-bottom: 1px solid rgba(48, 54, 61, 0.2);
        }
        .status-bar .endpoint { color: #58a6ff; }
        .status-bar .time { color: #8b949e; }
        .result-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px 18px;
        }
        #result {
            background: rgba(13, 17, 23, 0.8);
            border-radius: 8px;
            padding: 14px;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 12px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 100%;
            color: #8b949e;
        }
        .success { color: #7ee787; }
        .error { color: #f85149; }

        /* Resize Handle */
        .resize-handle {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            cursor: ew-resize;
            background: transparent;
        }
        .resize-handle:hover {
            background: rgba(88, 166, 255, 0.3);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(88, 166, 255, 0.3);
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(88, 166, 255, 0.5);
        }

        /* Settings Forms */
        .settings-form {
            background: rgba(13, 17, 23, 0.5);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 12px;
            border: 1px solid rgba(48, 54, 61, 0.4);
            transition: all 0.2s ease;
        }
        .settings-form:hover {
            border-color: rgba(48, 54, 61, 0.8);
        }
        .settings-form .form-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(48, 54, 61, 0.4);
        }
        .settings-form .form-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #e6edf3;
        }
        .settings-form .endpoint-tag {
            font-size: 10px;
            color: #8b949e;
            background: rgba(0, 0, 0, 0.3);
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'SF Mono', monospace;
        }
        .settings-form .form-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .settings-form .form-group {
            flex: 1;
        }
        .settings-form .form-group.sm {
            flex: 0 0 70px;
        }
        .settings-form .form-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid rgba(48, 54, 61, 0.3);
        }
        .settings-form .checkbox-row {
            display: flex;
            gap: 12px;
            margin-bottom: 10px;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            color: #8b949e;
            transition: all 0.2s;
        }
        .checkbox-label:hover {
            background: rgba(0, 0, 0, 0.3);
            color: #e6edf3;
        }
        .checkbox-label input {
            accent-color: #58a6ff;
        }
        .time-input {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .time-input input {
            width: 50px;
            text-align: center;
        }
        .time-input .sep {
            color: #484f58;
            font-weight: bold;
        }

        /* Section Titles */
        .section-title {
            font-size: 12px;
            font-weight: 600;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(48, 54, 61, 0.4);
        }

        /* Automation Rules Styles */
        .automation-section {
            margin-top: 20px;
        }
        .automation-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }
        .automation-header h2 {
            font-size: 18px;
            font-weight: 600;
            color: #e6edf3;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .automation-header h2 .icon {
            font-size: 22px;
        }
        .automation-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .automation-toggle {
            position: relative;
            width: 52px;
            height: 28px;
            background: rgba(48, 54, 61, 0.8);
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(48, 54, 61, 0.8);
        }
        .automation-toggle.active {
            background: linear-gradient(135deg, #238636, #1a7f37);
            border-color: #238636;
        }
        .automation-toggle::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: #e6edf3;
            border-radius: 50%;
            top: 2px;
            left: 3px;
            transition: all 0.3s ease;
        }
        .automation-toggle.active::after {
            left: 26px;
        }
        .automation-status-text {
            font-size: 12px;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .automation-status-text.active {
            color: #7ee787;
        }
        .rules-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 16px;
        }
        .rule-card {
            background: linear-gradient(145deg, rgba(33, 38, 45, 0.9), rgba(22, 27, 34, 0.95));
            border-radius: 12px;
            border: 1px solid rgba(48, 54, 61, 0.6);
            overflow: hidden;
            transition: all 0.2s ease;
        }
        .rule-card:hover {
            border-color: rgba(88, 166, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        .rule-card.disabled {
            opacity: 0.6;
        }
        .rule-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(48, 54, 61, 0.4);
        }
        .rule-card-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #e6edf3;
        }
        .rule-card-actions {
            display: flex;
            gap: 6px;
        }
        .rule-card-actions button {
            padding: 4px 8px;
            background: rgba(33, 38, 45, 0.8);
            border: 1px solid rgba(48, 54, 61, 0.8);
            border-radius: 4px;
            color: #8b949e;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        .rule-card-actions button:hover {
            background: rgba(48, 54, 61, 0.8);
            color: #e6edf3;
        }
        .rule-card-actions button.delete:hover {
            background: rgba(248, 81, 73, 0.2);
            border-color: rgba(248, 81, 73, 0.4);
            color: #f85149;
        }
        .rule-card-body {
            padding: 14px 16px;
        }
        .rule-conditions, .rule-actions-box {
            margin-bottom: 12px;
        }
        .rule-section-label {
            font-size: 10px;
            font-weight: 600;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .condition-tag, .action-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            margin: 3px;
        }
        .condition-tag {
            background: rgba(88, 166, 255, 0.1);
            border: 1px solid rgba(88, 166, 255, 0.2);
            color: #58a6ff;
        }
        .condition-tag.price { border-color: rgba(126, 231, 135, 0.3); color: #7ee787; }
        .condition-tag.soc { border-color: rgba(163, 113, 247, 0.3); color: #a371f7; }
        .condition-tag.temp { border-color: rgba(210, 153, 34, 0.3); color: #d29922; }
        .condition-tag.weather { border-color: rgba(88, 166, 255, 0.3); color: #58a6ff; }
        .action-tag {
            background: rgba(35, 134, 54, 0.15);
            border: 1px solid rgba(35, 134, 54, 0.3);
            color: #7ee787;
        }
        .action-tag.charge { background: rgba(88, 166, 255, 0.15); border-color: rgba(88, 166, 255, 0.3); color: #58a6ff; }
        .action-tag.discharge { background: rgba(240, 136, 62, 0.15); border-color: rgba(240, 136, 62, 0.3); color: #f0883e; }
        .action-tag.feedin { background: rgba(210, 153, 34, 0.15); border-color: rgba(210, 153, 34, 0.3); color: #d29922; }
        
        /* Rule Builder Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal-overlay.show {
            display: flex;
        }
        .modal-content {
            background: linear-gradient(145deg, #21262d, #161b22);
            border: 1px solid rgba(48, 54, 61, 0.8);
            border-radius: 16px;
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 18px 24px;
            border-bottom: 1px solid rgba(48, 54, 61, 0.6);
            background: rgba(0, 0, 0, 0.2);
        }
        .modal-header h3 {
            font-size: 16px;
            font-weight: 600;
            color: #e6edf3;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .modal-close {
            width: 32px;
            height: 32px;
            border: none;
            background: rgba(48, 54, 61, 0.6);
            border-radius: 6px;
            color: #8b949e;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .modal-close:hover {
            background: rgba(248, 81, 73, 0.2);
            color: #f85149;
        }
        .modal-body {
            padding: 24px;
        }
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 16px 24px;
            border-top: 1px solid rgba(48, 54, 61, 0.6);
            background: rgba(0, 0, 0, 0.1);
        }
        .form-section {
            margin-bottom: 24px;
        }
        .form-section-title {
            font-size: 13px;
            font-weight: 600;
            color: #e6edf3;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .form-section-title .icon {
            font-size: 16px;
        }
        .condition-builder {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        @media (max-width: 600px) {
            .condition-builder {
                grid-template-columns: 1fr;
            }
        }
        .condition-item {
            background: rgba(13, 17, 23, 0.5);
            border: 1px solid rgba(48, 54, 61, 0.6);
            border-radius: 10px;
            padding: 14px;
            transition: all 0.2s ease;
        }
        .condition-item:hover {
            border-color: rgba(88, 166, 255, 0.3);
        }
        .condition-item.active {
            border-color: rgba(88, 166, 255, 0.5);
            background: rgba(88, 166, 255, 0.05);
        }
        .condition-item-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .condition-item-header input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #58a6ff;
        }
        .condition-item-header label {
            font-size: 13px;
            font-weight: 600;
            color: #e6edf3;
            cursor: pointer;
        }
        .condition-item-header .icon {
            font-size: 16px;
        }
        .condition-fields {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding-left: 28px;
        }
        .condition-field {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .condition-field label {
            font-size: 11px;
            color: #8b949e;
            min-width: 60px;
        }
        .condition-field select,
        .condition-field input {
            flex: 1;
            padding: 6px 10px;
            background: rgba(13, 17, 23, 0.8);
            border: 1px solid rgba(48, 54, 61, 0.8);
            border-radius: 6px;
            color: #e6edf3;
            font-size: 12px;
        }
        .condition-field select:focus,
        .condition-field input:focus {
            outline: none;
            border-color: #58a6ff;
        }
        .action-builder {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .action-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(13, 17, 23, 0.5);
            border: 1px solid rgba(48, 54, 61, 0.6);
            border-radius: 8px;
        }
        .action-item label {
            font-size: 13px;
            color: #8b949e;
            min-width: 100px;
        }
        .action-item select,
        .action-item input {
            flex: 1;
            padding: 8px 12px;
            background: rgba(13, 17, 23, 0.8);
            border: 1px solid rgba(48, 54, 61, 0.8);
            border-radius: 6px;
            color: #e6edf3;
            font-size: 13px;
        }
        .add-rule-card {
            background: rgba(33, 38, 45, 0.5);
            border: 2px dashed rgba(48, 54, 61, 0.8);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 180px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .add-rule-card:hover {
            border-color: rgba(88, 166, 255, 0.4);
            background: rgba(88, 166, 255, 0.05);
        }
        .add-rule-card .icon {
            font-size: 36px;
            color: #58a6ff;
            margin-bottom: 10px;
        }
        .add-rule-card span {
            font-size: 14px;
            color: #8b949e;
        }
        .empty-rules {
            grid-column: 1 / -1;
            text-align: center;
            padding: 40px 20px;
            color: #8b949e;
        }
        .empty-rules .icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        .empty-rules p {
            font-size: 14px;
            margin-bottom: 8px;
        }
        .empty-rules .hint {
            font-size: 12px;
            color: #6e7681;
        }
        
        /* Spinner for loading states */
        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* FAQ Section */
        .faq-section { margin-top: 16px; }
        .faq-item {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            margin-bottom: 6px;
            overflow: hidden;
        }
        .faq-question {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            cursor: pointer;
            font-weight: 500;
            font-size: 12px;
            color: #e6edf3;
            transition: background 0.2s;
        }
        .faq-question:hover { background: #21262d; }
        .faq-question .icon {
            transition: transform 0.2s;
            font-size: 10px;
            color: #8b949e;
        }
        .faq-item.open .faq-question .icon { transform: rotate(180deg); }
        .faq-answer {
            display: none;
            padding: 0 12px 12px;
            font-size: 11px;
            line-height: 1.5;
            color: #8b949e;
        }
        .faq-item.open .faq-answer { display: block; }
        .faq-answer code {
            background: #0d1117;
            padding: 1px 4px;
            border-radius: 3px;
            font-family: 'Consolas', monospace;
            color: #58a6ff;
            font-size: 10px;
        }
        .faq-answer ul { margin: 6px 0; padding-left: 16px; }
        .faq-answer li { margin-bottom: 4px; }
        .faq-highlight {
            background: rgba(126, 231, 135, 0.1);
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            border-left: 2px solid #7ee787;
            font-size: 10px;
        }
    </style>
    <style>
        /* Small inline weather map */
        .weather-map {
            width: 100%;
            min-height: 120px;
            height: 120px !important;
            border-radius: 6px;
            margin-top: 12px;
            overflow: hidden;
            background: #1a1f26 !important;
            border: 1px solid rgba(48, 54, 61, 0.5) !important;
            position: relative;
        }
        /* Simple modal for Amber history date selection */
        .modal-backdrop { position: fixed; inset: 0; background: rgba(3,6,9,0.6); display:none; align-items:center; justify-content:center; z-index:1200 }
        .modal-backdrop.show { display:flex }
        .modal { background: #0d1117; border:1px solid rgba(48,54,61,0.6); padding:16px; border-radius:8px; width:360px; max-width:92%; box-shadow:0 10px 30px rgba(2,6,23,0.6) }
        .modal h3 { margin:0 0 8px 0; font-size:16px }
        .modal .row { display:flex; gap:8px; align-items:center; margin-bottom:8px }
        .modal .row input[type=date] { flex:1; padding:8px; background:transparent; border:1px solid rgba(255,255,255,0.04); color:#e6edf3 }
        .modal .actions { display:flex; gap:8px; justify-content:flex-end; margin-top:8px }
        .leaflet-container {
            min-height: 120px !important;
            background: #1a1f26 !important;
        }
        /* Force tile images visible if leaflet.css is missing or some rules hide them */
        .leaflet-tile, .leaflet-tile-loaded { opacity: 1 !important; visibility: visible !important; filter: none !important; }
        /* Ensure tiles are stacked above any card overlays */
        .weather-map .leaflet-map-pane, .weather-map .leaflet-tile-pane { z-index: 1 !important; position: relative !important; }
        .weather-map .leaflet-overlay-pane, .weather-map .leaflet-shadow-pane { z-index: 2 !important; }
        /* Make Leaflet tiles blend with dark UI when tiles fail to load quickly */
        .leaflet-container { background: #0d1117; }
    </style>
</head>
<body>
    <nav class="nav-main">
        <div class="nav-links">
            <a href="/" class="nav-link">üè† Overview</a>
            <a href="/test.html" class="nav-link">üß™ Automation Lab</a>
            <a href="/control.html" class="nav-link">üß≠ Controls</a>
            <a href="/history.html" class="nav-link">üìä History</a>
            <a href="/settings.html" class="nav-link">‚öôÔ∏è Settings</a>
        </div>
        <div class="nav-right">
            <div class="device-input">
                <label>Device SN</label>
                <input type="text" id="deviceSn" placeholder="Auto-detect from .env">
            </div>
            <div class="user-menu" data-user-menu>
                <button class="user-avatar" type="button" data-user-avatar>
                    <span data-user-initials>?</span>
                </button>
                <div class="user-dropdown" data-user-dropdown>
                    <div class="user-dropdown-header">
                        <div class="user-name" data-user-name>Guest</div>
                        <div class="user-email" data-user-email>Not signed in</div>
                    </div>
                    <button class="user-dropdown-item" type="button" data-go-settings>‚öôÔ∏è Settings</button>
                    <button class="user-dropdown-item danger" type="button" data-signout>üö™ Sign Out</button>
                </div>
            </div>
        </div>
    </nav>
    
    <header class="header" style="margin-top:50px">
        <h1><span class="logo">‚ö°</span> FoxESS Solar Dashboard</h1>
    </header>
    
    <div class="main-layout">
        <div class="left-panel panel-open">
            <div class="main-content">
            
            <!-- Priority Row: Inverter, Prices, Weather -->
            <div class="priority-row">
                
                <!-- Inverter Status -->
                <div class="card priority">
                    <div class="card-header">
                        <div class="card-title"><span class="icon">‚ö°</span> Inverter Status</div>
                            <div style="display:flex;align-items:center;gap:8px;flex-direction:column;align-items:flex-end">
                            <div style="display:flex;gap:8px;align-items:center">
                                <span class="card-badge">Live</span>
                                <div id="inverterLastUpdate" style="font-size:11px;color:#8b949e;">‚Äî</div>
                                <button class="btn btn-icon" onclick="callAPI('/api/inverter/real-time', 'Real-time Data')" title="Refresh inverter data">üîÑ</button>
                            </div>

                                <!-- API call metrics footer -->
                                <div id="apiMetricsFooter" class="api-metrics-footer">
                                    <div class="metrics-icon">üìä API Calls</div>
                                    <div id="metricsDate" class="metrics-date">‚Äî</div>
                                    <div id="metricsCounts" class="metrics-counts">
                                        <div class="metric-fox">FoxESS: <span id="countFox" class="metric-value">0</span></div>
                                        <div class="metric-amber">Amber: <span id="countAmber" class="metric-value">0</span></div>
                                        <div class="metric-weather">Weather: <span id="countWeather" class="metric-value">0</span></div>
                                    </div>
                                    <button class="btn btn-sm" onclick="loadApiMetrics(1)" title="Refresh metrics">üîÑ</button>
                                </div>
                            <div style="font-size:11px;color:#8b949e;margin-top:4px;text-align:right">
                                <span id="inverterCloudTime">‚Äî</span>
                                <span style="color:#6e7681;margin-left:8px;font-size:10px" id="inverterFetchLabel">(fetched ‚Ä¢ <span id="inverterFetchAgo">‚Äî</span>)</span>
                            </div>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="data-card info" id="inverterCard">
                            <div style="color:#8b949e;font-size:12px">Loading inverter data...</div>
                        </div>
                    </div>
                </div>

                <!-- Amber Prices -->
                <div class="card priority">
                    <div class="card-header">
                        <div class="card-title"><span class="icon">üí∞</span> Electricity Prices</div>
                        <div style="display:flex;align-items:center;gap:8px">
                            <span class="card-badge">Amber</span>
                            <div id="amberLastUpdate" style="font-size:11px;color:#8b949e;">‚Äî</div>
                            <button class="btn btn-icon" onclick="getAmberCurrent()" title="Refresh prices">üîÑ</button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="input-row">
                            <select id="amberSiteId" class="input">
                                <option value="">Loading sites...</option>
                            </select>
                            <button class="btn btn-sm" id="amberShowMore" onclick="toggleAmberMore()" style="width:auto;margin:0;padding:6px 12px;font-size:12px">Show all</button>
                        </div>
                        <!-- Hidden input for compatibility with existing code -->
                        <input type="hidden" id="amberNext" value="288">
                        <div class="data-card" id="amberCard">
                            <div style="color:#8b949e;font-size:12px">Loading Amber sites...</div>
                        </div>
                    </div>
                </div>

                <!-- Weather -->
                <div class="card priority">
                    <div class="card-header">
                        <div class="card-title"><span class="icon">üå§Ô∏è</span> Weather Forecast</div>
                        <div style="display:flex;align-items:center;gap:8px">
                            <span class="card-badge">Open-Meteo</span>
                            <div id="weatherLastUpdate" style="font-size:11px;color:#8b949e;">‚Äî</div>
                            <button class="btn btn-icon" onclick="getWeather()" title="Refresh weather">üîÑ</button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="input-row" style="align-items:center">
                            <input type="text" id="weatherPlace" class="input" placeholder="Location" value="Roselands 2196 NSW" style="flex:1;min-width:220px;max-width:520px">
                            <input type="number" id="weatherDays" class="input" min="1" max="16" value="6" style="width:70px" title="Days">
                            <div id="weatherRequestedLabel" style="min-width:110px;color:#8b949e;font-size:12px;display:flex;align-items:center;justify-content:center;margin-left:8px">Requested: 6</div>
                        </div>
                        <button id="getWeatherBtn" class="btn btn-primary btn-sm" onclick="getWeather()" style="width:auto;align-self:flex-start;padding:8px 16px">Get Forecast</button>
                        <div class="data-card" id="weatherCard">
                            <div style="color:#8b949e;font-size:12px">Enter a location and click Get Forecast</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Manual Scheduler (Time Segments) - moved up for prominence -->
            <div class="card" style="margin-bottom: 20px;">
                <div class="card-header">
                    <div class="card-title"><span class="icon">üìÖ</span> Manual Scheduler (Time Segments)</div>
                    <div style="display:flex;gap:8px;">
                        <button class="btn" onclick="clearAllSchedulerSegments()" style="font-size:11px;padding:4px 10px;width:auto;margin:0;background:#da3633;border-color:#f85149;">üóëÔ∏è Clear All</button>
                        <button class="btn" onclick="loadSchedulerSegments()" style="font-size:11px;padding:4px 10px;width:auto;margin:0">üîÑ Load Current</button>
                    </div>
                </div>
                <div class="card-body">
                    <div id="schedulerStatus" style="padding:8px;margin-bottom:10px;border-radius:6px;font-size:12px;display:none;"></div>
                    <div id="schedulerSegments" style="display:grid;grid-template-columns:repeat(auto-fit, minmax(300px, 1fr));gap:10px;">
                        <!-- Segments will be loaded here -->
                        <div style="color:#8b949e;font-size:12px;padding:20px;text-align:center">
                            Click "Load Current" to fetch your scheduler segments, or add a new segment below.
                        </div>
                    </div>
                    
                    <!-- Add New Segment -->
                    <div style="margin-top:16px;padding-top:16px;border-top:1px solid #30363d;">
                        <div style="font-weight:600;color:#58a6ff;margin-bottom:10px">‚ûï Add/Edit Segment</div>
                        <form id="form-scheduler-segment" onsubmit="submitSchedulerSegment(event)" style="display:grid;grid-template-columns:repeat(auto-fit, minmax(140px, 1fr));gap:10px;align-items:end;">
                            <div class="input-group">
                                <label style="font-size:11px">Segment #</label>
                                <select name="segmentIndex" class="input" style="padding:6px">
                                    <option value="0">1</option>
                                    <option value="1">2</option>
                                    <option value="2">3</option>
                                    <option value="3">4</option>
                                    <option value="4">5</option>
                                    <option value="5">6</option>
                                    <option value="6">7</option>
                                    <option value="7">8</option>
                                </select>
                            </div>
                            <div class="input-group">
                                <label style="font-size:11px">Enable</label>
                                <select name="enable" class="input" style="padding:6px">
                                    <option value="1">Yes</option>
                                    <option value="0">No</option>
                                </select>
                            </div>
                            <div class="input-group">
                                <label style="font-size:11px">Work Mode</label>
                                <select name="workMode" class="input" style="padding:6px">
                                    <option value="SelfUse">Self Use</option>
                                    <option value="ForceCharge">Force Charge</option>
                                    <option value="ForceDischarge">Force Discharge</option>
                                    <option value="Feedin">Feed In</option>
                                    <option value="Backup">Backup</option>
                                </select>
                            </div>
                            <div class="input-group">
                                <label style="font-size:11px">Start Time</label>
                                <input type="time" name="startTime" class="input" value="00:00" style="padding:5px">
                            </div>
                            <div class="input-group">
                                <label style="font-size:11px">End Time</label>
                                <input type="time" name="endTime" class="input" value="00:00" style="padding:5px">
                            </div>
                            <div class="input-group">
                                <label style="font-size:11px">Min SoC Grid %</label>
                                <input type="number" name="minSocOnGrid" class="input" min="10" max="100" value="20" style="padding:6px">
                            </div>
                            <div class="input-group">
                                <label style="font-size:11px">FD SoC %</label>
                                <input type="number" name="fdSoc" class="input" min="10" max="100" value="35" style="padding:6px">
                            </div>
                            <div class="input-group">
                                <label style="font-size:11px">FD Power (W)</label>
                                <input type="number" name="fdPwr" class="input" min="0" max="10500" value="5000" style="padding:6px">
                            </div>
                            <div class="input-group">
                                <label style="font-size:11px">Max SoC %</label>
                                <input type="number" name="maxSoc" class="input" min="10" max="100" value="90" style="padding:6px">
                            </div>
                            <div style="display:flex;gap:6px">
                                <button class="btn btn-primary" type="submit" style="flex:1">üíæ Save Segment</button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>

        </div>

            </div> <!-- /.main-content -->

            <div id="automationResizer" class="panel-resizer" title="Drag to resize rules panel"></div>
            <button class="automation-toggle-btn" id="automationToggleBtn" onclick="toggleAutomationPanel()" title="Collapse automation panel" aria-label="Toggle automation panel"><span class="automation-toggle-icon"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"><defs><linearGradient id="robotBody" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:#667eea;stop-opacity:1" /><stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" /></linearGradient></defs><rect x="5" y="8" width="14" height="10" rx="3" fill="url(#robotBody)" stroke="#5567d8" stroke-width="0.5"/><rect x="7" y="4" width="10" height="4" rx="2" fill="#667eea" stroke="#5567d8" stroke-width="0.5"/><circle cx="9.5" cy="11" r="1.3" fill="#fff"/><circle cx="14.5" cy="11" r="1.3" fill="#fff"/><circle cx="9.5" cy="11" r="0.7" fill="#667eea"/><circle cx="14.5" cy="11" r="0.7" fill="#667eea"/><rect x="10" y="15" width="4" height="1.5" rx="0.7" fill="#764ba2"/><circle cx="6" y="4" r="0.8" fill="#ffd700"/></svg></span><span class="automation-toggle-arrow">‚óÄ</span></button>

            <div class="automation-panel collapsed">
                <!-- Backend Automation Status -->
                <div class="card" style="margin-bottom:16px">
                    <div class="card-header">
                        <div class="card-title"><span class="icon">‚ö°</span> Active Automation</div>
                        <button class="btn btn-sm" onclick="loadBackendAutomationStatus()" style="padding:4px 10px;width:auto;margin:0">üîÑ</button>
                    </div>
                    <div class="card-body" id="backendAutomationStatus">
                        <div style="color:#8b949e;font-size:12px">Loading automation status...</div>
                    </div>
                </div>

                <!-- FAQ Section -->
                <div class="card faq-card" style="margin-bottom:16px">
                    <div class="card-header">
                        <div class="card-title"><span class="icon">‚ùì</span> How It Works</div>
                    </div>
                    <div class="card-body">
                        <div class="faq-section">
                            <div class="faq-item">
                                <div class="faq-question" onclick="this.parentElement.classList.toggle('open')">
                                    <span>How often are conditions checked?</span>
                                    <span class="icon">‚ñº</span>
                                </div>
                                <div class="faq-answer">
                                    Every <code id="faqAutomationInterval">60 seconds</code> using <strong>cached data</strong>:
                                    <ul>
                                        <li>Amber prices: refreshed every <span id="faqAmberCache">30s</span></li>
                                        <li>Inverter (SoC, temps): every <span id="faqInverterCache">5 min</span></li>
                                        <li>Weather: every <span id="faqWeatherCache">30 min</span></li>
                                    </ul>
                                </div>
                            </div>
                            <div class="faq-item">
                                <div class="faq-question" onclick="this.parentElement.classList.toggle('open')">
                                    <span>What is cooldown?</span>
                                    <span class="icon">‚ñº</span>
                                </div>
                                <div class="faq-answer">
                                    After a rule triggers, it can't trigger again for <code id="faqCooldown">5 minutes</code> (default). Prevents rapid switching when values hover near thresholds.
                                </div>
                            </div>
                            <div class="faq-item">
                                <div class="faq-question" onclick="this.parentElement.classList.toggle('open')">
                                    <span>What if conditions change mid-segment?</span>
                                    <span class="icon">‚ñº</span>
                                </div>
                                <div class="faq-answer">
                                    <div class="faq-highlight">
                                        <strong>Active Cancellation:</strong> If the triggering rule's conditions are no longer met, the segment is cancelled within ~<span id="faqCancelInterval">60 seconds</span>. Higher-priority rules can also replace active lower-priority rules immediately.
                                    </div>
                                </div>
                            </div>
                            <div class="faq-item">
                                <div class="faq-question" onclick="this.parentElement.classList.toggle('open')">
                                    <span>How does priority work?</span>
                                    <span class="icon">‚ñº</span>
                                </div>
                                <div class="faq-answer">
                                    <strong>Lower number = Higher priority.</strong> Rules evaluated in order; first match wins. Use priority 1-2 for safety rules.
                                </div>
                            </div>
                        </div>
                        <div style="text-align:center;margin-top:10px">
                            <a href="/test.html" style="color:#58a6ff;font-size:11px;text-decoration:none">üß™ Full FAQ in Automation Lab ‚Üí</a>
                        </div>
                    </div>
                </div>
            </div> <!-- /.automation-panel -->

            <!-- Right Panel - Response -->
            <div class="right-panel collapsed" id="rightPanel">
                <div class="resize-handle" id="resizeHandle"></div>
                
                <div class="result-container">
                    <div class="result-header">
                        <h2>üìã API Response</h2>
                        <div class="header-btns">
                            <button class="copy-btn" onclick="copyResult()">üìã Copy</button>
                            <button class="clear-btn" onclick="clearResult()">Clear</button>
                        </div>
                    </div>
                    <div id="status-bar" class="status-bar" style="display: none;">
                        <span class="endpoint"></span>
                        <span class="time"></span>
                    </div>
                    <div class="result-content">
                        <pre id="result">Click any button to see the API response here...</pre>
                    </div>
                </div>
            </div>

        </div> <!-- /.main-layout -->

        <!-- Toggle button outside main-layout, fixed position, always visible -->
        <button class="toggle-panel" onclick="togglePanel()" id="toggleBtn">R ‚óÄ</button>

        <!-- Rule Builder Modal -->
        <div class="modal-overlay" id="ruleModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3><span class="icon">‚öôÔ∏è</span> <span id="ruleModalTitle">Create Automation Rule</span></h3>
                    <button class="modal-close" onclick="closeRuleModal()">√ó</button>
                </div>
                <div class="modal-body">
                    <form id="ruleForm">
                        <!-- Rule Name -->
                        <div class="form-section">
                            <div class="form-section-title"><span class="icon">üìù</span> Rule Name</div>
                            <input type="text" id="ruleName" class="input" placeholder="e.g., Cheap Rate Charging" required>
                        </div>
                        
                        <!-- Conditions -->
                        <div class="form-section">
                            <div class="form-section-title"><span class="icon">üéØ</span> Conditions (when to trigger)</div>
                            <div class="condition-builder">
                                <!-- Amber Price Condition -->
                                <div class="condition-item" id="conditionPrice">
                                    <div class="condition-item-header">
                                        <input type="checkbox" id="condPriceEnabled" onchange="toggleCondition('Price')">
                                        <span class="icon">üí∞</span>
                                        <label for="condPriceEnabled">Amber Price</label>
                                    </div>
                                    <div class="condition-fields" id="condPriceFields">
                                        <div class="condition-field">
                                            <label>Type</label>
                                            <select id="condPriceType">
                                                <option value="buy">Buy Price</option>
                                                <option value="feedin">Feed-in Price</option>
                                            </select>
                                        </div>
                                        <div class="condition-field">
                                            <label>Operator</label>
                                            <select id="condPriceOp">
                                                <option value="<">Less than</option>
                                                <option value="<=">Less or equal</option>
                                                <option value=">">Greater than</option>
                                                <option value=">=">Greater or equal</option>
                                                <option value="between">Between</option>
                                            </select>
                                        </div>
                                        <div class="condition-field">
                                            <label>Value (¬¢)</label>
                                            <input type="number" id="condPriceValue" placeholder="15" step="0.1">
                                        </div>
                                        <div class="condition-field" id="condPriceValue2Row" style="display:none">
                                            <label>And (¬¢)</label>
                                            <input type="number" id="condPriceValue2" placeholder="25" step="0.1">
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Battery SoC Condition -->
                                <div class="condition-item" id="conditionSoC">
                                    <div class="condition-item-header">
                                        <input type="checkbox" id="condSoCEnabled" onchange="toggleCondition('SoC')">
                                        <span class="icon">üîã</span>
                                        <label for="condSoCEnabled">Battery SoC</label>
                                    </div>
                                    <div class="condition-fields" id="condSoCFields">
                                        <div class="condition-field">
                                            <label>Operator</label>
                                            <select id="condSoCOp">
                                                <option value="<">Less than</option>
                                                <option value="<=">Less or equal</option>
                                                <option value=">">Greater than</option>
                                                <option value=">=">Greater or equal</option>
                                                <option value="between">Between</option>
                                            </select>
                                        </div>
                                        <div class="condition-field">
                                            <label>Value (%)</label>
                                            <input type="number" id="condSoCValue" min="0" max="100" placeholder="20">
                                        </div>
                                        <div class="condition-field" id="condSoCValue2Row" style="display:none">
                                            <label>And (%)</label>
                                            <input type="number" id="condSoCValue2" min="0" max="100" placeholder="80">
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Battery Temperature Condition -->
                                <div class="condition-item" id="conditionTemp">
                                    <div class="condition-item-header">
                                        <input type="checkbox" id="condTempEnabled" onchange="toggleCondition('Temp')">
                                        <span class="icon">üå°Ô∏è</span>
                                        <label for="condTempEnabled">Battery Temperature</label>
                                    </div>
                                    <div class="condition-fields" id="condTempFields">
                                        <div class="condition-field">
                                            <label>Operator</label>
                                            <select id="condTempOp">
                                                <option value="<">Less than</option>
                                                <option value="<=">Less or equal</option>
                                                <option value=">">Greater than</option>
                                                <option value=">=">Greater or equal</option>
                                                <option value="between">Between</option>
                                            </select>
                                        </div>
                                        <div class="condition-field">
                                            <label>Value (¬∞C)</label>
                                            <input type="number" id="condTempValue" placeholder="35">
                                        </div>
                                        <div class="condition-field" id="condTempValue2Row" style="display:none">
                                            <label>And (¬∞C)</label>
                                            <input type="number" id="condTempValue2" placeholder="45">
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Weather Condition -->
                                <div class="condition-item" id="conditionWeather">
                                    <div class="condition-item-header">
                                        <input type="checkbox" id="condWeatherEnabled" onchange="toggleCondition('Weather')">
                                        <span class="icon">üå§Ô∏è</span>
                                        <label for="condWeatherEnabled">Weather Forecast</label>
                                    </div>
                                    <div class="condition-fields" id="condWeatherFields">
                                        <div class="condition-field">
                                            <label>Condition</label>
                                            <select id="condWeatherType">
                                                <option value="sunny">Sunny / Clear</option>
                                                <option value="cloudy">Cloudy / Overcast</option>
                                                <option value="rainy">Rainy</option>
                                                <option value="any">Any</option>
                                            </select>
                                        </div>
                                        <div class="condition-field">
                                            <label>Solar (kWh)</label>
                                            <select id="condWeatherSolarOp">
                                                <option value="any">Any</option>
                                                <option value=">">Expected &gt;</option>
                                                <option value="<">Expected &lt;</option>
                                            </select>
                                        </div>
                                        <div class="condition-field" id="condWeatherSolarValueRow">
                                            <label>Value</label>
                                            <input type="number" id="condWeatherSolarValue" placeholder="20" step="0.1">
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Time Window Condition -->
                                <div class="condition-item" id="conditionTime">
                                    <div class="condition-item-header">
                                        <input type="checkbox" id="condTimeEnabled" onchange="toggleCondition('Time')">
                                        <span class="icon">üïê</span>
                                        <label for="condTimeEnabled">Time Window</label>
                                    </div>
                                    <div class="condition-fields" id="condTimeFields">
                                        <div class="condition-field">
                                            <label>From</label>
                                            <input type="time" id="condTimeStart" value="00:00">
                                        </div>
                                        <div class="condition-field">
                                            <label>To</label>
                                            <input type="time" id="condTimeEnd" value="23:59">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Actions -->
                        <div class="form-section">
                            <div class="form-section-title"><span class="icon">‚ö°</span> Action (what to do)</div>
                            <div class="action-builder">
                                <div class="action-item">
                                    <label>Work Mode</label>
                                    <select id="actionWorkMode">
                                        <option value="">-- Select --</option>
                                        <option value="SelfUse">Self Use</option>
                                        <option value="ForceCharge">Force Charge</option>
                                        <option value="ForceDischarge">Force Discharge</option>
                                        <option value="Feedin">Feed In</option>
                                        <option value="Backup">Backup</option>
                                    </select>
                                </div>
                                <div class="action-item">
                                    <label>Min SoC (%)</label>
                                    <input type="number" id="actionMinSoC" min="10" max="100" placeholder="Optional">
                                </div>
                                <div class="action-item">
                                    <label>Max SoC (%)</label>
                                    <input type="number" id="actionMaxSoC" min="10" max="100" placeholder="Optional">
                                </div>
                                <div class="action-item">
                                    <label>Discharge Power (W)</label>
                                    <input type="number" id="actionFdPwr" min="0" max="10500" placeholder="Optional">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Priority -->
                        <div class="form-section">
                            <div class="form-section-title"><span class="icon">üìä</span> Priority</div>
                            <div class="action-item">
                                <label>Rule Priority</label>
                                <select id="rulePriority">
                                    <option value="1">1 - Highest</option>
                                    <option value="2">2 - High</option>
                                    <option value="3" selected>3 - Normal</option>
                                    <option value="4">4 - Low</option>
                                    <option value="5">5 - Lowest</option>
                                </select>
                            </div>
                        </div>
                        
                        <input type="hidden" id="ruleId" value="">
                    </form>
                </div>
                <div class="modal-footer">
                    <button class="btn" onclick="closeRuleModal()">Cancel</button>
                    <button class="btn btn-primary" onclick="saveRule()">üíæ Save Rule</button>
                </div>
            </div>
        </div>

    <script>
        // default collapsed state for right response panel; value persisted in localStorage
        let panelCollapsed = false;
        // When true, suppress auto-opening the right response panel (used during init)
        window.suppressPanelAutoOpen = false;

        // apiClient is declared in api-client.js and initialized after Firebase auth is ready

        /**
         * Helper function to make authenticated API calls.
         * Uses apiClient.fetch to include the Authorization header and normalize responses.
         */
        async function authenticatedFetch(url, options = {}) {
            if (window.AppShell && typeof AppShell.authFetch === 'function') {
                return AppShell.authFetch(url, options);
            }
            try {
                if (typeof waitForAPIClient === 'function') {
                    await waitForAPIClient(3000);
                } else {
                    const start = Date.now();
                    while (!apiClient && (Date.now() - start) < 3000) {
                        await new Promise(r => setTimeout(r, 50));
                    }
                }
            } catch (e) {
                console.warn('[API] apiClient not initialized yet');
                throw new Error('API client not ready');
            }
            return apiClient.fetch(url, options);
        }
        // Dismiss the weather fallback banner for a given location key
        function dismissWeatherFallback(key) {
            try {
                localStorage.setItem('weatherFallbackDismissed:' + key, String(Date.now()));
            } catch (e) { /* ignore storage errors */ }
            const el = document.getElementById('weather-fallback-banner-' + key);
            if (el && el.remove) el.remove();
            // Also clear status bar border if it was indicating fallback
            try {
                const statusBar = document.getElementById('status-bar');
                if (statusBar) statusBar.style.border = '';
            } catch (e) {}

            // Ensure the toggle button remains clickable; keep pointer events enabled
            try {
                const tbtn = document.getElementById('automationToggleBtn');
                if (tbtn) tbtn.style.pointerEvents = 'auto';
            } catch (e) { /* ignore */ }
        }
        // Dynamically load Leaflet CSS+JS once and return a Promise when ready
        function ensureLeafletLoaded() {
            if (window.__leafletLoading) return window.__leafletLoading;
            if (window.L) return Promise.resolve();

            window.__leafletLoading = new Promise((resolve, reject) => {
                try {
                    // CSS
                    const cssHref = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                    const existing = Array.from(document.getElementsByTagName('link')).find(l => l.href && l.href.indexOf('unpkg.com/leaflet') !== -1);
                    if (!existing) {
                        const link = document.createElement('link');
                        link.rel = 'stylesheet';
                        link.href = cssHref;
                        document.head.appendChild(link);
                    }

                    // JS
                    const existingScript = Array.from(document.getElementsByTagName('script')).find(s => s.src && s.src.indexOf('unpkg.com/leaflet') !== -1);
                    if (existingScript) {
                        existingScript.addEventListener('load', () => resolve());
                        existingScript.addEventListener('error', () => reject(new Error('Leaflet script failed to load')));
                        return;
                    }
                    const script = document.createElement('script');
                    script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                    script.async = true;
                    script.onload = () => setTimeout(() => resolve(), 20);
                    script.onerror = () => reject(new Error('Leaflet script failed to load'));
                    document.body.appendChild(script);
                } catch (e) {
                    reject(e);
                }
            });
            return window.__leafletLoading;
        }
        
        function updateToggleBtnPosition() {
            const panel = document.getElementById('rightPanel');
            const toggleBtn = document.getElementById('toggleBtn');
            if (!panel || !toggleBtn) return;
            const panelWidth = panel.offsetWidth || 0;
            toggleBtn.style.right = panelWidth + 'px';
        }
        
        function togglePanel() {
            const panel = document.getElementById('rightPanel');
            const toggleBtn = document.getElementById('toggleBtn');
            if (!panel) return;
            
            panelCollapsed = !panelCollapsed;
            if (panelCollapsed) {
                panel.classList.add('collapsed');
                // Panel is collapsed ‚Äî clicking should open it (move left), so show left-facing arrow
                toggleBtn.textContent = 'R ‚óÄ';
                toggleBtn.style.right = '0px';
                try { localStorage.setItem('rightPanelCollapsed', 'true'); } catch(e) {}
            } else {
                // Force reflow before removing class
                void panel.offsetWidth;
                panel.classList.remove('collapsed');
                // Panel is expanded ‚Äî clicking should collapse it (move right), so show right-facing arrow
                toggleBtn.textContent = 'R ‚ñ∂';
                // Set button position to target width immediately - CSS transition will animate both smoothly
                toggleBtn.style.right = '480px';
                try { localStorage.setItem('rightPanelCollapsed', 'false'); } catch(e) {}
            }
        }
        
        async function callAPI(endpoint, name, autoOpen = false) {
            // Only auto-open the right-panel if caller explicitly requests it.
            // Suppress during initial boot to keep panel collapsed by default.
            if (autoOpen && panelCollapsed && !window.suppressPanelAutoOpen) togglePanel();
            const resultEl = document.getElementById('result');
            const statusBar = document.getElementById('status-bar');
            const sn = document.getElementById('deviceSn').value;
            
            let url = endpoint;
            if (sn && (endpoint.includes('/inverter') || endpoint.includes('/scheduler/') || endpoint.includes('/module/signal'))) {
                url += `?sn=${encodeURIComponent(sn)}`;
            }
            
            resultEl.className = '';
            resultEl.textContent = `Loading ${name}...`;
            const startTime = Date.now();
            
                try {
                    // Ensure a global in-flight map exists for deduplication
                    if (!window._inflightRequests) window._inflightRequests = {};
                    const inflightKey = `GET ${url}`;
                    let fetchPromise = window._inflightRequests[inflightKey];
                    if (!fetchPromise) {
                        fetchPromise = (async () => {
                            try {
                                const response = await authenticatedFetch(url);
                                return await response.json();
                            } finally {
                                // Clear the in-flight entry when finished (success or error)
                                try { delete window._inflightRequests[inflightKey]; } catch (e) {}
                            }
                        })();
                        window._inflightRequests[inflightKey] = fetchPromise;
                    }
                    const data = await fetchPromise;
                const endTime = Date.now();
                
                statusBar.style.display = 'flex';
                statusBar.querySelector('.endpoint').textContent = `${name} - ${endpoint}`;
                statusBar.querySelector('.time').textContent = `${endTime - startTime}ms`;
                
                resultEl.className = (data.errno === 0 || data.result) ? 'success' : 'error';
                resultEl.textContent = JSON.stringify(data, null, 2);
                
                // Update inverter card if relevant
                if (endpoint.includes('/inverter/')) {
                    updateInverterCard(data, name);
                }

                // If this was a real-time inverter fetch, prefer the cloud timestamp when available
                try {
                    if (endpoint.includes('/inverter/real-time') || name === 'Real-time Data') {
                        // Save the client fetch time
                        setLastUpdated('inverter');

                        // If the API provided a server/cloud timestamp (result[0].time), parse and use it
                        try {
                            const frame = (data && data.result && Array.isArray(data.result) && data.result[0]) ? data.result[0] : null;
                            if (frame && frame.time) {
                                const parsed = parseFoxESSCloudTime(frame.time);
                                if (parsed) {
                                    // store cloud timestamp (ms since epoch)
                                    lastUpdated.inverterCloud = parsed;
                                    // also show formatted cloud time in the header (DD/MM/YYYY HH:MM)
                                    const el = document.getElementById('inverterCloudTime');
                                    if (el) el.textContent = 'cloud: ' + formatDate(parsed, true);
                                }
                            }
                        } catch (e) {/* ignore parse errors */}
                    }
                } catch (e) { /* ignore */ }
            } catch (error) {
                resultEl.className = 'error';
                resultEl.textContent = `Error: ${error.message}`;
                statusBar.style.display = 'none';
            }
        }

        async function callAPIPost(endpoint, name, bodyTemplate = {}, autoOpen = false) {
            // Only auto-open the right-panel if caller explicitly requests it.
            if (autoOpen && panelCollapsed && !window.suppressPanelAutoOpen) togglePanel();
            const resultEl = document.getElementById('result');
            const statusBar = document.getElementById('status-bar');
            const sn = document.getElementById('deviceSn').value;
            const body = Object.assign({}, bodyTemplate);
            if (sn) body.sn = sn;

            resultEl.className = '';
            resultEl.textContent = `Sending ${name}...`;
            const startTime = Date.now();

            try {
                // POST dedupe: include body in the key so identical requests reuse the same in-flight Promise
                if (!window._inflightRequests) window._inflightRequests = {};
                let bodyKey = '';
                try { bodyKey = JSON.stringify(body); } catch (e) { bodyKey = String(Date.now()); }
                const inflightKey = `POST ${endpoint} ${bodyKey}`;
                let postPromise = window._inflightRequests[inflightKey];
                if (!postPromise) {
                    postPromise = (async () => {
                        try {
                            const response = await authenticatedFetch(endpoint, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(body)
                            });
                            return await response.json();
                        } finally {
                            try { delete window._inflightRequests[inflightKey]; } catch (e) {}
                        }
                    })();
                    window._inflightRequests[inflightKey] = postPromise;
                }
                const data = await postPromise;
                const endTime = Date.now();

                statusBar.style.display = 'flex';
                statusBar.querySelector('.endpoint').textContent = `${name} - ${endpoint}`;
                statusBar.querySelector('.time').textContent = `${endTime - startTime}ms`;

                resultEl.className = (data.errno === 0 || data.result) ? 'success' : 'error';
                resultEl.textContent = JSON.stringify(data, null, 2);
            } catch (error) {
                resultEl.className = 'error';
                resultEl.textContent = `Error: ${error.message}`;
                statusBar.style.display = 'none';
            }
        }

        async function getSetting() {
            const key = document.getElementById('settingKey').value;
            callAPI(`/api/inverter/settings?key=${encodeURIComponent(key)}`, `Setting: ${key}`);
        }

        // Get current inverter work mode (direct setting, not scheduler)
        async function getWorkMode() {
            const displayEl = document.getElementById('currentWorkMode');
            const sn = document.getElementById('deviceSn').value;
            displayEl.textContent = 'Loading...';
            displayEl.style.color = '#8b949e';
            
            try {
                let url = '/api/device/workmode/get';
                if (sn) url += `?sn=${encodeURIComponent(sn)}`;
                const fetchStart = Date.now();
                const response = await authenticatedFetch(url);
                const data = await response.json();
                
                if (data.errno === 0 && data.result) {
                    const result = data.result;
                    const currentMode = result.value;
                    const enumList = result.enumList || [];
                    
                    displayEl.innerHTML = `<span style="color:#7ee787">Current:</span> ${currentMode}`;
                    
                    // Select matching option in dropdown
                    const select = document.getElementById('workModeSelect');
                    for (let opt of select.options) {
                        if (opt.value === currentMode) {
                            select.value = opt.value;
                            break;
                        }
                    }
                } else {
                    displayEl.textContent = data.msg || 'Failed to get mode';
                    displayEl.style.color = '#f85149';
                }
                
                // Also show in the right panel using the fetched data (avoid duplicate network call)
                try {
                    const resultEl = document.getElementById('result');
                    const statusBar = document.getElementById('status-bar');
                    const fetchEnd = Date.now();
                    if (resultEl) {
                        resultEl.className = (data.errno === 0 && data.result) ? 'success' : 'error';
                        resultEl.textContent = JSON.stringify(data, null, 2);
                    }
                    if (statusBar) {
                        statusBar.style.display = 'flex';
                        const endpointLabel = `Work Mode Setting - ${url}`;
                        try { statusBar.querySelector('.endpoint').textContent = endpointLabel; } catch (e) {}
                        try { statusBar.querySelector('.time').textContent = `${fetchEnd - fetchStart}ms`; } catch (e) {}
                    }
                } catch (e) { /* ignore panel update errors */ }
            } catch (error) {
                displayEl.textContent = `Error: ${error.message}`;
                displayEl.style.color = '#f85149';
            }
        }

        // Set inverter work mode (direct setting, not scheduler)
        async function setWorkMode() {
            const displayEl = document.getElementById('currentWorkMode');
            const select = document.getElementById('workModeSelect');
            const workMode = select.value;
            const sn = document.getElementById('deviceSn').value;
            
            if (!workMode) {
                displayEl.textContent = 'Please select a mode';
                displayEl.style.color = '#f85149';
                return;
            }
            
            displayEl.textContent = `Setting to ${workMode}...`;
            displayEl.style.color = '#58a6ff';
            
            try {
                const body = { workMode };
                if (sn) body.sn = sn;
                
                const response = await authenticatedFetch('/api/device/workmode/set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const data = await response.json();
                
                if (data.errno === 0) {
                    displayEl.innerHTML = `<span style="color:#7ee787">‚úì Set to:</span> ${workMode}`;
                } else {
                    displayEl.textContent = data.msg || 'Failed to set mode';
                    displayEl.style.color = '#f85149';
                }
                
                // Show response in right panel
                if (panelCollapsed) togglePanel();
                const resultEl = document.getElementById('result');
                const statusBar = document.getElementById('status-bar');
                statusBar.style.display = 'flex';
                statusBar.querySelector('.endpoint').textContent = `Set Work Mode - /api/device/workmode/set`;
                statusBar.querySelector('.time').textContent = '';
                resultEl.className = data.errno === 0 ? 'success' : 'error';
                resultEl.textContent = JSON.stringify(data, null, 2);
            } catch (error) {
                displayEl.textContent = `Error: ${error.message}`;
                displayEl.style.color = '#f85149';
            }
        }

        async function getAllSettings() {
            if (panelCollapsed) togglePanel();
            const resultEl = document.getElementById('result');
            const statusBar = document.getElementById('status-bar');
            const card = document.getElementById('inverterCard');
            const keys = ['MinSoc', 'MinSocOnGrid'];
            
            resultEl.className = '';
            resultEl.textContent = 'Loading all settings...';
            const startTime = Date.now();
            
            try {
                const results = await Promise.all(keys.map(key => 
                    fetch(`/api/inverter/settings?key=${encodeURIComponent(key)}`).then(r => r.json())
                ));
                const endTime = Date.now();
                
                const settings = {};
                keys.forEach((key, i) => {
                    if (results[i].errno === 0 && results[i].result) {
                        settings[key] = results[i].result;
                    } else {
                        settings[key] = { error: results[i].msg || 'Failed' };
                    }
                });
                
                statusBar.style.display = 'flex';
                statusBar.querySelector('.endpoint').textContent = 'All Settings';
                statusBar.querySelector('.time').textContent = `${endTime - startTime}ms`;
                
                resultEl.className = 'success';
                resultEl.textContent = JSON.stringify(settings, null, 2);
                
                // Update inverter card with settings
                card.innerHTML = `<div class="stat-row">
                    <div class="stat-item"><div class="value">${settings.MinSoc?.value || '-'}%</div><div class="label">Min SoC</div></div>
                    <div class="stat-item"><div class="value">${settings.MinSocOnGrid?.value || '-'}%</div><div class="label">Min On-Grid</div></div>
                </div>`;
            } catch (error) {
                resultEl.className = 'error';
                resultEl.textContent = `Error: ${error.message}`;
                statusBar.style.display = 'none';
            }
        }

        function updateInverterCard(data, name) {
            const card = document.getElementById('inverterCard');
            if (!data || data.errno !== 0) {
                card.innerHTML = `<div style="color:#f85149;font-size:12px">Error loading data</div>`;
                return;
            }
            
            const result = data.result || [];
            if (name === 'Real-time Data' && Array.isArray(result)) {
                // Helper to find a numeric value from common variable keys or variable name patterns
                function findValue(arr, keysOrPatterns) {
                    if (!Array.isArray(arr)) return null;
                    for (const k of keysOrPatterns) {
                        // try exact match on variable
                        const exact = arr.find(it => (it.variable && it.variable.toString().toLowerCase() === k.toString().toLowerCase()) || (it.key && it.key.toString().toLowerCase() === k.toString().toLowerCase()));
                        if (exact && exact.value !== undefined && exact.value !== null) return exact.value;
                        // try includes match on variable name
                        const incl = arr.find(it => (it.variable && it.variable.toString().toLowerCase().includes(k.toString().toLowerCase())) || (it.key && it.key.toString().toLowerCase().includes(k.toString().toLowerCase())));
                        if (incl && incl.value !== undefined && incl.value !== null) return incl.value;
                    }
                    return null;
                }

                // Normalize a list of datapoints from various FoxESS response shapes
                let items = [];
                if (Array.isArray(result)) {
                    // result may be an array of frames, each with a `datas` array
                    if (result.length > 0 && Array.isArray(result[0].datas)) {
                        result.forEach(r => { if (Array.isArray(r.datas)) items.push(...r.datas); });
                    } else {
                        // assume array of simple datapoints
                        items = result.slice();
                    }
                } else if (result && typeof result === 'object') {
                    if (Array.isArray(result.datas)) items = result.datas.slice();
                    else if (Array.isArray(result.data)) items = result.data.slice();
                    else if (result.result && Array.isArray(result.result.datas)) items = result.result.datas.slice();
                    else if (Array.isArray(result.result)) items = result.result.slice();
                }

                // Try a set of common keys for each concept (case-insensitive)
                // Keys expanded to match FoxESS responses (observe real-time payload)
                const solarKeys = ['generationpower', 'generation', 'pvpower','pv_power','pv','solar','generationpower','acpower','pv1power','pv2power','powerpv'];
                // 'loadsPower' is the FoxESS variable for house load
                const loadKeys = ['loadspower','load','loadpower','houseload','house_load','consumption','load_active_power','loadactivepower','loadsPower'];
                // Grid may come as gridConsumptionPower or feedinPower - handle both
                const gridKeys = ['gridconsumptionpower','grid_consumption_power','gridpower','grid_power','grid','meterpower','gridactivepower','grid_active_power','eim','feedinpower','feed_in'];
                // Battery values may appear as batChargePower / batDischargePower
                const battKeys = ['batchargepower','batcharge','batpower','battery','bms_chg_power','batterycharge','batterydischarge','batdischargepower','battery_current','batchargepower','batdischargepower'];

                // Primary raw values
                const solar = findValue(items, solarKeys);
                const houseLoad = findValue(items, loadKeys);
                // Prefer feed-in and grid consumption separately so we can decide import vs export
                const feedIn = findValue(items, ['feedinpower', 'feed_in', 'feed-in', 'feedin']);
                const gridConsumption = findValue(items, ['gridconsumptionpower', 'grid_consumption_power', 'gridconsumption', 'gridconsumption']);
                const grid = gridConsumption !== null && gridConsumption !== undefined ? gridConsumption : findValue(items, gridKeys);
                // Battery: prefer discharge/charge specific keys
                const batDis = findValue(items, ['batdischargepower', 'bat_discharge_power', 'batdischarge', 'dischargepower']);
                const batChg = findValue(items, ['batchargepower', 'bat_charge_power', 'batcharge', 'chargepower']);
                const battery = (batChg !== null && batChg !== undefined) || (batDis !== null && batDis !== undefined) ? { charge: batChg, discharge: batDis } : findValue(items, battKeys);

                // Compute solar production as manufacturer app expects:
                // PV = load + batteryCharge + feedIn - batteryDischarge - gridImport
                // Fallbacks: if any part missing, try generationPower + batCharge as approximation
                const gen = findValue(items, ['generationpower', 'generation', 'outputpower']);
                function asNumber(v) { return v === null || v === undefined || v === '-' ? 0 : Number(v); }
                let computedSolar = null;
                if (houseLoad !== null || batChg !== null || feedIn !== null || batDis !== null || grid !== null) {
                    // Use numeric values (treat missing as 0)
                    const L = asNumber(houseLoad);
                    const C = asNumber(batChg);
                    const F = asNumber(feedIn);
                    const D = asNumber(batDis);
                    const Gc = asNumber(grid);
                    // grid is reported as gridConsumptionPower (positive when importing)
                    computedSolar = L + C + F - D - Gc;
                }
                // If computedSolar is effectively zero and generation is present, prefer generation + charge
                if ((!computedSolar || computedSolar === 0) && gen !== null && (batChg !== null)) {
                    computedSolar = asNumber(gen) + asNumber(batChg);
                }
                // Prefer aggregated pvPower from the device when available (more accurate for total PV)
                const pvTotal = findValue(items, ['pvPower','pvpower','pv_total','pv_total_power']);
                let finalSolar = null;
                if (pvTotal !== null && pvTotal !== undefined && !isNaN(Number(pvTotal))) {
                    finalSolar = pvTotal;
                } else {
                    // If computedSolar set use it, otherwise fall back to raw solar field
                    finalSolar = (computedSolar !== null && !isNaN(Number(computedSolar))) ? computedSolar : solar;
                }

                // Format helper (kW, one decimal). Some APIs return W ‚Äî if value seems large, convert to kW.
                function fmtKW(v) {
                    if (v === null || v === undefined || v === '-') return '-';
                    let n = Number(v);
                    if (isNaN(n)) return '-';
                    // if value looks like watts (>2000), convert to kW
                    if (Math.abs(n) > 2000) n = n / 1000;
                    return n.toFixed(2) + ' kW';
                }

                // Interpret grid using feedIn and gridConsumption when available
                function gridLabel(feedInVal, gridVal) {
                    try {
                        const f = feedInVal !== null && feedInVal !== undefined ? Number(feedInVal) : null;
                        const g = gridVal !== null && gridVal !== undefined ? Number(gridVal) : null;

                        // if both provided and non-zero, show both
                        if (f !== null && !isNaN(f) && Math.abs(f) > 0 && g !== null && !isNaN(g) && Math.abs(g) > 0) {
                            return `Import ${Math.abs(g).toFixed(2)} kW / Export ${Math.abs(f).toFixed(2)} kW`;
                        }
                        if (g !== null && !isNaN(g) && Math.abs(g) > 0) return `${Math.abs(g).toFixed(2)} kW <span class="substatus">(import)</span>`;
                        if (f !== null && !isNaN(f) && Math.abs(f) > 0) return `${Math.abs(f).toFixed(2)} kW <span class="substatus">(export)</span>`;
                        return '‚Äî';
                    } catch (e) { return '‚Äî'; }
                }

                // Interpret battery using separate charge/discharge values when available
                function batteryLabelComposite(objOrVal) {
                    try {
                        if (!objOrVal) return '‚Äî';
                        if (typeof objOrVal === 'object') {
                            const ch = objOrVal.charge !== null && objOrVal.charge !== undefined ? Number(objOrVal.charge) : 0;
                            const dis = objOrVal.discharge !== null && objOrVal.discharge !== undefined ? Number(objOrVal.discharge) : 0;
                            if (!isNaN(dis) && dis > 0) return `${Math.abs(dis).toFixed(2)} kW <span class="substatus">(discharging)</span>`;
                            if (!isNaN(ch) && ch > 0) return `${Math.abs(ch).toFixed(2)} kW <span class="substatus">(charging)</span>`;
                            return '‚Äî';
                        }
                        const n = Number(objOrVal);
                        if (isNaN(n)) return '‚Äî';
                        return n > 0 ? `${Math.abs(n).toFixed(2)} kW <span class="substatus">(charging)</span>` : `${Math.abs(n).toFixed(2)} kW <span class="substatus">(discharging)</span>`;
                    } catch (e) { return '‚Äî'; }
                }

                const solarDisplay = fmtKW(finalSolar);
                const loadDisplay = fmtKW(houseLoad);
                const gridDisplay = grid !== null || feedIn !== null ? gridLabel(feedIn, grid) : '-';
                const batteryDisplay = (typeof battery === 'object' || battery !== null) ? batteryLabelComposite(battery) : batteryLabelComposite(null);

                // Determine coloring for grid and battery
                let batteryIsCharging = false, batteryIsDischarging = false;
                if (typeof battery === 'object') {
                    batteryIsCharging = battery.charge !== null && battery.charge !== undefined && Number(battery.charge) > 0;
                    batteryIsDischarging = battery.discharge !== null && battery.discharge !== undefined && Number(battery.discharge) > 0;
                } else if (battery !== null && battery !== undefined) {
                    const bn = Number(battery);
                    if (!isNaN(bn)) {
                        batteryIsCharging = bn > 0;
                        batteryIsDischarging = bn < 0;
                    }
                }

                // Determine import/export presence robustly. grid/feed in some payloads can be strings
                // (eg "0.01 kW (import)") so we attempt to extract a numeric value when needed.
                let gridIsImport = false, gridIsExport = false;
                const rawG = (grid !== null && grid !== undefined) ? grid : null;
                const rawF = (feedIn !== null && feedIn !== undefined) ? feedIn : null;

                function extractNumberFromRaw(r) {
                    if (r === null || r === undefined) return null;
                    if (typeof r === 'number') return r;
                    // Try to parse direct numeric string
                    if (typeof r === 'string') {
                        // match first number (including decimals and negative)
                        const m = r.match(/-?\d+\.?\d*/);
                        if (m) return Number(m[0]);
                    }
                    const n = Number(r);
                    return isNaN(n) ? null : n;
                }

                const gNumRaw = extractNumberFromRaw(rawG);
                const fNumRaw = extractNumberFromRaw(rawF);
                if (gNumRaw !== null && !isNaN(gNumRaw) && gNumRaw > 0) gridIsImport = true;
                if (fNumRaw !== null && !isNaN(fNumRaw) && fNumRaw > 0) gridIsExport = true;

                // Helper: simple normalization to kW for small-value checks
                function _normToKWForSmall(v) {
                    if (v === null || v === undefined) return null;
                    const n = Number(v);
                    if (isNaN(n)) return null;
                    // Heuristic: large numbers are likely in watts
                    if (Math.abs(n) > 100) return n / 1000;
                    return n;
                }

                // Compute a battery power (kW) for small-value heuristics
                let batteryPowerKW = null;
                if (typeof battery === 'object') {
                    if (batteryIsCharging && battery.charge !== undefined && battery.charge !== null) batteryPowerKW = _normToKWForSmall(battery.charge);
                    else if (batteryIsDischarging && battery.discharge !== undefined && battery.discharge !== null) batteryPowerKW = _normToKWForSmall(battery.discharge);
                    else {
                        // fallback to raw keys if present in payload
                        batteryPowerKW = batteryIsCharging && typeof batChg !== 'undefined' ? _normToKWForSmall(batChg) : (batteryIsDischarging && typeof batDis !== 'undefined' ? _normToKWForSmall(batDis) : null);
                    }
                } else if (battery !== null && battery !== undefined) {
                    batteryPowerKW = _normToKWForSmall(battery);
                }

                // If the battery power is tiny (<0.05 kW) show it as neutral/gray
                const SMALL_BATT_THRESHOLD = 0.05; // kW
                let batteryClass = '';
                if (batteryPowerKW !== null && !isNaN(batteryPowerKW) && Math.abs(batteryPowerKW) < SMALL_BATT_THRESHOLD) {
                    batteryClass = 'price-neutral';
                } else {
                    batteryClass = batteryIsCharging ? 'price-low' : (batteryIsDischarging ? 'price-high' : '');
                }
                // Normalise grid/feed values to kW and keep very small values (close to zero)
                // displayed as neutral/gray. User requested values under 0.05 kW remain gray.
                // Try to find the original items so we can detect units (W vs kW)
                function findItemByKeys(keys) {
                    if (!Array.isArray(items)) return null;
                    for (const k of keys) {
                        const exact = items.find(it => (it.variable && it.variable.toString().toLowerCase() === k.toString().toLowerCase()) || (it.key && it.key.toString().toLowerCase() === k.toString().toLowerCase()));
                        if (exact) return exact;
                        const incl = items.find(it => (it.variable && it.variable.toString().toLowerCase().includes(k.toString().toLowerCase())) || (it.key && it.key.toString().toLowerCase().includes(k.toString().toLowerCase())));
                        if (incl) return incl;
                    }
                    return null;
                }

                function normalizedKWFromValue(val, item) {
                    if (val === null || val === undefined) return null;
                    const n = Number(val);
                    if (isNaN(n)) return null;

                    // If the variable includes a unit string, prefer that
                    const unit = (item && item.unit) ? item.unit.toString().toLowerCase() : '';
                    if (unit.includes('kw')) return n; // already kW
                    if (unit.includes('w')) return n / 1000; // watts -> kW

                    // Fallback heuristics: if value looks large assume watts, otherwise assume kW
                    // Treat values > 100 as watts, convert to kW
                    if (Math.abs(n) > 100) return n / 1000;

                    // If dividing by 1000 produces a value that would be considered "close to zero"
                    // (e.g., 10 -> 0.01), prefer the divided value because many small W values are reported
                    // and should be interpreted as kW when deciding if they're 'near zero'. This is safer
                    // for tiny readings (e.g. 10 -> 0.01 kW) which we want to keep neutral.
                    if (Math.abs(n) / 1000 < 0.05 && Math.abs(n) >= 1) return n / 1000;

                    // Otherwise treat as already kW
                    return n;
                }

                // Use raw values (or extracted numeric) to normalise to kW
                const gKW = normalizedKWFromValue(gNumRaw !== null ? gNumRaw : rawG, findItemByKeys(['gridconsumptionpower','grid_consumption_power','gridpower','grid_power','grid','meterpower','gridactivepower','grid_active_power','eim','feedin','feed_in','feed-in']));
                const fKW = normalizedKWFromValue(fNumRaw !== null ? fNumRaw : rawF, findItemByKeys(['feedinpower','feed_in','feed-in','feedin']));
                let gridClass = '';
                if (gridIsImport && gKW !== null && Math.abs(gKW) < 0.05) {
                    // small import ‚Äî show neutral/gray
                    gridClass = 'price-neutral';
                } else if (gridIsExport && fKW !== null && Math.abs(fKW) < 0.05) {
                    // small export ‚Äî show neutral/gray
                    gridClass = 'price-neutral';
                } else {
                    gridClass = gridIsImport ? 'price-high' : (gridIsExport ? 'price-low' : 'price-neutral');
                }

                // Fallback: if the formatted label contains a numeric reading and that number is < 0.05 kW
                // treat it as near-zero and keep the display neutral. This covers cases where raw
                // values weren't easily parseable earlier.
                try {
                    if (typeof gridDisplay === 'string') {
                        const m = gridDisplay.match(/-?\d+\.?\d*/);
                        if (m) {
                            const parsed = Number(m[0]);
                            if (!isNaN(parsed) && Math.abs(parsed) < 0.05) {
                                gridClass = 'price-neutral';
                            }
                        }
                    }
                } catch (e) { /* ignore fallback parse errors */ }
                // end try

                // Battery capacity used for estimates (kWh). Change here if you have a different pack size.
                const BATTERY_CAP_KWH = 41.93;

                // Try to find SoC in the real-time feed
                const socVal = findValue(items, ['soc','socvalue','SoC','batSoc','bms_soc','stateofcharge','batterySoc','socpercent']);
                const socNum = (socVal !== null && socVal !== undefined && !isNaN(Number(socVal))) ? Number(socVal) : null;

                // helper to normalise numeric power into kW (some endpoints return W)
                function toKW(v) {
                    if (v === null || v === undefined || v === '-') return null;
                    let n = Number(v);
                    if (isNaN(n)) return null;
                    if (Math.abs(n) > 2000) n = n / 1000; // treat as W -> kW
                    return n;
                }

                // Compute estimated time to reach target energy when charging/discharging
                let batteryTimeText = '';
                const currentEnergyKWh = (socNum !== null) ? (socNum / 100.0) * BATTERY_CAP_KWH : null;
                const chKW = (batChg !== null && batChg !== undefined) ? toKW(batChg) : (battery && battery.charge ? toKW(battery.charge) : null);
                const disKW = (batDis !== null && batDis !== undefined) ? toKW(batDis) : (battery && battery.discharge ? toKW(battery.discharge) : null);

                function fmtTimeHours(h) {
                    if (!h || !isFinite(h) || h <= 0) return null;
                    const totMin = Math.round(h * 60);
                    const hours = Math.floor(totMin / 60);
                    const mins = totMin % 60;
                    if (hours === 0) return `${mins}m`;
                    return `${hours}h ${mins}m`;
                }

                if (batteryIsCharging && chKW && chKW > 0 && currentEnergyKWh !== null) {
                    const energyNeeded = Math.max(0, BATTERY_CAP_KWH - currentEnergyKWh);
                    if (energyNeeded <= 0) batteryTimeText = 'Full';
                    else {
                        // base hours to full at current power (kW)
                        let hrs = energyNeeded / chKW;

                        // Add a 5% buffer for the portion of charge above 90% SoC
                        // Battery slows when >90%, so if current or future charge includes >90% portion we increase time accordingly
                        const ninetyKwh = 0.9 * BATTERY_CAP_KWH;
                        if (currentEnergyKWh >= ninetyKwh) {
                            // already beyond 90% ‚Äî apply full 5% buffer
                            hrs *= 1.05;
                        } else if ((currentEnergyKWh + energyNeeded) > ninetyKwh) {
                            // charging will cross 90% ‚Äî only apply buffer proportional to the portion above 90%
                            const portionAbove90 = (currentEnergyKWh + energyNeeded) - ninetyKwh;
                            const proportion = portionAbove90 / energyNeeded; // 0..1
                            hrs *= (1 + 0.05 * proportion);
                        }

                        const s = fmtTimeHours(hrs);
                        batteryTimeText = s ? `‚âà ${s} to ${BATTERY_CAP_KWH.toFixed(2)} kWh` : '';
                    }
                } else if (batteryIsDischarging && disKW && disKW > 0 && currentEnergyKWh !== null) {
                    const targetEnergy = 0.2 * BATTERY_CAP_KWH; // 20%
                    const energyAvailable = Math.max(0, currentEnergyKWh - targetEnergy);
                    if (energyAvailable <= 0) batteryTimeText = `‚â§ 20% (${targetEnergy.toFixed(3)} kWh)`;
                    else {
                        const hrs = energyAvailable / disKW;
                        const s = fmtTimeHours(hrs);
                        batteryTimeText = s ? `‚âà ${s} to 20% (${targetEnergy.toFixed(3)} kWh)` : '';
                    }
                }

                // Helper for temperature class: <40 green, <55 amber, >=55 red
                function tempClassRealtime(v) {
                    if (v === undefined || v === null || isNaN(Number(v))) return '';
                    const n = Number(v);
                    if (n < 40) return 'price-low';
                    if (n < 55) return 'price-mid';
                    return 'price-high';
                }

                // Pull real-time temperatures if present
                const batTempVal = findValue(items, ['batTemperature','bat_temperature','batterytemperature','batTemp','batteryTemp','battemperation']);
                const ambTempVal = findValue(items, ['ambientTemperation','ambienttemperature','ambient_temp','ambientTemp','ambTemperature']);
                const invTempVal = findValue(items, ['invTemperation','invtemperature','invertertemperature','invTemp','inverterTemp']);

                function fmtTemp(v) { if (v === null || v === undefined || v === '-') return '-'; const n = Number(v); if (isNaN(n)) return '-'; return n.toFixed(1) + '¬∞C'; }

                const batTempCls = tempClassRealtime(batTempVal);
                const ambTempCls = tempClassRealtime(ambTempVal);
                const invTempCls = tempClassRealtime(invTempVal);

                const html = `<div class="stat-row">
                    <div class="stat-item"><div class="tile-icon">‚òÄÔ∏è</div><div class="value">${solarDisplay}</div><div class="label">Solar Production</div></div>
                    <div class="stat-item"><div class="tile-icon">üè†</div><div class="value">${loadDisplay}</div><div class="label">House Load</div></div>
                    <div class="stat-item"><div class="tile-icon">üîå</div><div class="value ${gridClass}">${gridDisplay}</div><div class="label">Grid Import/Export</div></div>
                    <div class="stat-item battery-tile"><div class="tile-icon battery ${batteryIsCharging ? 'charging' : ''}">
                                <!-- Inline SVG battery: fill level reflects SoC -->
                                ${(() => {
                                    const socPct = (socNum !== null && !isNaN(Number(socNum))) ? Math.max(0, Math.min(100, Number(socNum))) : 0;
                                    // innerHeight = 28 (y from 4..32). Compute rect y and height so fill starts at bottom
                                    const innerH = 28;
                                    const fillH = Math.round((socPct / 100) * innerH);
                                    const y = 4 + (innerH - fillH);
                                    const fillColor = socPct >= 80 ? '#16a34a' : (socPct >= 40 ? '#7ee787' : '#d29922');
                                    return `
                                    <svg viewBox="0 0 24 40" aria-hidden="true">
                                        <rect x="3" y="4" width="18" height="28" rx="3" ry="3" fill="none" stroke="rgba(255,255,255,0.12)" stroke-width="1.5"></rect>
                                        <rect x="3" y="${y}" width="18" height="${fillH}" rx="2" ry="2" class="level" fill="${fillColor}"></rect>
                                        <rect x="9" y="1" width="6" height="2" rx="1" ry="1" fill="rgba(255,255,255,0.12)"></rect>
                                    </svg>`;
                                })()}
                            </div>
                            <div class="value ${batteryClass}" style="font-size:20px;font-weight:600">${batteryDisplay}</div>
                        <div style="font-size:28px;font-weight:700;color:#58a6ff;margin-top:4px">${socNum !== null ? socNum.toFixed(0) + '%' : '-'}</div>
                        <div style="font-size:12px;color:#8b949e;margin-top:2px">${currentEnergyKWh !== null ? (currentEnergyKWh.toFixed(2) + ' kWh') : ''}</div>
                        <div style="font-size:11px;color:#8b949e;margin-top:4px">${batteryTimeText || ''}</div>
                    </div>
                </div>

                <!-- Inline temps row for real-time display -->
                <div class="stat-row" style="margin-top:8px">
                        <div class="stat-item" style="min-width:140px">
                            <div class="tile-icon">üå°Ô∏è</div>
                            <div class="value ${batTempCls}" style="font-size:18px">${batTempVal !== null && batTempVal !== undefined ? fmtTemp(batTempVal) : '-'}</div>
                            <div class="label">Battery Temp</div>
                        </div>
                    <div class="stat-item" style="min-width:140px">
                        <div class="tile-icon">üå°Ô∏è</div>
                        <div class="value ${ambTempCls}" style="font-size:18px">${ambTempVal !== null && ambTempVal !== undefined ? fmtTemp(ambTempVal) : '-'}</div>
                        <div class="label">Ambient Temp</div>
                    </div>
                    <div class="stat-item" style="min-width:140px">
                        <div class="tile-icon">üå°Ô∏è</div>
                        <div class="value ${invTempCls}" style="font-size:18px">${invTempVal !== null && invTempVal !== undefined ? fmtTemp(invTempVal) : '-'}</div>
                        <div class="label">Inverter Temp</div>
                    </div>
                </div>`;
                // Debug raw view removed for stable inverter status
                const rawHtml = '';

                // Display per-PV-string outputs if present (pv1Power..pv4Power)
                const pvStrings = [];
                for (let i = 1; i <= 4; i++) {
                    const pKey = `pv${i}power`;
                    const vKey = `pv${i}volt`;
                    const cKey = `pv${i}current`;
                    const p = findValue(items, [pKey, `pv${i}Power`]);
                    const v = findValue(items, [vKey, `pv${i}Volt`]);
                    const c = findValue(items, [cKey, `pv${i}Current`]);
                    if (p !== null && p !== undefined) pvStrings.push({ idx: i, power: p, volt: v, current: c });
                }
                // Also include aggregated pvPower if available
                const pvPowerTotal = findValue(items, ['pvPower','pvpower']);

                if (pvStrings.length) {
                    let pvHtml = '<div style="margin-top:12px;font-size:12px;color:#8b949e;font-weight:600">üî∏ PV String Outputs';
                    if (pvPowerTotal !== null && pvPowerTotal !== undefined) {
                        pvHtml += ` <span style="color:#7ee787;font-weight:700">(Total: ${fmtKW(pvPowerTotal)})</span>`;
                    }
                    pvHtml += '</div>';
                    pvHtml += '<div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:8px">';
                    pvStrings.forEach(s => {
                        const voltStr = s.volt !== null && s.volt !== undefined ? `${Number(s.volt).toFixed(1)}V` : '-';
                        const currStr = s.current !== null && s.current !== undefined ? `${Number(s.current).toFixed(1)}A` : '-';
                        const pvColor = (Number(s.power) === 0) ? '#8b949e' : '#7ee787';
                        pvHtml += `<div class="stat-item" style="min-width:90px;padding:10px;text-align:center">
                            <div class="value" style="font-size:18px;font-weight:700;color:${pvColor}">${fmtKW(s.power)}</div>
                            <div class="label" style="font-size:12px;color:#58a6ff;margin-top:4px;font-weight:600">PV${s.idx}</div>
                            <div style="font-size:10px;color:#8b949e;margin-top:4px">${voltStr} ¬∑ ${currStr}</div>
                        </div>`;
                    });
                    pvHtml += '</div>';
                    card.innerHTML = html + pvHtml;
                } else {
                    card.innerHTML = html;
                }
            } else if (name === 'Battery SoC' && data.result) {
                const r = data.result;
                card.innerHTML = `<div class="stat-row">
                    <div class="stat-item"><div class="value">${r.minSoc || '-'}%</div><div class="label">Min SoC</div></div>
                    <div class="stat-item"><div class="value">${r.minSocOnGrid || '-'}%</div><div class="label">Min On-Grid</div></div>
                </div>`;
            } else if (name === 'Temperatures' && Array.isArray(result) && result[0]?.datas) {
                const temps = result[0].datas;
                const batTemp = temps.find(t => t.variable === 'batTemperature');
                const ambTemp = temps.find(t => t.variable === 'ambientTemperation');
                const invTemp = temps.find(t => t.variable === 'invTemperation');
                const time = result[0].time || '';

                // Temperature threshold helper: <40 green, <55 amber, >=55 red
                function tempClass(v) {
                    if (v === undefined || v === null || isNaN(Number(v))) return '';
                    const n = Number(v);
                    if (n < 40) return 'price-low';
                    if (n < 55) return 'price-mid';
                    return 'price-high';
                }

                const batCls = tempClass(batTemp?.value);
                const ambCls = tempClass(ambTemp?.value);
                const invCls = tempClass(invTemp?.value);

                card.innerHTML = `
                    <div class="stat-row">
                        <div class="stat-item" style="flex:2">
                            <div class="value ${batCls}" style="font-size:28px">üîã ${batTemp ? batTemp.value : '-'}¬∞C</div>
                            <div class="label">Battery Temperature</div>
                        </div>
                    </div>
                    <div class="stat-row" style="margin-top:8px">
                        <div class="stat-item"><div class="value ${ambCls}">${ambTemp ? ambTemp.value : '-'}¬∞C</div><div class="label">Ambient</div></div>
                        <div class="stat-item"><div class="value ${invCls}">${invTemp ? invTemp.value : '-'}¬∞C</div><div class="label">Inverter</div></div>
                    </div>
                    <div style="font-size:10px;color:#8b949e;margin-top:6px;text-align:center">${time}</div>`;
            } else if (name === 'Generation' && data.result) {
                const r = data.result;
                card.innerHTML = `<div class="stat-row">
                    <div class="stat-item"><div class="value">${r.today?.toFixed(1) || '-'} kWh</div><div class="label">Today</div></div>
                    <div class="stat-item"><div class="value">${r.month?.toFixed(1) || '-'} kWh</div><div class="label">Month</div></div>
                    <div class="stat-item"><div class="value">${r.cumulative?.toFixed(0) || '-'} kWh</div><div class="label">Total</div></div>
                </div>`;
            } else {
                card.innerHTML = `<div style="color:#7ee787;font-size:12px">‚úì ${name} loaded - see response panel</div>`;
            }
        }

        // Weather
        async function getWeather() {
            const placeEl = document.getElementById('weatherPlace');
            const rawPlace = (placeEl && typeof placeEl.value === 'string') ? placeEl.value.trim() : '';
            // Guard against the literal string 'undefined' (can appear from bad inputs)
            const cleanRaw = (rawPlace && rawPlace !== 'undefined') ? rawPlace : '';
            const place = cleanRaw || 'Roselands 2196 NSW';
            // normalize back into the input (helps when using autocomplete)
            try { if (placeEl) placeEl.value = (place === 'Roselands 2196 NSW' ? placeEl.value || place : place); } catch (e) {}

            const days = Number(document.getElementById('weatherDays').value || 6);
            const card = document.getElementById('weatherCard');
            card.innerHTML = '<div style="color:#8b949e">Loading weather...</div>';

            try {
                const resp = await authenticatedFetch(`/api/weather?place=${encodeURIComponent(place)}&days=${days}`);
                const data = await resp.json();
                renderWeatherCard(data);
                // mark last updated for weather
                setLastUpdated('weather');

                // Show full payload in the result panel
                document.getElementById('result').textContent = JSON.stringify(data, null, 2);
                // If API returned a resolved place name, prefer that in the status bar
                document.getElementById('status-bar').style.display = 'flex';
                // Prefer the API-resolved name for display, but only if it was
                // genuinely resolved (i.e. the server did not fall back to defaults).
                // We still derive the dismissal key from resolvedName or the query
                // (so it remains stable across page-load vs manual searches).
                const resolved = (data && data.place && data.place.resolvedName && !data.place.fallback) ? data.place.resolvedName : '';
                // Use the original query as the dismissal key when available so the
                // user-dismiss action applies to their typed query (not a backend
                // resolved/fallback name). Fallback to resolvedName if query missing.
                const locKeySource = (data && data.place && (data.place.query || data.place.resolvedName)) ? (data.place.query || data.place.resolvedName) : place;
                // build a sanitized key for dismissals (use locKeySource so key is stable)
                const locKey = (locKeySource || 'unknown').toString().trim().toLowerCase().replace(/\s+/g,'_').replace(/[^a-z0-9_-]/g,'');
                let endpointText = resolved ? `Weather - ${resolved}` : 'Weather';
                // If server indicated it used fallback coordinates, make that visible to user
                let dismissed = false;
                try { dismissed = !!localStorage.getItem('weatherFallbackDismissed:' + locKey); } catch (e) { dismissed = false; }
                if (data && data.place && data.place.fallback && !dismissed) {
                    endpointText += ' (used fallback coords)';
                    // also make status-bar visually noticeable
                    document.getElementById('status-bar').style.border = '1px solid #f5c542';
                } else {
                    document.getElementById('status-bar').style.border = '';
                }
                document.getElementById('status-bar').querySelector('.endpoint').textContent = endpointText;
            } catch (e) {
                card.innerHTML = `<div style="color:#f85149">Error: ${e.message}</div>`;
            }
        }

        function weatherCodeToWord(code) {
            // Map Open-Meteo / WMO weather codes to simple one-word descriptions
            const c = Number(code);
            if (c === 0) return 'Clear';
            if (c === 1 || c === 2) return 'Partly Cloudy';
            if (c === 3) return 'Overcast';
            if (c === 45 || c === 48) return 'Fog';
            if ([51,53,55].includes(c)) return 'Drizzle';
            if ([56,57].includes(c)) return 'Freezing Drizzle';
            if ([61,63,65].includes(c)) return 'Rain';
            if ([66,67].includes(c)) return 'Freezing Rain';
            if ([71,73,75,77].includes(c)) return 'Snow';
            if ([80,81,82].includes(c)) return 'Showers';
            if ([85,86].includes(c)) return 'Snow Showers';
            if (c === 95 || c === 96 || c === 99) return 'Thunderstorm';
            return 'Unknown';
        }

        // Ensure Leaflet is loaded (returns a Promise). Loads CSS+JS once via CDN.
        function ensureLeafletLoaded() {
            if (window._leafletPromise) return window._leafletPromise;
            window._leafletPromise = new Promise((resolve, reject) => {
                // If L already exists, resolve immediately
                if (window.L) return resolve(window.L);

                // Load CSS
                try {
                    const cssId = 'leaflet-css';
                    if (!document.getElementById(cssId)) {
                        const link = document.createElement('link');
                        link.id = cssId;
                        link.rel = 'stylesheet';
                        link.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                        link.crossOrigin = '';
                        document.head.appendChild(link);
                    }
                } catch (e) { /* ignore */ }

                // Load script
                const jsId = 'leaflet-js';
                if (document.getElementById(jsId)) {
                    // wait for it to be available
                    const waitForL = setInterval(() => {
                        if (window.L) {
                            clearInterval(waitForL);
                            resolve(window.L);
                        }
                    }, 50);
                    // timeout safety
                    setTimeout(() => { clearInterval(waitForL); if (!window.L) reject(new Error('Leaflet failed to load')); }, 8000);
                    return;
                }

                const script = document.createElement('script');
                script.id = jsId;
                script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                script.async = true;
                script.onload = () => {
                    if (window.L) resolve(window.L);
                    else reject(new Error('Leaflet loaded but L not available'));
                };
                script.onerror = () => reject(new Error('Failed to load Leaflet script'));
                document.head.appendChild(script);
            });
            return window._leafletPromise;
        }

        // Update the small label showing how many days are requested by the control
        function updateWeatherRequestedLabel() {
            try {
                const el = document.getElementById('weatherDays');
                const lbl = document.getElementById('weatherRequestedLabel');
                if (!lbl || !el) return;
                const v = (el.value && String(el.value).trim()) ? String(el.value).trim() : '6';
                lbl.textContent = `Requested: ${v}`;
            } catch (e) { /* ignore */ }
        }

        function renderWeatherCard(data) {
            const card = document.getElementById('weatherCard');
            if (!data) { card.innerHTML = '<div style="color:#f85149">No data</div>'; return; }

            const place = data.place || {};
            const current = data.current || null;
            const daily = data.daily || null;

            // Build a concise location header: prefer API-resolved name, show country and coords if available
            // Show the resolved name when available. If the server used fallback
            // coordinates, prefer a friendly `fallbackResolvedName` (provided by
            // the backend) so we can display a human-readable fallback place.
            let locName = '';
            if (place && typeof place === 'object') {
                const tryName = (v) => (v === undefined || v === null || String(v).toLowerCase() === 'undefined') ? '' : String(v);
                if (place.fallback && tryName(place.fallbackResolvedName)) {
                    locName = tryName(place.fallbackResolvedName);
                } else if (tryName(place.resolvedName) && !place.fallback) {
                    locName = tryName(place.resolvedName);
                }
            }
            const lat = (place.latitude !== undefined && place.latitude !== null) ? Number(place.latitude).toFixed(4) : null;
            const lon = (place.longitude !== undefined && place.longitude !== null) ? Number(place.longitude).toFixed(4) : null;
            // sanitized key for map/banner instances (based on user's query when available)
            const locKey = (place.query || place.resolvedName || 'unknown').toString().trim().toLowerCase().replace(/\s+/g,'_').replace(/[^a-z0-9_-]/g,'');
            const country = place.country || '';
            let locExtra = '';
            if (country) locExtra += country;
            if (lat !== null && lon !== null) locExtra += (locExtra ? ' ‚Ä¢ ' : '') + `${lat}, ${lon}`;
            // If the API resolved a location name, show it. If not, show a friendly
            // label and include an info icon when the server fell back to coordinates.
            let headerTooltip = '';
            if (place && place.fallback) {
                const reasonText = (place.fallbackReason || 'unknown').replace(/_/g,' ');
                headerTooltip = ` <span class="info-tip" title="Using fallback coordinates: ${reasonText}">‚ìò</span>`;
            }
            let html = `<div style="font-weight:600;color:#58a6ff;margin-bottom:6px">${locName || 'Unknown location'}${headerTooltip}</div>`;
            if (locExtra) html += `<div style="font-size:12px;color:#8b949e;margin-bottom:8px">${locExtra}</div>`;

            // Show a visible, dismissible warning when the backend had to use fallback coordinates
            if (place && place.fallback) {
                const reason = place.fallbackReason || 'unknown';
                // Prefer the original query when building the banner key so dismissal
                // is associated with what the user typed, not the backend's resolved label.
                const locKeyBanner = (place.query || place.resolvedName || '').toString().trim().toLowerCase().replace(/\s+/g,'_').replace(/[^a-z0-9_-]/g,'');
                let dismissedBanner = false;
                try { dismissedBanner = !!localStorage.getItem('weatherFallbackDismissed:' + locKeyBanner); } catch (e) { dismissedBanner = false; }
                if (!dismissedBanner) {
                    html += `<div id="weather-fallback-banner-${locKeyBanner}" style="margin-top:8px;padding:10px;border-radius:8px;background:linear-gradient(90deg,#3b2f00,#5a4300);color:#fff;font-size:13px;display:flex;align-items:center;gap:10px;justify-content:space-between">
                        <div style="flex:1"><strong>‚ö†Ô∏è Location not resolved</strong><span style="opacity:0.9;margin-left:8px">Using fallback coordinates (${reason.replace(/_/g,' ')})</span></div>
                        <div style="flex:0 0 auto;margin-left:12px"><button onclick="dismissWeatherFallback('${locKeyBanner}')" style="background:transparent;border:1px solid rgba(255,255,255,0.12);color:#fff;padding:6px 10px;border-radius:6px;cursor:pointer">Dismiss</button></div>
                    </div>`;
                }
            }

            if (current) {
                // Determine today's weather description and rainfall if available
                const todayCode = (current.weathercode !== undefined && current.weathercode !== null) ? current.weathercode : (daily && daily.weathercode ? daily.weathercode[0] : null);
                const todayDesc = todayCode !== null ? weatherCodeToWord(todayCode) : 'Unknown';
                const rainArr = daily && (daily.precipitation_sum || daily.precipitation || daily.rain_sum) ? (daily.precipitation_sum || daily.precipitation || daily.rain_sum) : null;
                const todayRain = (rainArr && rainArr[0] !== undefined) ? Number(rainArr[0]) : null;

                // windInfo: prefer current.windspeed and current.winddirection when supplied (Open-Meteo style)
                function degToCompass(num) {
                    if (num === null || num === undefined || isNaN(Number(num))) return '';
                    const val = Math.floor((Number(num) / 22.5) + 0.5);
                    const arr = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'];
                    return arr[(val % 16)];
                }

                const windSpeed = (current.windspeed !== undefined && current.windspeed !== null) ? Number(current.windspeed) : null;
                const windDirDeg = (current.winddirection !== undefined && current.winddirection !== null) ? Number(current.winddirection) : null;
                const windDirName = windDirDeg !== null ? degToCompass(windDirDeg) : '';

                const nowTemp = (current.temperature !== undefined && current.temperature !== null && String(current.temperature).toLowerCase() !== 'undefined') ? `${current.temperature}¬∞` : '‚Äî';
                html += `<div class="live-stat"><span class="value">${nowTemp}</span><span class="unit">C</span><span class="label">Now</span></div>`;
                html += `<div style="margin-top:8px;font-size:13px;color:#8b949e">${todayDesc} ‚Ä¢ Rain: ${todayRain !== null ? todayRain.toFixed(1) + ' mm' : '‚Äî'}`;
                if (windSpeed !== null) html += ` ‚Ä¢ Wind: <strong style="color:#c9d1d9">${windSpeed.toFixed(1)} km/h</strong>${windDirName ? ' ' + windDirName : ''}`;
                html += `</div>`;
            }

            if (daily && daily.time) {
                html += '<div class="weather-days">';
                // Respect the user's requested days (fallback to available daily length)
                const requestedDays = Number(document.getElementById('weatherDays')?.value) || daily.time.length;
                const showCount = Math.min(daily.time.length, Math.max(1, requestedDays));
                for (let i = 0; i < showCount; i++) {
                    const d = daily.time[i];
                    const tmax = (daily.temperature_2m_max && daily.temperature_2m_max[i] !== undefined && daily.temperature_2m_max[i] !== null && String(daily.temperature_2m_max[i]).toLowerCase() !== 'undefined') ? daily.temperature_2m_max[i] : '-';
                    const tmin = (daily.temperature_2m_min && daily.temperature_2m_min[i] !== undefined && daily.temperature_2m_min[i] !== null && String(daily.temperature_2m_min[i]).toLowerCase() !== 'undefined') ? daily.temperature_2m_min[i] : '-';
                    const code = (daily.weathercode && daily.weathercode[i] !== undefined) ? daily.weathercode[i] : null;
                    const desc = code !== null ? weatherCodeToWord(code) : 'Unknown';
                    // precipitation_sum can be named differently depending on API fields
                    const rainArr = daily.precipitation_sum || daily.precipitation || daily.rain_sum || null;
                    const rain = (rainArr && rainArr[i] !== undefined) ? Number(rainArr[i]) : null;

                    // Detect "extreme" conditions for this day so we can visually highlight them.
                    // Rules (tunable): heavy rain >= 10mm, very hot high >= 35¬∞C, very cold low <= 0¬∞C,
                    // or descriptions that mention storm/thunder/snow/hail/sleet/blizzard/heavy
                    const extremeReasons = [];
                    try {
                        if (rain !== null && !isNaN(rain) && rain >= 10) extremeReasons.push(`Heavy rain: ${rain.toFixed(1)} mm`);
                        if (!isNaN(Number(tmax)) && Number(tmax) >= 35) extremeReasons.push(`High heat: ${Number(tmax)}¬∞`);
                        if (!isNaN(Number(tmin)) && Number(tmin) <= 0) extremeReasons.push(`Very cold: ${Number(tmin)}¬∞`);
                        if (desc && /thunder|storm|snow|sleet|hail|blizzard|heavy/i.test(String(desc))) extremeReasons.push(String(desc));
                    } catch (e) { /* ignore detection errors */ }
                    const isExtreme = extremeReasons.length > 0;
                    const extremeClass = isExtreme ? ' extreme' : '';
                    const extremeTitle = isExtreme ? ` title="${extremeReasons.join('; ')}"` : '';

                    html += `<div class="stat-item${extremeClass}"${extremeTitle}>
                        <div style="font-size:12px;font-weight:700;color:#e6edf3">${formatDate(d, false)}</div>
                        <div style="font-size:13px;color:#58a6ff;font-weight:600;margin-top:4px">${desc}</div>
                        <div style="font-size:12px;color:#8b949e;margin-top:4px">High ${tmax}¬∞ / Low ${tmin}¬∞</div>
                        <div style="font-size:11px;color:#7ee787;margin-top:3px">Rain: ${rain !== null ? rain.toFixed(1) + ' mm' : '‚Äî'}</div>
                    </div>`;
                }
                html += '</div>';
            }

            // Insert a small inline map below the weather content when we have coordinates
            if (lat !== null && lon !== null) {
                html += `<div class="weather-map" id="weather-map-${locKey}"></div>`;
            }

            card.innerHTML = html;

            // Initialize or update the inline Leaflet map for this location
            try {
                if (lat !== null && lon !== null) {
                    // Retry loop to ensure container is ready and Leaflet loads
                    let attempts = 0;
                    const mapId = 'weather-map-' + locKey;
                    function tryInitMap() {
                        const mapEl = document.getElementById(mapId);
                        // Only attempt to initialize when element exists and is laid out
                        // (non-zero width/height). When forecast count is large the
                        // element may be present but not yet painted or sized.
                        if (mapEl && (mapEl.offsetWidth === 0 || mapEl.offsetHeight === 0)) {
                            // wait longer for layout to stabilise
                            if (attempts < 60) {
                                attempts++;
                                const delay = attempts < 12 ? 100 : 160; // back off a bit
                                setTimeout(tryInitMap, delay);
                                return;
                            }
                        }
                        if (!mapEl) {
                            // When many tiles are rendered the browser may take longer to
                            // parse/paint the large innerHTML blob. Retry longer to ensure
                            // the container appears before giving up.
                            if (attempts < 40) {
                                attempts++;
                                // progressive backoff: start fast then slow down
                                const delay = attempts < 8 ? 80 : 120;
                                setTimeout(tryInitMap, delay);
                            } else {
                                console.warn('Leaflet map container not found after retries:', mapId);
                                // Show error in container if the element exists later
                                if (mapEl) mapEl.innerHTML = '<div style="color:#f85149;font-size:13px;padding:8px">Map container not found</div>';
                            }
                            return;
                        }
                        ensureLeafletLoaded().then(() => {
                            try {
                                if (!window.weatherMaps) window.weatherMaps = {};
                                const latNum = Number(place.latitude);
                                const lonNum = Number(place.longitude);
                                // Reuse existing map instance if present
                                if (window.weatherMaps[mapId]) {
                                    let m = window.weatherMaps[mapId];
                                    // If the stored map instance is attached to an old/removed container
                                    // (card.innerHTML was replaced), recreate the map on the new element.
                                    try {
                                        const currentContainer = m.getContainer && m.getContainer();
                                        if (!currentContainer || currentContainer !== mapEl) {
                                            try {
                                                // disconnect any attached observers/listeners before removing
                                                try { if (m._resizeObserver) m._resizeObserver.disconnect(); } catch(e){}
                                                try { if (m._resizeListener) window.removeEventListener('resize', m._resizeListener); } catch(e){}
                                                m.remove && m.remove();
                                            } catch (err) { /* ignore */ }
                                            // drop stale instance so we create a fresh one below
                                            delete window.weatherMaps[mapId];
                                            m = null;
                                        }
                                    } catch (err) {
                                        // If anything goes wrong checking container, prefer to recreate
                                        try { m.remove && m.remove(); } catch (e){}
                                        delete window.weatherMaps[mapId];
                                        m = null;
                                    }
                                    if (m) {
                                    m.setView([latNum, lonNum], 9);
                                    try { if (m._weatherMarker) m.removeLayer(m._weatherMarker); } catch(e){}
                                    const mark = L.circleMarker([latNum, lonNum], { radius:6, fillColor:'#58a6ff', color:'#fff', weight:1, fillOpacity:0.95 }).addTo(m);
                                    m._weatherMarker = mark;
                                        // In some cases reflow needs multiple ticks ‚Äî call invalidate repeatedly
                                        const invalidate = () => {
                                            try { m.invalidateSize && m.invalidateSize(); if (m._weatherMarker) m._weatherMarker.setLatLng([latNum, lonNum]); } catch(e){}
                                        };
                                        requestAnimationFrame(invalidate);
                                        setTimeout(invalidate, 160);
                                        setTimeout(invalidate, 420);
                                        setTimeout(invalidate, 900);
                                        setTimeout(invalidate, 1600);
                                        // Ensure map invalidates when its container or window resizes
                                        try {
                                            if (!m._resizeObserver && 'ResizeObserver' in window) {
                                                const ro = new ResizeObserver(() => { try { m.invalidateSize && m.invalidateSize(); } catch(e){} });
                                                ro.observe(mapEl);
                                                m._resizeObserver = ro;
                                            } else if (!m._resizeListener) {
                                                const onWin = () => { try { m.invalidateSize && m.invalidateSize(); } catch(e){} };
                                                window.addEventListener('resize', onWin);
                                                m._resizeListener = onWin;
                                            }
                                        } catch(e) {}
                                    console.log('Leaflet map updated:', mapId);
                                    } else {
                                        // Removed stale map instance ‚Äî fall through to create a new map below
                                    }
                                } else {
                                    const m = L.map(mapId, { zoomControl:false, attributionControl:false, dragging:false, scrollWheelZoom:false, doubleClickZoom:false, boxZoom:false, touchZoom:false }).setView([latNum, lonNum], 9);
                                    const tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 });
                                    // diagnostic counters & handlers
                                    let tileLoadCount = 0;
                                    // lightweight in-map diagnostics node
                                    function ensureDiagNode() {
                                        const el = document.getElementById(mapId);
                                        if (!el) return null;
                                        return null;
                                    }
                                    tileLayer.on('tileload', function (ev) {
                                        tileLoadCount++;
                                        // ensure the specific tile is visible (fallback if stylesheet didn't load)
                                        try { if (ev && ev.tile) { ev.tile.style.opacity = '1'; ev.tile.style.visibility = 'visible'; ev.tile.style.filter = 'none'; } } catch(e){}
                                        // ...existing code...
                                    });
                                    tileLayer.on('load', function () {
                                        console.log('tileLayer load event:', mapId, 'tilesLoaded=', tileLoadCount);
                                        // ...existing code...
                                    });
                                    tileLayer.on('tileerror', function (ev) {
                                        const mapEl = document.getElementById(mapId);
                                        console.warn('tileerror', mapId, ev);
                                        // ...existing code...
                                    });
                                    tileLayer.addTo(m);
                                    const mark = L.circleMarker([latNum, lonNum], { radius:6, fillColor:'#58a6ff', color:'#fff', weight:1, fillOpacity:0.95 }).addTo(m);
                                    m._weatherMarker = mark;
                                    window.weatherMaps[mapId] = m;
                                    // Attach a ResizeObserver so the map adapts to the card/panel width
                                    try {
                                        if ('ResizeObserver' in window) {
                                            const ro2 = new ResizeObserver(() => { try { m.invalidateSize && m.invalidateSize(); } catch(e){} });
                                            const mapElNow = document.getElementById(mapId);
                                            if (mapElNow) {
                                                ro2.observe(mapElNow);
                                                m._resizeObserver = ro2;
                                            }
                                        } else {
                                            const onWin2 = () => { try { m.invalidateSize && m.invalidateSize(); } catch(e){} };
                                            window.addEventListener('resize', onWin2);
                                            m._resizeListener = onWin2;
                                        }
                                    } catch(e) {}
                                    setTimeout(() => { try { m.invalidateSize && m.invalidateSize(); } catch(e){} }, 200);
                                    // Ensure map also invalidates a bit later to handle large DOM updates
                                    setTimeout(() => { try { m.invalidateSize && m.invalidateSize(); } catch(e){} }, 800);
                                    // Extra diagnostics: log map size and tile container children
                                            setTimeout(() => {
                                        try {
                                            const size = m.getSize();
                                            const tileContainer = mapEl.querySelector('.leaflet-tile-pane');
                                            const tiles = tileContainer ? tileContainer.querySelectorAll('img') : [];
                                            console.log('map diagnostics:', mapId, 'size:', size, 'tile-img-count:', tiles.length, 'tileLoadCount:', tileLoadCount);
                                            // If no tiles loaded after a short delay, attempt a direct tile test by requesting a single tile image
                                            if (tileLoadCount === 0) {
                                                try {
                                                    const z = 9;
                                                    // convert lat/lon to tile xy for zoom z
                                                    function long2tile(lon, z) { return Math.floor((lon + 180) / 360 * Math.pow(2, z)); }
                                                    function lat2tile(lat, z) { return Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, z)); }
                                                    const tx = long2tile(latNum ? lonNum : 151.03, z);
                                                    const ty = lat2tile(latNum ? latNum : -33.92, z);
                                                    const tileUrl = `https://a.tile.openstreetmap.org/${z}/${tx}/${ty}.png`;
                                                    console.log('Attempt direct tile fetch:', tileUrl);
                                                    const tImg = new Image();
                                                    tImg.crossOrigin = 'anonymous';
                                                    tImg.onload = function() {
                                                        console.log('Direct tile onload OK');
                                                        // ...existing code...
                                                    };
                                                    tImg.onerror = function(err) {
                                                        console.warn('Direct tile failed to load', err);
                                                        // ...existing code...
                                                    };
                                                    tImg.src = tileUrl;
                                                } catch(e) { console.error('direct tile test failed', e); }
                                            }
                                        } catch (e) { console.error('map diag error', e); }
                                            }, 600);
                                            // extra run: collect per-tile diagnostics and display them
                                            setTimeout(() => {
                                                try {
                                                    const mapEl2 = document.getElementById(mapId);
                                                    if (!mapEl2) return;
                                                    const tilePane = mapEl2.querySelector('.leaflet-tile-pane');
                                                    const tiles = tilePane ? Array.from(tilePane.querySelectorAll('img')) : [];
                                                    const diag2 = ensureDiagNode();
                                                    if (diag2) {
                                                        if (tiles.length === 0) {
                                                            diag2.textContent = (diag2.textContent || '') + ' | tiles:0';
                                                        } else {
                                                            let info = ' | tiles:' + tiles.length + ' [';
                                                            info += tiles.slice(0,6).map(img => {
                                                                const src = img.src.split('/').slice(-3).join('/');
                                                                const cw = img.naturalWidth || img.width || 0;
                                                                const ch = img.naturalHeight || img.height || 0;
                                                                const style = window.getComputedStyle(img);
                                                                return `${src} w:${cw} h:${ch} d:${style.display} o:${style.opacity}`;
                                                            }).join(' ; ');
                                                            info += (tiles.length > 6 ? ' ‚Ä¶' : '') + ']';
                                                            diag2.textContent = (diag2.textContent || '') + info;
                                                        }
                                                    }
                                                } catch(e) { console.error('tile diagnostics 2 error', e); }
                                            }, 900);
                                    console.log('Leaflet map created:', mapId);
                                }
                            } catch (e) {
                                console.error('Map init error:', e);
                                mapEl.innerHTML = '<div style="color:#f85149;font-size:13px;padding:8px">Map init error: ' + e.message + '</div>';
                            }
                        }).catch((e) => {
                            console.error('Leaflet failed to load:', e);
                            mapEl.innerHTML = '<div style="color:#f85149;font-size:13px;padding:8px">Leaflet failed to load</div>';
                        });
                    }
                    setTimeout(tryInitMap, 120);
                }
            } catch (e) { /* ignore */ }

            // Populate debug raw intervals list for feed-in so we can compare exact nemTime/perKwh/spotPerKwh
            const rawDiv = document.getElementById('amberRaw');
            if (rawDiv) {
                const feedList = feedIn.slice(0, 48); // up to next 48 intervals
                if (feedList.length === 0) {
                    rawDiv.style.display = 'none';
                } else {
                    let rawHtml = '<div style="font-weight:600;margin-bottom:6px">Raw Feed-in Intervals (nemTime / spot / perKwh)</div>';
                    rawHtml += '<div style="display:flex;flex-direction:column;gap:6px">';
                    feedList.forEach(it => {
                        const nem = it.nemTime || it.startTime;
                        const spot = (typeof it.spotPerKwh === 'number') ? it.spotPerKwh.toFixed(3) : 'n/a';
                        const per = (typeof it.perKwh === 'number') ? it.perKwh.toFixed(3) : 'n/a';
                        // Format nemTime to DD/MM/YYYY HH:MM when possible
                        let nemFormatted = nem;
                        try {
                            const nd = new Date(nem);
                            if (!isNaN(nd.getTime())) nemFormatted = formatDate(nd, true);
                        } catch(e) {}
                        rawHtml += `<div style="padding:6px;background:rgba(33,38,45,0.6);border-radius:6px">${nemFormatted} ‚Äî spot: <strong style=\"color:${(parseFloat(spot) < 0 ? '#f85149' : '#7ee787')}\">${spot}¬¢</strong> ‚Äî per: <strong>${per}¬¢</strong></div>`;
                    });
                    rawHtml += '</div>';
                    rawDiv.style.display = 'block';
                    rawDiv.innerHTML = rawHtml;
                }
            }
        }

        // Amber
        let amberSites = [];
        
        async function loadAmberSites() {
            const select = document.getElementById('amberSiteId');
            const card = document.getElementById('amberCard');
            select.innerHTML = '<option value="">Loading...</option>';
            
            try {
                const resp = await authenticatedFetch('/api/amber/sites');
                const json = await resp.json();
                
                // Extract sites array from response
                let sites = [];
                if (Array.isArray(json)) {
                    sites = json;
                } else if (json && json.result) {
                    sites = Array.isArray(json.result) ? json.result : [];
                } else if (json && json.sites) {
                    sites = json.sites;
                }
                
                if (sites.length > 0) {
                    amberSites = sites;
                    select.innerHTML = sites.map(s => `<option value="${s.id}">${s.nmi} (${s.network})</option>`).join('');
                    card.innerHTML = `<div style="color:#7ee787">‚úì ${sites.length} site(s) found</div>`;
                    // Auto-fetch current prices
                    setTimeout(getAmberCurrent, 500);
                } else {
                    select.innerHTML = '<option value="">No sites</option>';
                    card.innerHTML = `<div style="color:#d29922">No sites found</div>`;
                }
            } catch (e) {
                console.error('[Amber] Error loading sites:', e);
                select.innerHTML = '<option value="">Error</option>';
                card.innerHTML = `<div style="color:#f85149">Error: ${e.message}</div>`;
            }
        }

        async function getAmberCurrent() {
            const siteId = document.getElementById('amberSiteId').value;
            if (!siteId) { document.getElementById('amberCard').innerHTML = '<div style="color:#d29922">Select a site</div>'; return; }
            
            const card = document.getElementById('amberCard');
            card.innerHTML = '<div style="color:#8b949e">Loading prices...</div>';
            
            try {
                const next = Number(document.getElementById('amberNext')?.value) || 12;
                const resp = await authenticatedFetch(`/api/amber/prices/current?siteId=${siteId}&next=${next}`);
                const data = await resp.json();
                renderAmberCard(data);
                // Also set last-updated for amber (history query counts as an update)
                setLastUpdated('amber');
                // mark last updated for amber prices
                setLastUpdated('amber');
                
                document.getElementById('result').textContent = JSON.stringify(data, null, 2);
                document.getElementById('status-bar').style.display = 'flex';
                document.getElementById('status-bar').querySelector('.endpoint').textContent = `Amber Prices`;
            } catch (e) {
                card.innerHTML = `<div style="color:#f85149">Error: ${e.message}</div>`;
            }
        }

        // Open the Amber history modal
        function openAmberHistoryModal() {
            const today = new Date();
            const yesterday = new Date(today.getTime() - 24*60*60*1000);
            const elStart = document.getElementById('amberHistoryStart');
            const elEnd = document.getElementById('amberHistoryEnd');
            if (elStart) elStart.value = yesterday.toISOString().slice(0,10);
            if (elEnd) elEnd.value = today.toISOString().slice(0,10);
            document.getElementById('amberHistoryModal').classList.add('show');
        }
        function closeAmberHistoryModal() { document.getElementById('amberHistoryModal').classList.remove('show'); }
        
        // Dump full Amber response to debug panel
        function dumpAmberRaw() {
            const resp = window.lastAmberResponse || [];
            const json = JSON.stringify(resp, null, 2);
            const debugEl = document.getElementById('result');
            if (debugEl) {
                debugEl.textContent = json;
                document.getElementById('status-bar').style.display = 'flex';
                document.getElementById('status-bar').querySelector('.endpoint').textContent = 'Amber Raw Response';
            } else {
                alert('Debug panel not available. Response has ' + resp.length + ' items');
            }
        }
        
        // Export Amber data as CSV or JSON
        function exportAmberData(format) {
            const resp = window.lastAmberResponse || [];
            if (!resp.length) { alert('No data to export'); return; }
            let content, filename, mime;
            if (format === 'csv') {
                const headers = ['type','date','startTime','perKwh','spotPerKwh','renewables','spikeStatus','descriptor','channelType','period'];
                const rows = resp.map(r => [
                    r.type, r.date, r.startTime, r.perKwh, r.spotPerKwh, r.renewables, r.spikeStatus, r.descriptor, r.channelType, r.tariffInformation?.period || ''
                ].map(v => typeof v === 'string' && v.includes(',') ? `"${v}"` : v).join(','));
                content = [headers.join(','), ...rows].join('\n');
                filename = 'amber_' + new Date().toISOString().slice(0,10) + '.csv';
                mime = 'text/csv';
            } else {
                content = JSON.stringify(resp, null, 2);
                filename = 'amber_' + new Date().toISOString().slice(0,19).replace(/[-T:]/g, '') + '.json';
                mime = 'application/json';
            }
            const blob = new Blob([content], {type: mime});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function getAmberRange(startDate, endDate) {
            const siteId = document.getElementById('amberSiteId').value;
            if (!siteId) return;

            const card = document.getElementById('amberCard');
            card.innerHTML = '<div style="color:#8b949e">Loading history...</div>';

            try {
                let s = startDate, e = endDate;
                if (!s || !e) {
                    const today = new Date();
                    const yesterday = new Date(today.getTime() - 24*60*60*1000);
                    s = yesterday.toISOString().slice(0,10);
                    e = today.toISOString().slice(0,10);
                }
                const resp = await authenticatedFetch(`/api/amber/prices?siteId=${siteId}&startDate=${s}&endDate=${e}`);
                const data = await resp.json();
                renderAmberCard(data);
                document.getElementById('result').textContent = JSON.stringify(data, null, 2);
            } catch (e) {
                card.innerHTML = `<div style="color:#f85149">Error: ${e.message}</div>`;
            }
        }

        function toggleAmberMore() {
            const btn = document.getElementById('amberShowMore');
            if (!btn) return;
            const isShowingAll = btn.dataset.showAll === '1';
            // Toggle state and request appropriate number of intervals
            if (isShowingAll) {
                btn.dataset.showAll = '0';
                // restore to default smaller fetch
                const nextEl = document.getElementById('amberNext');
                if (nextEl) nextEl.value = '288';
            } else {
                btn.dataset.showAll = '1';
                // request a larger window to see more intervals
                const nextEl = document.getElementById('amberNext');
                if (nextEl) nextEl.value = '500';
            }
            // Fetch fresh data so count/limits are accurate
            getAmberCurrent();
        }

        function renderAmberCard(data) {
            const card = document.getElementById('amberCard');
            const intervals = Array.isArray(data) ? data : [];
            if (!intervals.length) { card.innerHTML = '<div style="color:#d29922">No data</div>'; return; }
            window.lastAmberResponse = intervals; // Store for raw dump and export

            const general = intervals.filter(i => i.channelType === 'general');
            const feedIn = intervals.filter(i => i.channelType === 'feedIn');
            const currentGen = general.find(i => i.type === 'CurrentInterval');
            const currentFeed = feedIn.find(i => i.type === 'CurrentInterval');
            const forecasts = general.filter(i => i.type === 'ForecastInterval');
            const feedForecasts = feedIn.filter(i => i.type === 'ForecastInterval');

            // Detect spikes in forecasts
            const spikeForecasts = forecasts.filter(i => i.spikeStatus && i.spikeStatus !== 'none');
            const hasSpikes = spikeForecasts.length > 0;
            
            // How many forecasts to show (use button dataset for show-all state)
            const showAllBtn = document.getElementById('amberShowMore');
            const showAll = showAllBtn?.dataset?.showAll === '1';
            // If show-all is enabled, display everything returned; otherwise show 12
            const forecastLimit = showAll ? forecasts.length : Math.min(forecasts.length, 12);

            // Find price extremes in DISPLAYED forecasts only (to align with tiles)
            const displayForecasts = forecasts.slice(0, forecastLimit);
            const displayFeedForecasts = feedForecasts.slice(0, forecastLimit);
            
            const maxBuyPrice = displayForecasts.length ? Math.max(...displayForecasts.map(i => i.perKwh)) : 0;
            const minBuyPrice = displayForecasts.length ? Math.min(...displayForecasts.map(i => i.perKwh)) : 0;
            // Compute feed-in display values using the same transform as the feed-in tiles
            // (displayVal = -Math.round(perKwh)) so summary matches tiles exactly
            const feedDisplayValues = displayFeedForecasts.length ? displayFeedForecasts.map(it => {
                try {
                    if (window.sharedUtils && typeof window.sharedUtils.feedDisplayValue === 'function') {
                        return window.sharedUtils.feedDisplayValue(it.perKwh);
                    }
                } catch (e) {
                    // fall through to inline transform
                }
                return -Math.round(it.perKwh);
            }) : [];
            const minFeedSpot = feedDisplayValues.length ? Math.min(...feedDisplayValues) : 0;
            const maxFeedSpot = feedDisplayValues.length ? Math.max(...feedDisplayValues) : 0;

            let html = '';

            // Compact info row: forecast count and time range
            try {
                const returned = forecasts.length;
                const lastInterval = forecasts.length ? new Date(forecasts[forecasts.length-1].startTime).toLocaleString('en-AU', {hour:'2-digit',minute:'2-digit', day:'2-digit', month:'2-digit', timeZone:'Australia/Sydney'}) : '‚Äî';
                html += `<div style="font-size:11px;color:#8b949e;margin-bottom:8px">
                    <strong>${returned}</strong> forecast intervals available ‚Äî until <strong>${lastInterval}</strong>
                </div>`;
                // Update the external show-all button label
                const btn = document.getElementById('amberShowMore');
                if (btn) {
                    const isShowingAll = btn.dataset.showAll === '1';
                    btn.textContent = isShowingAll ? 'Show less' : `Show all (${returned})`;
                }
            } catch(e) { /* ignore diagnostics errors */ }

            // Spike Alert Banner (if any forecasted spikes)
            if (hasSpikes) {
                const nextSpike = spikeForecasts[0];
                const spikeTime = new Date(nextSpike.startTime).toLocaleTimeString('en-AU', {hour:'2-digit', minute:'2-digit'});
                const spikePrice = nextSpike.perKwh.toFixed(0);
                html += `<div style="background:linear-gradient(135deg,rgba(248,81,73,0.15),rgba(248,81,73,0.05));border:1px solid rgba(248,81,73,0.4);border-radius:8px;padding:10px;margin-bottom:12px;display:flex;align-items:center;gap:10px">
                    <span style="font-size:24px">‚ö†Ô∏è</span>
                    <div>
                        <div style="font-weight:600;color:#f85149">Price Spike Forecast</div>
                        <div style="font-size:12px;color:#e6edf3">${spikeForecasts.length} spike${spikeForecasts.length > 1 ? 's' : ''} expected ‚Äî next at <strong>${spikeTime}</strong> (${spikePrice}¬¢)</div>
                    </div>
                </div>`;
            }

            // Current Prices Row
            if (currentGen || currentFeed) {
                html += '<div style="display:flex;gap:16px;margin-bottom:12px;flex-wrap:wrap">';
                if (currentGen) {
                    const p = currentGen.perKwh;
                    const spot = currentGen.spotPerKwh;
                    const cls = p > 30 ? 'price-high' : p > 20 ? 'price-mid' : 'price-low';
                    const spike = currentGen.spikeStatus && currentGen.spikeStatus !== 'none';
                    html += `<div style="min-width:100px">
                        <div style="font-size:11px;color:#8b949e">Buy Now ${spike ? '<span style="color:#f85149">‚ö†Ô∏è</span>' : ''}</div>
                        <div class="value ${cls}" style="font-size:28px;font-weight:700">${p.toFixed(1)}¬¢</div>
                    </div>`;
                }
                if (currentFeed) {
                    // Display feed-in price (formatted similar to Amber app)
                    // Amber shows the inverse of perKwh: positive perKwh (you owe) shows negative, negative perKwh (you earn) shows positive
                    const displayVal = -Math.round(currentFeed.perKwh);
                    function feedClassFromVal(v) {
                        // v is display value in cents (may be negative when you earn money)
                        if (v < -5) return 'price-high'; // red
                        if (v >= -5 && v < 0) return 'price-mid'; // amber (includes -5 to -0.01)
                        if (v >= 0 && v < 6) return 'price-neutral'; // grey (only for 0 to 5.99)
                        if (v >= 6 && v <= 15) return 'price-low'; // light green
                        if (v > 15) return 'price-darkgreen'; // dark green
                        return 'price-neutral';
                    }
                    const getCls = feedClassFromVal(displayVal);
                    html += `<div style="min-width:100px">
                        <div style="font-size:11px;color:#8b949e">Feed-In Price</div>
                        <div class="value ${getCls}" style="font-size:28px;font-weight:700">${displayVal}¬¢</div>
                    </div>`;
                }
                if (currentGen && currentGen.renewables !== undefined) {
                    const renew = currentGen.renewables;
                    // Map renewable descriptor to emoji and color
                    const renewDesc = currentGen.descriptor || '';
                    const renewEmoji = { best: 'üå±', great: 'üåø', ok: '‚òÅÔ∏è', notGreat: 'üè≠', worst: 'üí®' }[renewDesc] || '';
                    const renewColor = renew > 60 ? '#7ee787' : renew > 40 ? '#ffd43b' : '#f85149';
                    html += `<div style="min-width:100px">
                        <div style="font-size:11px;color:#8b949e">Renewables ${renewEmoji}</div>
                        <div class="value" style="font-size:28px;font-weight:700;color:${renewColor}">${renew.toFixed(0)}%</div>
                    </div>`;
                }
                html += '</div>';
            }

            // Price Range Summary with consistent coloring logic
            if (forecasts.length > 1) {
                // Buy price coloring (low=cheap, high=expensive)
                const minBuyCls = minBuyPrice > 30 ? 'price-high' : minBuyPrice > 20 ? 'price-mid' : 'price-low';
                const maxBuyCls = maxBuyPrice > 30 ? 'price-high' : maxBuyPrice > 20 ? 'price-mid' : 'price-low';
                
                // Feed-in coloring (high=you earn money, low=you pay)
                function feedClassFromVal(v) {
                    if (v < -5) return 'price-high';
                    if (v >= -5 && v < 0) return 'price-mid';
                    if (v >= 0 && v < 6) return 'price-neutral';
                    if (v >= 6 && v <= 15) return 'price-low';
                    if (v > 15) return 'price-darkgreen';
                    return 'price-neutral';
                }
                const minFeedCls = feedClassFromVal(minFeedSpot);
                const maxFeedCls = feedClassFromVal(maxFeedSpot);
                
                html += `<div style="display:flex;gap:12px;margin-bottom:12px;padding:8px;background:rgba(33,38,45,0.6);border-radius:6px;font-size:11px">
                    <div><span style="color:#8b949e">Forecast range:</span> <span class="${minBuyCls}" style="font-weight:600">${minBuyPrice.toFixed(0)}¬¢</span> ‚Äî <span class="${maxBuyCls}" style="font-weight:600">${maxBuyPrice.toFixed(0)}¬¢</span></div>
                    ${feedForecasts.length ? `<div><span style="color:#8b949e">Feed-in range:</span> <span class="${minFeedCls}" style="font-weight:600">${minFeedSpot}¬¢</span> ‚Äî <span class="${maxFeedCls}" style="font-weight:600">${maxFeedSpot}¬¢</span></div>` : ''}
                </div>`;
            }

            // Buy price forecasts with advanced pricing and tariff info
            if (displayForecasts.length) {
                html += '<div style="font-size:11px;color:#8b949e;margin-bottom:6px;margin-top:8px;font-weight:600">üìà Buy Price Forecast</div>';
                html += '<div style="display:flex;gap:4px;flex-wrap:wrap">';
                displayForecasts.forEach(it => {
                    const startDate = new Date(it.startTime);
                    const time = startDate.toLocaleTimeString('en-AU', {hour:'numeric', minute:'2-digit', hour12:false, timeZone:'Australia/Sydney'});
                    const p = it.perKwh;
                    const cls = p > 30 ? 'price-high' : p > 20 ? 'price-mid' : 'price-low';
                    const spike = it.spikeStatus && it.spikeStatus !== 'none';
                    const ap = it.advancedPrice;
                    const bandInfo = ap ? `Low: ${ap.low.toFixed(0)}¬¢ | Pred: ${ap.predicted.toFixed(0)}¬¢ | High: ${ap.high.toFixed(0)}¬¢` : '';
                    const tooltip = spike ? `SPIKE: ${it.spikeStatus}` : bandInfo;
                    html += `<div class="stat-item" style="min-width:52px;padding:5px;${spike ? 'border:1px solid rgba(248,81,73,0.5);background:rgba(248,81,73,0.1)' : ''}" title="${tooltip}">
                        <div style="display:flex;align-items:center;justify-content:center;gap:2px">
                            <span class="value ${cls}" style="font-size:12px;font-weight:600">${p.toFixed(0)}¬¢</span>
                            ${spike ? '<span style="font-size:10px">‚ö†Ô∏è</span>' : ''}
                        </div>
                        <div class="label" style="font-size:9px;color:#8b949e">${time}</div>
                    </div>`;
                });
                html += '</div>';
            }

            // Feed-in price forecasts - Amber app shows spotPerKwh rounded to whole cents
            if (displayFeedForecasts.length) {
                html += '<div style="font-size:11px;color:#8b949e;margin-bottom:6px;margin-top:12px;font-weight:600">üìâ Feed-in Spot Forecast</div>';
                html += '<div style="display:flex;gap:4px;flex-wrap:wrap">';
                displayFeedForecasts.forEach(it => {
                    // Use startTime converted to AEST - Amber shows interval START time
                    const startDate = new Date(it.startTime);
                    const time = startDate.toLocaleTimeString('en-AU', {hour:'numeric', minute:'2-digit', hour12:false, timeZone:'Australia/Sydney'});
                    // Display -Round(perKwh) to match Amber app (negative perKwh = you earn, shown positive)
                    const displayVal = -Math.round(it.perKwh);
                    function feedClassFromVal(v) {
                        if (v < -5) return 'price-high';
                        if (v >= -5 && v < 0) return 'price-mid';
                        if (v >= 0 && v < 6) return 'price-neutral';
                        if (v >= 6 && v <= 15) return 'price-low';
                        if (v > 15) return 'price-darkgreen';
                        return 'price-neutral';
                    }
                    const getCls = feedClassFromVal(displayVal);
                    const isVeryNegative = displayVal < -2;
                    const feedHighlightCls = displayVal > 50 ? 'feedin-highlight' : '';
                    html += `<div class="stat-item ${feedHighlightCls}" style="min-width:52px;padding:6px;${isVeryNegative ? 'border:1px solid rgba(248,81,73,0.5);background:rgba(248,81,73,0.1)' : ''}">
                                <div style="display:flex;align-items:center;justify-content:center;gap:2px">
                                    <span class="value ${getCls}" style="font-size:13px;font-weight:700">${displayVal}¬¢</span>
                        </div>
                        <div class="label" style="font-size:9px">${time}</div>
                    </div>`;
                });
                html += '</div>';
            }

            // Add chart canvas to HTML before rendering
            html += '<div style="margin-top:16px;position:relative;height:200px;width:100%"><canvas id="amberPriceChart" style="width:100%;height:200px"></canvas></div>';
            card.innerHTML = html;

            // Schedule chart rendering after DOM is ready
            setTimeout(() => renderAmberChart(displayForecasts, displayFeedForecasts), 100);
        }

        async function renderAmberChart(displayForecasts, displayFeedForecasts) {
            try {
                // Load Chart.js if not present
                if (typeof Chart === 'undefined') {
                    await new Promise((resolve, reject) => {
                        const s = document.createElement('script');
                        s.src = 'https://cdn.jsdelivr.net/npm/chart.js';
                        s.onload = resolve;
                        s.onerror = reject;
                        document.head.appendChild(s);
                    });
                }

                const canvas = document.getElementById('amberPriceChart');
                if (!canvas || typeof Chart === 'undefined') return;

                // Build labels from buy or feed-in forecasts
                const forecasts = displayForecasts.length ? displayForecasts : displayFeedForecasts;
                const labels = forecasts.map(it => {
                    try {
                        const d = new Date(it.startTime);
                        return d.toLocaleTimeString('en-AU', {hour:'2-digit', minute:'2-digit', hour12:false, timeZone:'Australia/Sydney'});
                    } catch(e) { return ''; }
                });

                // Build datasets
                const buySeries = displayForecasts.map(it => it ? Number(it.perKwh) : null);
                const feedSeries = displayFeedForecasts.map(it => it ? -Math.round(it.perKwh) : null);

                // Destroy old chart if exists
                if (window.amberChartInst) {
                    try { window.amberChartInst.destroy(); } catch(e) {}
                }

                const ctx = canvas.getContext('2d');
                window.amberChartInst = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [
                            {
                                label: 'Buy Price (¬¢/kWh)',
                                data: buySeries,
                                borderColor: '#ffd43b',
                                backgroundColor: 'rgba(255,212,59,0.1)',
                                borderWidth: 2,
                                tension: 0.3,
                                pointRadius: 4,
                                pointBackgroundColor: '#ffd43b',
                                pointBorderColor: '#0d1117',
                                pointBorderWidth: 1,
                                fill: true
                            },
                            {
                                label: 'Feed-in Spot (¬¢)',
                                data: feedSeries,
                                borderColor: '#7ee787',
                                backgroundColor: 'rgba(126,231,135,0.1)',
                                borderWidth: 2,
                                tension: 0.3,
                                pointRadius: 4,
                                pointBackgroundColor: '#7ee787',
                                pointBorderColor: '#0d1117',
                                pointBorderWidth: 1,
                                fill: true
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        plugins: {
                            legend: {
                                display: true,
                                labels: { color: '#c9d1d9', usePointStyle: true, padding: 15, font: { size: 12 } }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(13,17,23,0.95)',
                                titleColor: '#c9d1d9',
                                bodyColor: '#8b949e',
                                borderColor: '#30363d',
                                borderWidth: 1,
                                padding: 10,
                                cornerRadius: 6,
                                displayColors: true
                            }
                        },
                        scales: {
                            x: {
                                grid: { color: 'rgba(255,255,255,0.02)', drawBorder: false },
                                ticks: { color: '#8b949e', font: { size: 11 } }
                            },
                            y: {
                                beginAtZero: true,
                                grid: { color: 'rgba(255,255,255,0.05)', drawBorder: false },
                                ticks: { color: '#8b949e', font: { size: 11 }, callback: val => val + '¬¢' }
                            }
                        }
                    }
                });
            } catch (err) {
                console.error('Chart render failed:', err);
            }
        }

        // Scheduler segments
        let currentSchedulerGroups = [];
        
        async function clearAllSchedulerSegments() {
            if (!confirm('‚ö†Ô∏è Clear ALL 10 scheduler time periods?\n\nThis will reset all segments to disabled (00:00-00:00).')) {
                return;
            }
            
            const statusEl = document.getElementById('schedulerStatus');
            statusEl.style.display = 'block';
            statusEl.style.background = '#1f6feb';
            statusEl.textContent = 'üîÑ Clearing all segments...';
            
            try {
                const resp = await authenticatedFetch('/api/scheduler/v1/clear-all', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                const data = await resp.json();
                
                if (data.errno === 0) {
                    statusEl.style.background = '#238636';
                    let msg = '‚úÖ All segments cleared successfully!';
                    // Show flag result if available
                    if (data.flagResult) {
                        msg += data.flagResult.errno === 0 ? ' (flag disabled)' : ' (flag warning)';
                    }
                    statusEl.textContent = msg;
                    // Show full response including verify info so user can see device state
                    try { document.getElementById('result').className = 'info'; document.getElementById('result').textContent = JSON.stringify(data, null, 2); } catch(e) {}
                    setTimeout(() => loadSchedulerSegments(), CONFIG.ui.schedulerReloadDelayMs);
                } else {
                    statusEl.style.background = '#da3633';
                    statusEl.textContent = `‚ùå Failed: ${data.msg || 'Unknown error'}`;
                    // Show error response for debugging
                    try { document.getElementById('result').className = 'error'; document.getElementById('result').textContent = JSON.stringify(data, null, 2); } catch(e) {}
                }
            } catch (err) {
                statusEl.style.background = '#da3633';
                statusEl.textContent = `‚ùå Error: ${err.message}`;
            }
            
            setTimeout(() => { statusEl.style.display = 'none'; }, CONFIG.ui.statusFadeMs);
        }
        
        async function loadSchedulerSegments() {
            const container = document.getElementById('schedulerSegments');
            container.innerHTML = '<div style="color:#8b949e;font-size:12px;padding:20px;text-align:center">Loading...</div>';
            
            try {
                const resp = await authenticatedFetch('/api/scheduler/v1/get');
                const data = await resp.json();
                
                if (data.errno !== 0 || !data.result) {
                    container.innerHTML = `<div style="color:#f85149;font-size:12px;padding:20px">Error: ${data.msg || 'Failed to load'}</div>`;
                    return;
                }
                
                currentSchedulerGroups = data.result.groups || [];
                const globalEnable = data.result.enable;
                
                if (currentSchedulerGroups.length === 0) {
                    container.innerHTML = '<div style="color:#8b949e;font-size:12px;padding:20px;text-align:center">No segments configured</div>';
                    return;
                }
                
                const modeColors = {
                    'SelfUse': '#7ee787',
                    'ForceCharge': '#58a6ff', 
                    'ForceDischarge': '#f0883e',
                    'Feedin': '#d29922',
                    'Backup': '#a371f7'
                };
                
                let html = `<div style="grid-column:1/-1;margin-bottom:8px;padding:8px;background:${globalEnable ? '#238636' : '#30363d'};border-radius:6px;text-align:center;font-size:12px">
                    Scheduler: <strong>${globalEnable ? '‚úÖ ENABLED' : '‚ùå DISABLED'}</strong>
                </div>`;
                
                currentSchedulerGroups.forEach((seg, i) => {
                    const color = modeColors[seg.workMode] || '#8b949e';
                    const startTime = `${String(seg.startHour).padStart(2,'0')}:${String(seg.startMinute).padStart(2,'0')}`;
                    const endTime = `${String(seg.endHour).padStart(2,'0')}:${String(seg.endMinute).padStart(2,'0')}`;
                    const isEnabled = seg.enable === 1;
                    
                    html += `<div style="background:#21262d;border:1px solid ${isEnabled ? color : '#30363d'};border-radius:8px;padding:10px;opacity:${isEnabled ? 1 : 0.6}">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                            <span style="font-weight:600;color:${color}">Segment ${i+1}</span>
                            <span style="font-size:11px;padding:2px 8px;border-radius:4px;background:${isEnabled ? color : '#30363d'};color:#0d1117">${isEnabled ? 'ON' : 'OFF'}</span>
                        </div>
                        <div style="font-size:20px;font-weight:600;color:#c9d1d9;margin-bottom:4px">${startTime} ‚Üí ${endTime}</div>
                        <div style="font-size:13px;color:${color};margin-bottom:8px">${seg.workMode}</div>
                        <div style="font-size:11px;color:#8b949e;display:grid;grid-template-columns:1fr 1fr;gap:4px">
                            <span>MinSoC: ${seg.minSocOnGrid ?? seg.extraParam?.minSocOnGrid ?? '-'}%</span>
                            <span>FD SoC: ${seg.fdSoc ?? seg.extraParam?.fdSoc ?? '-'}%</span>
                            <span>FD Power: ${seg.fdPwr ?? seg.extraParam?.fdPwr ?? 0}W</span>
                            <span>Max SoC: ${seg.maxSoc ?? seg.extraParam?.maxSoc ?? '-'}%</span>
                        </div>
                        <div style="display:flex;gap:6px;margin-top:8px">
                            <button class="btn" onclick="editSegment(${i})" style="flex:1;font-size:11px;padding:4px">‚úèÔ∏è Edit</button>
                            <button class="btn" onclick="deleteSegment(${i})" style="flex:1;font-size:11px;padding:4px;background:#da3633">üóëÔ∏è Clear</button>
                        </div>
                    </div>`;
                });
                
                container.innerHTML = html;
                
                // Also show in result panel
                document.getElementById('result').className = 'success';
                document.getElementById('result').textContent = JSON.stringify(data, null, 2);
            } catch (error) {
                container.innerHTML = `<div style="color:#f85149;font-size:12px;padding:20px">Error: ${error.message}</div>`;
            }
        }
        
        function editSegment(index) {
            const seg = currentSchedulerGroups[index];
            if (!seg) return;
            
            const form = document.getElementById('form-scheduler-segment');
            form.segmentIndex.value = index;
            form.enable.value = seg.enable;
            form.workMode.value = seg.workMode;
            form.startTime.value = `${String(seg.startHour).padStart(2,'0')}:${String(seg.startMinute).padStart(2,'0')}`;
            form.endTime.value = `${String(seg.endHour).padStart(2,'0')}:${String(seg.endMinute).padStart(2,'0')}`;
            form.minSocOnGrid.value = seg.minSocOnGrid ?? seg.extraParam?.minSocOnGrid ?? 10;
            form.fdSoc.value = seg.fdSoc ?? seg.extraParam?.fdSoc ?? 10;
            form.fdPwr.value = seg.fdPwr ?? seg.extraParam?.fdPwr ?? 0;
            form.maxSoc.value = seg.maxSoc ?? seg.extraParam?.maxSoc ?? 100;
            
            // Scroll to form
            form.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        async function deleteSegment(index) {
            if (!confirm(`Clear segment ${index + 1}? This will disable it and reset times to 00:00.`)) return;
            
            const statusDiv = document.getElementById('schedulerStatus');
            statusDiv.style.display = 'block';
            statusDiv.style.background = '#21262d';
            statusDiv.style.color = '#58a6ff';
            statusDiv.innerHTML = '<div style="display:flex;align-items:center;gap:8px"><div class="spinner"></div><span>Clearing segment...</span></div>';
            
            // First load current segments if not loaded
            if (currentSchedulerGroups.length === 0) {
                try {
                    const resp = await authenticatedFetch('/api/scheduler/v1/get');
                    const data = await resp.json();
                    if (data.errno === 0 && data.result?.groups) {
                        currentSchedulerGroups = data.result.groups;
                    }
                } catch (e) {
                    statusDiv.style.background = '#da3633';
                    statusDiv.style.color = '#fff';
                    statusDiv.textContent = '‚ùå Failed to load current segments';
                    return;
                }
            }
            
            // Reset the segment to disabled with 00:00 times (V1 flat structure)
            currentSchedulerGroups[index] = {
                enable: 0,
                workMode: 'SelfUse',
                startHour: 0,
                startMinute: 0,
                endHour: 0,
                endMinute: 0,
                minSocOnGrid: 10,
                fdSoc: 10,
                fdPwr: 0,
                maxSoc: 100
            };
            
            // Send all segments to API
            const sn = document.getElementById('deviceSn').value || '';
            const body = { groups: currentSchedulerGroups };
            if (sn) body.sn = sn;
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
                
                const resp = await authenticatedFetch('/api/scheduler/v1/set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                const data = await resp.json();
                
                if (data.errno === 0) {
                    statusDiv.style.background = '#238636';
                    statusDiv.style.color = '#fff';
                    let msg = `‚úÖ Segment ${index + 1} cleared successfully`;
                    if (data.flagResult) {
                        msg += data.flagResult.errno === 0 ? ' (flag updated)' : '';
                    }
                    statusDiv.textContent = msg;
                    // Show full response including verify info so user can see device state
                    try { document.getElementById('result').className = 'info'; document.getElementById('result').textContent = JSON.stringify(data, null, 2); } catch(e) {}
                    // Reload segments to reflect changes
                    setTimeout(() => loadSchedulerSegments(), CONFIG.ui.schedulerReloadDelayMs);
                } else {
                    statusDiv.style.background = '#da3633';
                    statusDiv.style.color = '#fff';
                    statusDiv.textContent = `‚ùå Failed to clear segment: ${data.msg || 'Unknown error'}`;
                }
            } catch (error) {
                statusDiv.style.background = '#da3633';
                statusDiv.style.color = '#fff';
                if (error.name === 'AbortError') {
                    statusDiv.innerHTML = '<div style="display:flex;align-items:center;gap:8px"><div class="spinner"></div><span>‚ö†Ô∏è Request taking longer than expected, still processing...</span></div>';
                    // Check for success after timeout by reloading
                    setTimeout(() => {
                        loadSchedulerSegments();
                        statusDiv.style.background = '#f0883e';
                        statusDiv.style.color = '#0d1117';
                        statusDiv.textContent = '‚ö†Ô∏è Operation may have succeeded - segments reloaded';
                        setTimeout(() => { statusDiv.style.display = 'none'; }, CONFIG.ui.statusFadeMs);
                    }, CONFIG.ui.clearAllDelayMs);
                    return;
                }
                statusDiv.textContent = `‚ùå Error: ${error.message}`;
            }
            
            // Hide status after configured delay
            setTimeout(() => { statusDiv.style.display = 'none'; }, CONFIG.ui.statusFadeMs);
        }
        
        async function submitSchedulerSegment(evt) {
            evt.preventDefault();
            const form = evt.target;
            
            const statusDiv = document.getElementById('schedulerStatus');
            statusDiv.style.display = 'block';
            statusDiv.style.background = '#21262d';
            statusDiv.style.color = '#58a6ff';
            statusDiv.innerHTML = '<div style="display:flex;align-items:center;gap:8px"><div class="spinner"></div><span>Saving segment...</span></div>';
            
            // First load current segments if not loaded
            if (currentSchedulerGroups.length === 0) {
                try {
                    const resp = await authenticatedFetch('/api/scheduler/v1/get');
                    const data = await resp.json();
                    if (data.errno === 0 && data.result?.groups) {
                        currentSchedulerGroups = data.result.groups;
                    }
                } catch (e) {
                    statusDiv.style.background = '#da3633';
                    statusDiv.style.color = '#fff';
                    statusDiv.textContent = '‚ùå Failed to load current segments';
                    setTimeout(() => { statusDiv.style.display = 'none'; }, CONFIG.ui.statusFadeMs);
                    return;
                }
            }
            
            const index = parseInt(form.segmentIndex.value);
            const [startHour, startMinute] = form.startTime.value.split(':').map(Number);
            const [endHour, endMinute] = form.endTime.value.split(':').map(Number);
            
            // Validate: fdSoc must be >= minSocOnGrid
            const minSocOnGrid = parseInt(form.minSocOnGrid.value) || 10;
            let fdSoc = parseInt(form.fdSoc.value) || 10;
            if (fdSoc < minSocOnGrid) {
                fdSoc = minSocOnGrid;
                form.fdSoc.value = fdSoc;
                statusDiv.style.background = '#f0883e';
                statusDiv.style.color = '#0d1117';
                statusDiv.textContent = `‚ö†Ô∏è FD SoC must be >= Min SoC Grid (${minSocOnGrid}%). Auto-corrected to ${fdSoc}%.`;
                await new Promise(resolve => setTimeout(resolve, 2000));
                statusDiv.style.background = '#21262d';
                statusDiv.style.color = '#58a6ff';
                statusDiv.innerHTML = '<div style="display:flex;align-items:center;gap:8px"><div class="spinner"></div><span>Saving segment...</span></div>';
            }
            
            // Update the segment
            if (!currentSchedulerGroups[index]) {
                currentSchedulerGroups[index] = {};
            }
            
            // V1 uses flat structure (no extraParam nesting)
            currentSchedulerGroups[index] = {
                enable: parseInt(form.enable.value),
                workMode: form.workMode.value,
                startHour,
                startMinute,
                endHour,
                endMinute,
                minSocOnGrid,
                fdSoc,
                fdPwr: parseInt(form.fdPwr.value) || 0,
                maxSoc: parseInt(form.maxSoc.value) || 100
            };
            
            // Send all segments to API (V1 endpoint)
            const sn = document.getElementById('deviceSn').value || '';
            const body = { groups: currentSchedulerGroups };
            if (sn) body.sn = sn;
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), CONFIG.timeout.schedulerMs);
                
                const resp = await authenticatedFetch('/api/scheduler/v1/set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                const data = await resp.json();
                
                if (data.errno === 0) {
                    statusDiv.style.background = '#238636';
                    statusDiv.style.color = '#fff';
                    let msg = `‚úÖ Segment ${index + 1} saved successfully`;
                    // Show flag status
                    if (data.flagResult) {
                        msg += data.flagResult.errno === 0 ? ' (flag set)' : ' (flag warning)';
                    }
                    statusDiv.textContent = msg;
                    // Show full response including verify info so user can see device state
                    try { document.getElementById('result').className = 'info'; document.getElementById('result').textContent = JSON.stringify(data, null, 2); } catch(e) {}
                    // Reload segments to reflect changes (this now reads from device, not Firestore)
                    setTimeout(() => loadSchedulerSegments(), CONFIG.ui.schedulerReloadDelayMs);
                } else {
                    statusDiv.style.background = '#da3633';
                    statusDiv.style.color = '#fff';
                    statusDiv.textContent = `‚ùå Failed to save segment: ${data.msg || 'Unknown error'}`;
                    // Show error response for debugging
                    try { document.getElementById('result').className = 'error'; document.getElementById('result').textContent = JSON.stringify(data, null, 2); } catch(e) {}
                }
            } catch (error) {
                statusDiv.style.background = '#da3633';
                statusDiv.style.color = '#fff';
                if (error.name === 'AbortError') {
                    statusDiv.innerHTML = '<div style="display:flex;align-items:center;gap:8px"><div class="spinner"></div><span>‚ö†Ô∏è Request taking longer than expected, still processing...</span></div>';
                    // Check for success after timeout by reloading
                    setTimeout(() => {
                        loadSchedulerSegments();
                        statusDiv.style.background = '#f0883e';
                        statusDiv.style.color = '#0d1117';
                        statusDiv.textContent = '‚ö†Ô∏è Operation may have succeeded - segments reloaded';
                        setTimeout(() => { statusDiv.style.display = 'none'; }, CONFIG.ui.statusFadeMs);
                    }, CONFIG.ui.clearAllDelayMs);
                    return;
                }
                statusDiv.textContent = `‚ùå Error: ${error.message}`;
            }
            
            // Hide status after configured delay
            setTimeout(() => { statusDiv.style.display = 'none'; }, CONFIG.ui.statusFadeMs);
        }

        // Forms
        async function submitSetForm(evt, endpoint) {
            evt.preventDefault();
            const form = evt.target;
            const body = buildBodyFromForm(form);
            const sn = document.getElementById('deviceSn').value;
            if (sn && !body.sn) body.sn = sn;

            if (body.raw) {
                try { Object.assign(body, JSON.parse(body.raw)); } catch(e) {}
                delete body.raw;
            }
            if (body.readerInfo && typeof body.readerInfo === 'string') {
                try { body.readerInfo = JSON.parse(body.readerInfo); } catch(e) {}
            }

            callAPIPost(endpoint, form.querySelector('.form-title')?.textContent || endpoint, body);
        }

        function buildBodyFromForm(form) {
            const obj = {};
            Array.from(form.elements).filter(el => el.name && !el.disabled).forEach(el => {
                if (el.type === 'submit' || el.type === 'button') return;
                let val = el.type === 'checkbox' ? el.checked : el.value;
                if (val === '') return;
                if (el.type === 'number') { const n = Number(val); if (!isNaN(n)) val = n; }
                
                if (el.name.includes('.')) {
                    const parts = el.name.split('.');
                    let cur = obj;
                    parts.forEach((p, i) => {
                        if (i === parts.length - 1) cur[p] = val;
                        else { cur[p] = cur[p] || {}; cur = cur[p]; }
                    });
                } else {
                    obj[el.name] = val;
                }
            });
            return obj;
        }

        function fillExample(formId) {
            const form = document.getElementById(formId);
            if (!form) return;
            if (formId === 'form-soc') {
                form.querySelector('[name=minSoc]').value = 20;
                form.querySelector('[name=minSocOnGrid]').value = 10;
            } else if (formId === 'form-forceCharge') {
                form.querySelector('[name=enable1]').checked = true;
                form.querySelector('[name="startTime1.hour"]').value = 6;
                form.querySelector('[name="startTime1.minute"]').value = 0;
                form.querySelector('[name="endTime1.hour"]').value = 8;
                form.querySelector('[name="endTime1.minute"]').value = 30;
            } else if (formId === 'form-peakShaving') {
                form.querySelector('[name=importLimit]').value = 5;
                form.querySelector('[name=soc]').value = 10;
            } else if (formId === 'form-time') {
                syncLocalTime(formId);
            }
        }

        function syncLocalTime(formId) {
            const form = document.getElementById(formId);
            if (!form) return;
            const d = new Date();
            form.querySelector('[name=year]').value = d.getFullYear();
            form.querySelector('[name=month]').value = d.getMonth() + 1;
            form.querySelector('[name=day]').value = d.getDate();
            form.querySelector('[name=hour]').value = d.getHours();
            form.querySelector('[name=minute]').value = d.getMinutes();
        }
        
        function clearResult() {
            document.getElementById('result').textContent = 'Click any button to see the API response here...';
            document.getElementById('result').className = '';
            document.getElementById('status-bar').style.display = 'none';
        }
        
        function copyResult() {
            navigator.clipboard.writeText(document.getElementById('result').textContent).then(() => {
                const btn = document.querySelector('.copy-btn');
                btn.textContent = '‚úì Copied!';
                setTimeout(() => btn.textContent = 'üìã Copy', 2000);
            });
        }
        
        // Resize handle
        const resizeHandle = document.getElementById('resizeHandle');
        const rightPanel = document.getElementById('rightPanel');
        let isResizing = false;
        
        resizeHandle.addEventListener('mousedown', () => {
            isResizing = true;
            document.body.style.cursor = 'ew-resize';
            document.body.style.userSelect = 'none';
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const newWidth = window.innerWidth - e.clientX;
            if (newWidth >= 300 && newWidth <= 800) {
                rightPanel.style.width = newWidth + 'px';
            }
        });
        
        document.addEventListener('mouseup', () => {
            isResizing = false;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        });

        // Clean up timers before unload (helps when navigating away during development)
        window.addEventListener('beforeunload', () => {
            try { if (amberRefreshTimer) clearInterval(amberRefreshTimer); } catch(e){}
            try { if (inverterRefreshTimer) clearInterval(inverterRefreshTimer); } catch(e){}
            try { if (weatherRefreshTimer) clearInterval(weatherRefreshTimer); } catch(e){}
            try { if (lastUpdateTicker) clearInterval(lastUpdateTicker); } catch(e){}
        });

        // ==================== CONFIGURATION ====================
        // Centralized configuration for all timing and thresholds
        const CONFIG = {
            // Data refresh intervals (should match backend cache TTLs)
            refresh: {
                amberPricesMs: 60 * 1000,      // 60 seconds - Amber prices
                inverterMs: 5 * 60 * 1000,     // 5 minutes - Inverter data
                weatherMs: 30 * 60 * 1000      // 30 minutes - Weather data
            },
            
            // Automation timing
            automation: {
                intervalMs: 60 * 1000,         // How often automation cycles run (must match backend)
                countdownUpdateMs: 1000        // How often to update countdown display
            },
            
            // UI timing
            ui: {
                statusFadeMs: 5000,            // How long to show status messages
                schedulerReloadDelayMs: 800,   // Delay before reloading scheduler after changes
                amberRetryDelayMs: 500,        // Delay before retrying Amber API call
                toggleAnimationDelayMs: 100,   // Delay for toggle button position update
                automationLoadDelayMs: 300,    // Delay before loading automation status
                tickerIntervalMs: 1000,        // Update interval for 'time since' labels
                copyButtonResetMs: 2000,       // Time to show 'copied' state on copy button
                clearAllDelayMs: 2000          // Delay in clear all segments
            },
            
            // API timeouts
            timeout: {
                schedulerMs: 30000,            // Timeout for scheduler API calls
                testAutomationMs: 15000        // Timeout for test automation calls
            },
            
            // Display limits
            display: {
                forecastLimit: 48,             // Max forecast intervals to show
                defaultAmberNext: 12           // Default number of Amber forecast intervals
            }
        };
        
        // Legacy alias for backwards compatibility
        const REFRESH = CONFIG.refresh;

        // Timer handles for auto-refresh (kept so we can cancel/replace during dev)
        let amberRefreshTimer = null;
        let inverterRefreshTimer = null;
        let weatherRefreshTimer = null;

        // Map of last update timestamps (ms since epoch)
        const lastUpdated = {
            inverter: null,           // client local ms when we last successfully fetched from API
            inverterCloud: null,      // cloud-recorded timestamp (ms) as returned by API
            amber: null,
            weather: null
        };

        // UI ticker for 'time since' labels
        let lastUpdateTicker = null;

        // Helper to format milliseconds to human-readable string
        function formatMsToReadable(ms) {
            if (!ms || ms <= 0) return '‚Äî';
            const sec = Math.floor(ms / 1000);
            if (sec < 60) return sec + 's';
            const min = Math.floor(sec / 60);
            if (min < 60) return min + ' min';
            const hours = Math.floor(min / 60);
            return hours + 'h ' + (min % 60) + 'm';
        }

        // Update FAQ display values from CONFIG
        function updateFaqValues() {
            try {
                // Automation interval
                const faqInterval = document.getElementById('faqAutomationInterval');
                if (faqInterval) faqInterval.textContent = formatMsToReadable(CONFIG.automation.intervalMs);
                
                // Cache intervals
                const faqAmber = document.getElementById('faqAmberCache');
                if (faqAmber) faqAmber.textContent = formatMsToReadable(CONFIG.refresh.amberPricesMs);
                
                const faqInverter = document.getElementById('faqInverterCache');
                if (faqInverter) faqInverter.textContent = formatMsToReadable(CONFIG.refresh.inverterMs);
                
                const faqWeather = document.getElementById('faqWeatherCache');
                if (faqWeather) faqWeather.textContent = formatMsToReadable(CONFIG.refresh.weatherMs);
                
                // Cooldown
                const faqCooldown = document.getElementById('faqCooldown');
                if (faqCooldown) faqCooldown.textContent = (CONFIG.defaults?.cooldownMinutes || 5) + ' minutes';
                
                // Cancel interval (same as automation interval)
                const faqCancel = document.getElementById('faqCancelInterval');
                if (faqCancel) faqCancel.textContent = formatMsToReadable(CONFIG.automation.intervalMs);
            } catch (e) {
                console.warn('Failed to update FAQ values:', e);
            }
        }

        function formatSince(ts) {
            if (!ts) return '‚Äî';
            const delta = Math.floor((Date.now() - ts) / 1000);
            if (delta <= 2) return 'just now';
            if (delta < 60) return `${delta}s ago`;
            const mins = Math.floor(delta / 60);
            if (mins < 60) return `${mins}m ${delta % 60}s ago`;
            const hours = Math.floor(mins / 60);
            return `${hours}h ${mins % 60}m ago`;
        }

        // Format a date/timestamp to DD/MM/YYYY optionally with time
        function formatDate(ts, withTime = false, withSeconds = false) {
            if (!ts) return '‚Äî';
            const d = (ts instanceof Date) ? ts : new Date(Number(ts) || ts);
            if (isNaN(d.getTime())) return '‚Äî';
            const dd = String(d.getDate()).padStart(2, '0');
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const yyyy = d.getFullYear();
            if (!withTime) return `${dd}/${mm}/${yyyy}`;
            const hh = String(d.getHours()).padStart(2, '0');
            const min = String(d.getMinutes()).padStart(2, '0');
            if (withSeconds) {
                const sec = String(d.getSeconds()).padStart(2, '0');
                return `${dd}/${mm}/${yyyy} ${hh}:${min}:${sec}`;
            }
            return `${dd}/${mm}/${yyyy} ${hh}:${min}`;
        }

        // Parse FoxESS cloud time strings like "2025-11-29 19:01:57 AEDT+1100" into epoch ms.
        function parseFoxESSCloudTime(s) {
            if (!s || typeof s !== 'string') return null;
            // Try to find an ISO-like datetime + offset (e.g., "2025-11-29 19:01:57 AEDT+1100")
            // We'll extract the date/time and the trailing +HHMM or -HHMM offset if present.
            const m = s.match(/(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})(?:.*?([+-]\d{4}))?$/);
            if (!m) return null;
            const base = m[1];
            const offset = m[2];
            // Convert to ISO by replacing space between date and time with 'T'
            let iso = base.replace(' ', 'T');
            if (offset) {
                // convert +1100 -> +11:00
                const off = offset.replace(/([+-]\d{2})(\d{2})/, '$1:$2');
                iso = iso + off;
            } else {
                // No explicit offset; treat as local time
            }
            const d = Date.parse(iso);
            if (isNaN(d)) return null;
            return d;
        }

        function updateLastUpdateDisplays() {
            try {
                const inv = document.getElementById('inverterLastUpdate');
                const amb = document.getElementById('amberLastUpdate');
                const we = document.getElementById('weatherLastUpdate');
                if (inv) {
                    // Show "time since cloud sync" if available, otherwise fallback to fetch time
                    if (lastUpdated.inverterCloud) {
                        inv.textContent = formatSince(lastUpdated.inverterCloud) + ' (cloud)';
                    } else if (lastUpdated.inverter) {
                        inv.textContent = formatSince(lastUpdated.inverter);
                    } else {
                        inv.textContent = '‚Äî';
                    }
                }
                if (amb) amb.textContent = lastUpdated.amber ? formatSince(lastUpdated.amber) : '‚Äî';
                if (we) we.textContent = lastUpdated.weather ? formatSince(lastUpdated.weather) : '‚Äî';

                // Also update the detailed inverter cloud/fetch labels
                try {
                    const cloudEl = document.getElementById('inverterCloudTime');
                    const fetchAgoEl = document.getElementById('inverterFetchAgo');
                    if (cloudEl) cloudEl.textContent = lastUpdated.inverterCloud ? `cloud: ${formatDate(lastUpdated.inverterCloud, true)}` : '‚Äî';
                    if (fetchAgoEl) fetchAgoEl.textContent = lastUpdated.inverter ? formatSince(lastUpdated.inverter) : '‚Äî';
                } catch (e) { /* ignore */ }
            } catch (e) { /* ignore */ }
        }

        function setLastUpdated(key) {
            if (!['inverter','amber','weather'].includes(key)) return;
            lastUpdated[key] = Date.now();
            updateLastUpdateDisplays();
        }

        // -------------------------
        // Automation panel resizer
        // -------------------------
        // Toggle automation panel - standalone function
        window.toggleAutomationPanel = function(forceState) {
            try {
                const panel = document.querySelector('.automation-panel');
                const resizer = document.getElementById('automationResizer');
                const btn = document.getElementById('automationToggleBtn');
                if (!panel) return;
                
                const isCollapsed = panel.classList.contains('collapsed');
                let targetCollapsed = typeof forceState === 'boolean' ? forceState : !isCollapsed;

                    if (targetCollapsed) {
                    panel.classList.add('collapsed');
                    if (resizer) resizer.style.display = 'none';
                    if (btn) {
                        btn.innerHTML = '<span class="automation-toggle-icon">' +
                        '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">' +
                        '<defs><linearGradient id="robotBody" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:#667eea;stop-opacity:1" /><stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" /></linearGradient></defs>' +
                        '<rect x="5" y="8" width="14" height="10" rx="3" fill="url(#robotBody)" stroke="#5567d8" stroke-width="0.5" />' +
                        '<rect x="7" y="4" width="10" height="4" rx="2" fill="#667eea" stroke="#5567d8" stroke-width="0.5" />' +
                        '<circle cx="9.5" cy="11" r="1.3" fill="#fff" />' +
                        '<circle cx="14.5" cy="11" r="1.3" fill="#fff" />' +
                        '<circle cx="9.5" cy="11" r="0.7" fill="#667eea" />' +
                        '<circle cx="14.5" cy="11" r="0.7" fill="#667eea" />' +
                        '<rect x="10" y="15" width="4" height="1.5" rx="0.7" fill="#764ba2" />' +
                        '<circle cx="6" cy="4" r="0.8" fill="#ffd700" />' +
                        '</svg></span><span class="automation-toggle-arrow">‚óÄ</span>';
                        // When collapsed, allow the toggle to receive pointer events (so it can be clicked)
                        try { btn.style.pointerEvents = 'auto'; } catch(e) {}
                    }
                } else {
                    panel.classList.remove('collapsed');
                    if (resizer) resizer.style.display = 'flex';
                    if (btn) {
                        btn.innerHTML = '<span class="automation-toggle-icon">' +
                        '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">' +
                        '<defs><linearGradient id="robotBody" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:#667eea;stop-opacity:1" /><stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" /></linearGradient></defs>' +
                        '<rect x="5" y="8" width="14" height="10" rx="3" fill="url(#robotBody)" stroke="#5567d8" stroke-width="0.5" />' +
                        '<rect x="7" y="4" width="10" height="4" rx="2" fill="#667eea" stroke="#5567d8" stroke-width="0.5" />' +
                        '<circle cx="9.5" cy="11" r="1.3" fill="#fff" />' +
                        '<circle cx="14.5" cy="11" r="1.3" fill="#fff" />' +
                        '<circle cx="9.5" cy="11" r="0.7" fill="#667eea" />' +
                        '<circle cx="14.5" cy="11" r="0.7" fill="#667eea" />' +
                        '<rect x="10" y="15" width="4" height="1.5" rx="0.7" fill="#764ba2" />' +
                        '<circle cx="6" cy="4" r="0.8" fill="#ffd700" />' +
                        '</svg></span><span class="automation-toggle-arrow">‚ñ∂</span>';
                        // Keep the toggle clickable even when expanded
                        try { btn.style.pointerEvents = 'auto'; } catch(e) {}
                    }
                }
                try { localStorage.setItem('automationPanelCollapsed', targetCollapsed ? 'true' : 'false'); } catch(e) {}
            } catch (e) { console.warn('toggleAutomationPanel error', e); }
        };

        function initAutomationResizer() {
            const leftPanel = document.querySelector('.left-panel');
            const resizer = document.getElementById('automationResizer');
            const panel = document.querySelector('.automation-panel');
            if (!leftPanel || !resizer || !panel) return;

            // restore saved width + collapsed state
            try {
                const saved = localStorage.getItem('automationPanelWidth');
                if (saved) panel.style.width = saved;
                const collapsedSaved = localStorage.getItem('automationPanelCollapsed');
                // default to collapsed unless explicitly set to 'false'
                if (collapsedSaved !== 'false') {
                    panel.classList.add('collapsed');
                    // hide resizer if collapsed
                    try { resizer.style.display = 'none'; } catch(e) {}
                    try {
                        const tbtn = document.getElementById('automationToggleBtn');
                        if (tbtn) {
                            tbtn.innerHTML = '<span class="automation-toggle-icon">' +
                        '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">' +
                        '<defs><linearGradient id="robotBody" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:#667eea;stop-opacity:1" /><stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" /></linearGradient></defs>' +
                        '<rect x="5" y="8" width="14" height="10" rx="3" fill="url(#robotBody)" stroke="#5567d8" stroke-width="0.5" />' +
                        '<rect x="7" y="4" width="10" height="4" rx="2" fill="#667eea" stroke="#5567d8" stroke-width="0.5" />' +
                        '<circle cx="9.5" cy="11" r="1.3" fill="#fff" />' +
                        '<circle cx="14.5" cy="11" r="1.3" fill="#fff" />' +
                        '<circle cx="9.5" cy="11" r="0.7" fill="#667eea" />' +
                        '<circle cx="14.5" cy="11" r="0.7" fill="#667eea" />' +
                        '<rect x="10" y="15" width="4" height="1.5" rx="0.7" fill="#764ba2" />' +
                        '<circle cx="6" cy="4" r="0.8" fill="#ffd700" />' +
                        '</svg></span><span class="automation-toggle-arrow">‚óÄ</span>';
                            try { tbtn.style.pointerEvents = 'auto'; } catch(e) {}
                        }
                    } catch(e) {}
                }
            } catch (e) {}

            let dragging = false;
            let pointerId = null;
            const minW = 220;
            const maxW = Math.min(900, leftPanel.clientWidth - 160);
            // Pointer Events (preferred): covers mouse, touch, stylus
            // We'll attach a full-window transparent overlay while dragging so other panels
            // (like the API response right-panel) can't steal pointer events.
            let dragOverlay = null;
            function createOverlay() {
                if (dragOverlay) return dragOverlay;
                dragOverlay = document.createElement('div');
                dragOverlay.id = 'resizerDragOverlay';
                Object.assign(dragOverlay.style, {
                    position: 'fixed', top: '0', left: '0', right: '0', bottom: '0',
                    background: 'transparent', zIndex: 9990, cursor: 'col-resize'
                });
                return dragOverlay;
            }

            resizer.addEventListener('pointerdown', (ev) => {
                try { ev.preventDefault(); } catch(e){}
                dragging = true;
                pointerId = ev.pointerId;
                try { resizer.setPointerCapture(pointerId); } catch(e) {}
                // add overlay to ensure we keep receiving pointer events even when cursor
                // moves over other interactive panels
                try {
                    const o = createOverlay();
                    document.body.appendChild(o);
                } catch (e) { /* ignore overlay failures */ }
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            document.addEventListener('pointermove', (ev) => {
                if (!dragging) return;
                // if pointerId is set, only respond to that pointer
                if (pointerId !== null && ev.pointerId !== pointerId) return;
                // Anchor width calculation to the window's right edge minus the right panel width
                // (mirrors the working right-panel resizer logic). This prevents event
                // interception when the cursor moves over the right panel.
                let newW = Math.round((window.innerWidth - (rightPanel?.offsetWidth || 0)) - ev.clientX);
                const maxForNow = Math.min(maxW, (window.innerWidth - (rightPanel?.offsetWidth || 0)) - (leftPanel.getBoundingClientRect().left + 120));
                if (newW < minW) newW = minW;
                if (newW > maxForNow) newW = maxForNow;
                panel.style.width = newW + 'px';
            });

            document.addEventListener('pointerup', (ev) => {
                if (!dragging) return;
                if (pointerId !== null && ev.pointerId !== pointerId) return;
                dragging = false;
                try { resizer.releasePointerCapture(ev.pointerId); } catch (e) {}
                pointerId = null;
                // remove overlay
                try { const o = document.getElementById('resizerDragOverlay'); if (o && o.parentNode) o.parentNode.removeChild(o); } catch(e) {}
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                try { localStorage.setItem('automationPanelWidth', panel.style.width); } catch(e) {}
            });

            // Fallback for older browsers: also listen for mouse/touch
            resizer.addEventListener('mousedown', (ev) => {
                try { ev.preventDefault(); } catch(e){}
                dragging = true;
                try { const o = createOverlay(); document.body.appendChild(o); } catch(e){}
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            document.addEventListener('mousemove', (ev) => { if (!dragging) return; let newW = Math.round((window.innerWidth - (rightPanel?.offsetWidth || 0)) - ev.clientX); const maxForNow = Math.min(maxW, (window.innerWidth - (rightPanel?.offsetWidth || 0)) - (leftPanel.getBoundingClientRect().left + 120)); if (newW < minW) newW = minW; if (newW > maxForNow) newW = maxForNow; panel.style.width = newW + 'px'; });
            document.addEventListener('mouseup', () => { if (dragging) { dragging = false; try { const o = document.getElementById('resizerDragOverlay'); if (o && o.parentNode) o.parentNode.removeChild(o); } catch(e){} document.body.style.cursor = ''; document.body.style.userSelect = ''; try { localStorage.setItem('automationPanelWidth', panel.style.width); } catch(e) {} } });

            resizer.addEventListener('touchstart', (ev) => { try { ev.preventDefault(); } catch(e){} dragging = true; try { const o = createOverlay(); document.body.appendChild(o); } catch(e){} document.body.style.cursor = 'col-resize'; document.body.style.userSelect = 'none'; }, {passive:false});
            document.addEventListener('touchmove', (ev) => { if (!dragging) return; const touch = ev.touches[0]; if (!touch) return; let newW = Math.round((window.innerWidth - (rightPanel?.offsetWidth || 0)) - touch.clientX); const maxForNow = Math.min(maxW, (window.innerWidth - (rightPanel?.offsetWidth || 0)) - (leftPanel.getBoundingClientRect().left + 120)); if (newW < minW) newW = minW; if (newW > maxForNow) newW = maxForNow; panel.style.width = newW + 'px'; }, {passive:true});
            document.addEventListener('touchend', () => { dragging = false; try { const o = document.getElementById('resizerDragOverlay'); if (o && o.parentNode) o.parentNode.removeChild(o); } catch(e){} document.body.style.cursor = ''; document.body.style.userSelect = ''; try { localStorage.setItem('automationPanelWidth', panel.style.width); } catch(e) {} }, {passive:true});
        }

        // Init - set up UI state on page load (NO authenticated API calls here!)
        document.addEventListener('DOMContentLoaded', () => {
            // Suppress auto-opening of the right-panel while the page initializes
            window.suppressPanelAutoOpen = true;

            // Ensure right-panel collapsed by default unless user explicitly expanded it before
            try {
                let saved = localStorage.getItem('rightPanelCollapsed');
                // If the user has no saved preference, default to collapsed and persist that choice
                if (saved === null) {
                    try { localStorage.setItem('rightPanelCollapsed', 'true'); } catch(e) {}
                    saved = 'true';
                }
                const panel = document.getElementById('rightPanel');
                const toggleBtn = document.getElementById('toggleBtn');
                // localStorage stores 'true' when collapsed, 'false' when expanded
                // Default to collapsed (panelCollapsed=true) unless explicitly set to 'false'
                if (saved === 'false') {
                    // User previously expanded the panel - keep it expanded
                    if (panel) panel.classList.remove('collapsed');
                    if (toggleBtn) {
                        toggleBtn.textContent = 'R ‚ñ∂';
                    }
                    panelCollapsed = false;
                    setTimeout(updateToggleBtnPosition, 100);
                } else {
                    // Default or 'true' - keep collapsed
                    if (panel) panel.classList.add('collapsed');
                    if (toggleBtn) {
                        toggleBtn.textContent = 'R ‚óÄ';
                        toggleBtn.style.right = '0px';
                    }
                    panelCollapsed = true;
                }
            } catch (e) { /* ignore */ }
            // NOTE: All authenticated API calls are deferred to initializePageData()
            // which is called only after firebaseAuth confirms user is authenticated
        });
        
        // =====================================================
        // AUTHENTICATED PAGE DATA INITIALIZATION
        // =====================================================
        // This function is called ONLY after user is authenticated
        // It loads all data that requires Firebase auth tokens
        async function initializePageData() {
            console.log('[PageInit] Initializing page data for authenticated user');
            
            // 0) Load shared config from backend (e.g. default weather location)
            try {
                const cfgResp = await authenticatedFetch('/api/config');
                const cfg = await cfgResp.json();
                if (cfg.errno === 0 && cfg.result) {
                    const wInput = document.getElementById('weatherPlace');
                    // Prefer explicit preferences.weatherPlace (user preference), then top-level weatherPlace
                    const preferredWeather = (cfg.result.preferences && cfg.result.preferences.weatherPlace) || cfg.result.weatherPlace;
                    // Only set if input is empty or still holds the placeholder/default value
                    if (wInput && (wInput.value === '' || wInput.value === 'Roselands 2196 NSW')) {
                        if (preferredWeather && String(preferredWeather).trim() !== '' && preferredWeather !== 'undefined') {
                            wInput.value = preferredWeather;
                        } else {
                            // Use sensible default if not configured
                            wInput.value = 'Sydney NSW';
                        }
                    }
                    const snInput = document.getElementById('deviceSn');
                    if (snInput && !snInput.value && cfg.result.deviceSn) {
                        snInput.value = cfg.result.deviceSn;
                    }

                    // Apply backend-configured refresh intervals so the UI honors settings
                    try {
                        if (cfg.result.cache && typeof cfg.result.cache.amber === 'number') {
                            CONFIG.refresh.amberPricesMs = Number(cfg.result.cache.amber);
                        }
                        if (cfg.result.cache && typeof cfg.result.cache.inverter === 'number') {
                            CONFIG.refresh.inverterMs = Number(cfg.result.cache.inverter);
                        }
                        if (cfg.result.cache && typeof cfg.result.cache.weather === 'number') {
                            CONFIG.refresh.weatherMs = Number(cfg.result.cache.weather);
                        }
                        if (cfg.result.automation && typeof cfg.result.automation.intervalMs === 'number') {
                            CONFIG.automation.intervalMs = Number(cfg.result.automation.intervalMs);
                        }
                        if (cfg.result.defaults && typeof cfg.result.defaults.cooldownMinutes === 'number') {
                            CONFIG.defaults = cfg.result.defaults;
                        }
                        // Update FAQ display with actual config values
                        updateFaqValues();
                    } catch (e) {
                        console.warn('Failed to apply backend refresh config', e);
                    }
                }
            } catch (e) { console.warn('Failed to load backend config', e); }
            
            // 1) Load Amber sites / prices
            try { loadAmberSites(); } catch(e) { console.warn('Failed to load Amber sites:', e); }
            
            // 2) Fetch inverter real-time data immediately
            try { callAPI('/api/inverter/real-time', 'Real-time Data'); } catch(e) { console.warn('Failed to load inverter data:', e); }
            
            // 3) Set up weather request
            try {
                // Determine default forecast days from backend preferences or top-level config
                try {
                    const daysEl = document.getElementById('weatherDays');
                    let defaultDays = 6;
                    if (cfg.result) {
                        if (cfg.result.preferences && typeof cfg.result.preferences.forecastDays === 'number') {
                            defaultDays = Number(cfg.result.preferences.forecastDays);
                        } else if (typeof cfg.result.forecastDays === 'number') {
                            defaultDays = Number(cfg.result.forecastDays);
                        }
                    }
                    // Clamp to allowed range
                    defaultDays = Math.max(1, Math.min(16, defaultDays || 6));
                    if (daysEl) daysEl.value = defaultDays;
                } catch (e) {
                    try { document.getElementById('weatherDays').value = 6; } catch (ee) {}
                }
                updateWeatherRequestedLabel();
                document.getElementById('weatherDays').addEventListener('input', updateWeatherRequestedLabel);
                getWeather();
            } catch(e) { console.warn('Failed to initialize weather:', e); }
            
            // 4) Load automation rules from localStorage
            try { loadAutomationRules(); } catch (e) { console.error('Error loading automation rules:', e); }
            
            // 5) Load backend automation status
            try { setTimeout(() => { loadBackendAutomationStatus(); }, 300); } catch(e) { console.warn('Failed to load automation status:', e); }
            
            // 6) Load API call metrics
            try { loadApiMetrics(1); } catch(e) { console.warn('Failed to load API metrics:', e); }
            
            // Now allow user-triggered API calls to open the panel
            window.suppressPanelAutoOpen = false;
            
            // ---- Start auto-refresh timers ----
            // Amber prices: every 30s
            try {
                if (amberRefreshTimer) clearInterval(amberRefreshTimer);
                amberRefreshTimer = setInterval(() => {
                    const siteId = document.getElementById('amberSiteId')?.value;
                    if (siteId) getAmberCurrent();
                }, REFRESH.amberPricesMs);
                if (!lastUpdateTicker) lastUpdateTicker = setInterval(updateLastUpdateDisplays, 1000);
            } catch (e) { console.warn('Amber refresh timer failed:', e); }

            // Inverter real-time data: every 5 minutes
            try {
                if (inverterRefreshTimer) clearInterval(inverterRefreshTimer);
                inverterRefreshTimer = setInterval(() => {
                    callAPI('/api/inverter/real-time', 'Real-time Data');
                }, REFRESH.inverterMs);
                if (!lastUpdateTicker) lastUpdateTicker = setInterval(updateLastUpdateDisplays, 1000);
            } catch (e) { console.warn('Inverter refresh timer failed:', e); }

            // Weather: every 30 minutes
            try {
                if (weatherRefreshTimer) clearInterval(weatherRefreshTimer);
                weatherRefreshTimer = setInterval(() => {
                    getWeather();
                }, REFRESH.weatherMs);
                if (!lastUpdateTicker) lastUpdateTicker = setInterval(updateLastUpdateDisplays, 1000);
            } catch (e) { console.warn('Weather refresh timer failed:', e); }

            // API call metrics: every 30 seconds
            try {
                if (window.metricsRefreshTimer) clearInterval(window.metricsRefreshTimer);
                window.metricsRefreshTimer = setInterval(() => {
                    loadApiMetrics(1);
                }, 30000);
            } catch (e) { console.warn('Metrics refresh timer failed:', e); }

            // Note: Automation status is NOT refreshed on a timer anymore
            // The countdown timer handles calling runAutomationCycle() when it hits 0
            // Status is only refreshed after specific actions (toggle, rule changes, cycle complete)
            
            // Start the 'since' ticker
            try {
                updateLastUpdateDisplays();
                if (!lastUpdateTicker) {
                    lastUpdateTicker = setInterval(updateLastUpdateDisplays, 1000);
                }
            } catch(e) { console.error('Update displays failed:', e); }
            
            // Init resizer for automation panel
            try { initAutomationResizer(); } catch(e) { console.error('initAutomationResizer failed:', e); }

            // Allow automated API calls to open the panel
            setTimeout(() => { try { window.suppressPanelAutoOpen = false; } catch(e) {} }, 1200);
        }

        // =====================================================
        // AUTOMATION RULES SYSTEM
        // =====================================================
        
        let automationRules = [];
        let automationEnabled = false;

        function loadAutomationRules() {
            try {
                const saved = localStorage.getItem('automationRules');
                if (saved) {
                    automationRules = JSON.parse(saved);
                }
                const enabledState = localStorage.getItem('automationEnabled');
                automationEnabled = enabledState === 'true';
            } catch (e) {
                console.error('Failed to load automation rules:', e);
                automationRules = [];
            }
            renderRules();
            updateAutomationToggle();
        }

        // Load backend automation status and sync UI
        async function loadBackendAutomationStatus() {
            try {
                const container = document.getElementById('backendAutomationStatus');
                if (!container) {
                    console.error('[Automation] Container backendAutomationStatus not found');
                    return;
                }
                
                // Don't show "Loading..." during refresh - it causes flicker
                // Only show it if the container is completely empty
                if (!container.innerHTML.trim() || container.innerHTML.includes('Failed') || container.innerHTML.includes('Error')) {
                    container.innerHTML = '<div style="color:#8b949e;font-size:12px">Loading automation status...</div>';
                }
                
                const resp = await authenticatedFetch('/api/automation/status');
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const data = await resp.json();
                if (data.errno === 0 && data.result) {
                    updateBackendAutomationUI(data.result);
                } else {
                    container.innerHTML = '<div style="color:#f85149;font-size:12px">‚ö†Ô∏è Failed to load (errno: ' + data.errno + ')</div>';
                }
            } catch (e) {
                console.error('[Automation] Load failed:', e);
                const container = document.getElementById('backendAutomationStatus');
                if (container) {
                    container.innerHTML = `<div style="color:#f85149;font-size:12px">‚ö†Ô∏è Error: ${e.message}</div>`;
                }
            }
        }

        // Update the backend automation section UI
        function updateBackendAutomationUI(status) {
            try {
                const container = document.getElementById('backendAutomationStatus');
                if (!container) {
                    console.error('[Automation] Container not found in updateBackendAutomationUI');
                    return;
                }
                
                const masterEnabled = status.enabled;
                const inBlackout = status.inBlackout || false;
                const blackoutWindow = status.currentBlackoutWindow;
                // Normalize lastCheck (handle Firestore Timestamp shapes and seconds/ms ambiguity)
                let lastCheckRaw = status.lastCheck;
                let lastCheck = Date.now();
                if (lastCheckRaw !== null && lastCheckRaw !== undefined) {
                    if (typeof lastCheckRaw === 'number') {
                        lastCheck = lastCheckRaw > 1e12 ? lastCheckRaw : lastCheckRaw * 1000;
                    } else if (typeof lastCheckRaw === 'object') {
                        const sec = lastCheckRaw._seconds ?? lastCheckRaw.seconds;
                        const nsec = lastCheckRaw._nanoseconds ?? lastCheckRaw.nanos ?? 0;
                        if (typeof sec === 'number') {
                            lastCheck = (sec * 1000) + Math.floor((nsec || 0) / 1e6);
                        } else {
                            const parsed = Number(lastCheckRaw);
                            lastCheck = !isNaN(parsed) ? (parsed > 1e12 ? parsed : parsed * 1000) : Date.now();
                        }
                    } else {
                        const parsed = Number(lastCheckRaw);
                        lastCheck = !isNaN(parsed) ? (parsed > 1e12 ? parsed : parsed * 1000) : Date.now();
                    }
                }
                const automationIntervalSec = CONFIG.automation.intervalMs / 1000;
                const nextCheckIn = Math.max(0, automationIntervalSec - Math.floor((Date.now() - lastCheck) / 1000));
                
                // Determine effective state: blackout overrides master enabled
                const effectivelyPaused = !masterEnabled || inBlackout;
                const statusText = inBlackout ? 'BLACKOUT' : (masterEnabled ? 'ACTIVE' : 'PAUSED');
                const statusColor = inBlackout ? '#f0883e' : (masterEnabled ? '#7ee787' : '#f85149');
                const countdownText = inBlackout ? 'BLACKOUT' : (masterEnabled ? nextCheckIn + 's' : 'PAUSED');
                const subtitleText = inBlackout 
                    ? `‚è∏Ô∏è Blackout window: ${blackoutWindow?.start || '??'} - ${blackoutWindow?.end || '??'}`
                    : (masterEnabled ? `Auto-refreshes every ${automationIntervalSec} seconds` : 'Enable master switch to activate');
                const gradientColors = inBlackout ? '#f0883e 0%, #da3633 100%' : (masterEnabled ? '#1f6feb 0%, #238636 100%' : '#6e7681 0%, #8b949e 100%');
            
            let html = `
                <!-- Countdown Timer -->
                <div style="background:linear-gradient(135deg, ${gradientColors});border-radius:8px;padding:14px;margin-bottom:14px;text-align:center;box-shadow:0 4px 12px rgba(31,111,235,0.3);opacity:${effectivelyPaused ? 0.85 : 1}">
                    <div style="font-size:11px;color:rgba(255,255,255,0.85);margin-bottom:6px;font-weight:500;letter-spacing:0.5px">${inBlackout ? 'üö´ AUTOMATION BLACKOUT' : '‚è±Ô∏è NEXT AUTOMATION CYCLE'}</div>
                    <div id="automationCountdown" style="font-size:32px;font-weight:700;color:#fff;font-family:'Courier New',monospace;letter-spacing:3px;text-shadow:0 2px 8px rgba(0,0,0,0.3)">${countdownText}</div>
                    <div style="font-size:10px;color:rgba(255,255,255,0.6);margin-top:4px">${subtitleText}</div>
                </div>
                
                <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:16px;padding-bottom:12px;border-bottom:1px solid #30363d">
                    <div>
                        <div style="font-size:14px;font-weight:600;color:#e6edf3">ü§ñ Master Switch</div>
                        <div style="font-size:11px;color:#6e7681;margin-top:2px">${inBlackout ? '‚ö†Ô∏è Blackout active - automation paused' : 'Controls all automation rules'}</div>
                    </div>
                    <div style="display:flex;align-items:center;gap:8px">
                        <span style="font-size:12px;font-weight:600;color:${statusColor}">${statusText}</span>
                        <div class="automation-toggle ${masterEnabled ? 'active' : ''}" onclick="toggleBackendAutomation()" style="width:48px;height:26px"></div>
                    </div>
                </div>
                <!-- Compact Add Rule button placed under Master Switch for quick access -->
                <div style="display:flex;justify-content:flex-start;gap:8px;margin-bottom:12px">
                    <button class="btn btn-primary btn-sm" onclick="showAddRuleModal()" style="padding:6px 10px;font-size:12px">‚ûï Add Rule</button>
                </div>
            `;
            
            // Render all automation rules (sorted by priority)
            const allRules = Object.entries(status.rules || {}).sort((a,b) => (a[1].priority || 99) - (b[1].priority || 99));
            if (allRules.length > 0) {
                html += `<div style=\"font-size:12px;font-weight:600;color:#58a6ff;margin-bottom:8px\">üìã Automation Rules (${allRules.length})</div>`;
                html += `<div style="font-size:10px;color:#8b949e;margin-bottom:8px;padding:6px 8px;background:rgba(88,166,255,0.1);border-radius:4px;border-left:2px solid #58a6ff">Sorted by priority ‚Ä¢ Lower number = Higher priority ‚Ä¢ First match wins</div>`;
                allRules.forEach(([ruleName, rule]) => {
                    const ruleAction = rule.action || {};
                    const conditions = rule.conditions || {};
                    
                    // Build conditions badges
                    let condBadges = '';
                    if (conditions.feedInPrice?.enabled) condBadges += `<span style="background:#238636;color:#fff;padding:2px 6px;border-radius:3px;font-size:10px;margin-right:4px">Feed-in ${conditions.feedInPrice.operator} ${conditions.feedInPrice.value}¬¢</span>`;
                    if (conditions.buyPrice?.enabled) condBadges += `<span style="background:#1f6feb;color:#fff;padding:2px 6px;border-radius:3px;font-size:10px;margin-right:4px">Buy ${conditions.buyPrice.operator} ${conditions.buyPrice.value}¬¢</span>`;
                    if (conditions.soc?.enabled) condBadges += `<span style="background:#8957e5;color:#fff;padding:2px 6px;border-radius:3px;font-size:10px;margin-right:4px">SoC ${conditions.soc.operator} ${conditions.soc.value}%</span>`;
                    if (conditions.temperature?.enabled) condBadges += `<span style="background:#f0883e;color:#000;padding:2px 6px;border-radius:3px;font-size:10px;margin-right:4px">Temp ${conditions.temperature.operator} ${conditions.temperature.value}¬∞C</span>`;
                    if (conditions.time?.enabled || conditions.timeWindow?.enabled) {
                        const tw = conditions.time || conditions.timeWindow;
                        condBadges += `<span style="background:#6e7681;color:#fff;padding:2px 6px;border-radius:3px;font-size:10px;margin-right:4px">${tw.start || tw.startTime}-${tw.end || tw.endTime}</span>`;
                    }
                    if (!condBadges) condBadges = '<span style="color:#8b949e;font-size:10px">No conditions set</span>';
                    
                    const priorityClass = rule.priority <= 1 ? 'p1' : rule.priority === 2 ? 'p2' : rule.priority === 3 ? 'p3' : (rule.priority === 4 || rule.priority === 5) ? 'p4' : 'p-low';
                    const isActive = status.activeRule === ruleName;
                    html += `
                    <div style="background:${isActive ? 'rgba(126,231,135,0.1)' : '#21262d'};border:1px solid ${isActive ? '#7ee787' : (rule.enabled && masterEnabled ? '#58a6ff' : '#30363d')};border-radius:8px;padding:12px;margin-bottom:8px;opacity:${masterEnabled ? 1 : 0.6};border-left:${isActive ? '3px solid #7ee787' : '1px solid ' + (rule.enabled && masterEnabled ? '#58a6ff' : '#30363d')}">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                            <div style="display:flex;align-items:center;gap:8px">
                                <span class="priority-badge ${priorityClass}" title="Priority ${rule.priority || '?'} - Lower number = Higher priority">P${rule.priority || '?'}</span>
                                <span style="font-weight:600;color:${isActive ? '#7ee787' : '#58a6ff'};font-size:14px">${rule.name || ruleName}</span>
                                ${isActive ? '<span style="background:#7ee787;color:#000;padding:2px 6px;border-radius:4px;font-size:10px;font-weight:700">ACTIVE NOW</span>' : ''}
                            </div>
                            <div style="display:flex;align-items:center;gap:6px">
                                <label style="display:flex;align-items:center;gap:4px;cursor:pointer">
                                    <input type="checkbox" ${rule.enabled ? 'checked' : ''} onchange="updateBackendRule('${ruleName}', 'enabled', this.checked)" style="accent-color:#58a6ff;width:14px;height:14px">
                                    <span style="font-size:11px;font-weight:600;color:${rule.enabled ? '#58a6ff' : '#8b949e'}">${rule.enabled ? 'ON' : 'OFF'}</span>
                                </label>
                                <button onclick="editBackendRule('${ruleName}')" style="background:#1f6feb26;border:1px solid #1f6feb;color:#58a6ff;padding:3px 6px;border-radius:4px;cursor:pointer;font-size:10px" title="Edit">‚úèÔ∏è</button>
                                <button onclick="deleteBackendRule('${ruleName}')" style="background:#f8514926;border:1px solid #f85149;color:#f85149;padding:3px 6px;border-radius:4px;cursor:pointer;font-size:10px" title="Delete">üóëÔ∏è</button>
                            </div>
                        </div>
                        <div style="margin-bottom:8px">${condBadges}</div>
                        <div style="display:flex;gap:8px;font-size:11px;flex-wrap:wrap">
                            <div style="background:#161b22;padding:4px 8px;border-radius:4px">
                                <span style="color:#8b949e">‚Üí</span> <span style="color:#7ee787">${ruleAction.workMode || 'N/A'}</span>
                            </div>
                            <div style="background:#161b22;padding:4px 8px;border-radius:4px">
                                <span style="color:#8b949e">‚è±</span> <span style="color:#e6edf3">${ruleAction.durationMinutes || 0}min</span>
                            </div>
                            <div style="background:#161b22;padding:4px 8px;border-radius:4px">
                                <span style="color:#8b949e">‚ö°</span> <span style="color:#e6edf3">${ruleAction.fdPwr || 0}W</span>
                            </div>
                            <div style="background:#161b22;padding:4px 8px;border-radius:4px">
                                <span style="color:#8b949e">üîÑ</span> <span style="color:#e6edf3">${rule.cooldownMinutes || 5}min CD</span>
                            </div>
                        </div>
                        ${rule.lastTriggered ? `<div style="margin-top:8px;font-size:10px;color:#f0883e">‚è±Ô∏è Last: ${formatDate(rule.lastTriggered, true)}</div>` : ''}
                    </div>
                    `;
                });
            } else {
                // No rules yet - show empty state
                html += `
                    <div style="padding:20px;background:#161b22;border-radius:8px;text-align:center;margin-bottom:8px">
                        <div style="font-size:32px;margin-bottom:12px">üì≠</div>
                        <div style="font-size:14px;color:#8b949e;margin-bottom:8px">No automation rules yet</div>
                        <div style="font-size:12px;color:#6e7681">Click the button below to create your first rule</div>
                    </div>
                `;
            }
            
            // Small placeholder to keep layout/anchors stable (hidden)
            html += `<div class="add-rule-card" style="display:none"></div>`;
            
            // Test Link
            html += `
                <div style="margin-top:16px;text-align:center">
                    <a href="/test.html" target="_blank" style="color:#58a6ff;font-size:12px;text-decoration:none">üß™ Open Automation Test UI ‚Üí</a>
                </div>
            `;
            
            // Last triggered info
            if (status.lastTriggered) {
                html += `
                    <div style="margin-top:12px;padding:8px;background:#161b22;border-radius:6px;font-size:11px;color:#8b949e;text-align:center">
                        Last automation: ${formatDate(status.lastTriggered, true)} (${status.activeRule || 'unknown'})
                    </div>
                `;
            }
            
            container.innerHTML = html;
            
            // Store lastCheck, enabled state, and blackout info for countdown timer
            // Normalize lastCheck: Firestore may return a Timestamp object or seconds-only value.
            (function(){
                const raw = status.lastCheck;
                let lastMs = Date.now();
                if (raw !== null && raw !== undefined) {
                    if (typeof raw === 'number') {
                        // If small number, treat as seconds, otherwise milliseconds
                        lastMs = raw > 1e12 ? raw : raw * 1000;
                    } else if (typeof raw === 'object') {
                        // Firestore Timestamp shape: {_seconds, _nanoseconds} or {seconds, nanos}
                        const sec = raw._seconds ?? raw.seconds;
                        const nsec = raw._nanoseconds ?? raw.nanos ?? 0;
                        if (typeof sec === 'number') {
                            lastMs = (sec * 1000) + Math.floor((nsec || 0) / 1e6);
                        } else {
                            const parsed = Number(raw);
                            lastMs = !isNaN(parsed) ? (parsed > 1e12 ? parsed : parsed * 1000) : Date.now();
                        }
                    } else {
                        const parsed = Number(raw);
                        lastMs = !isNaN(parsed) ? (parsed > 1e12 ? parsed : parsed * 1000) : Date.now();
                    }
                }
                window.automationLastCheck = lastMs;
            })();
            window.automationEnabled = !!status.enabled;
            window.automationInBlackout = !!status.inBlackout;
            
            // Start countdown timer if not already running (or restart if state changed)
            const shouldRun = window.automationEnabled && !window.automationInBlackout;
            const wasRunning = !!window.automationCountdownInterval;
            const stateChanged = (shouldRun !== wasRunning) || !window.automationCountdownStarted;
            
            if (stateChanged) {
                if (window.automationCountdownInterval) {
                    clearInterval(window.automationCountdownInterval);
                    window.automationCountdownInterval = null;
                }
                
                if (shouldRun) {
                    // Initialize lastCheck if not set
                    if (!window.automationLastCheck) {
                        window.automationLastCheck = Date.now();
                    }
                    window.automationCountdownStarted = true;
                    
                    window.automationCountdownInterval = setInterval(() => {
                        const countdownEl = document.getElementById('automationCountdown');
                        if (!countdownEl) {
                            clearInterval(window.automationCountdownInterval);
                            window.automationCountdownInterval = null;
                            return;
                        }
                        // If we're now in blackout, stop countdown
                        if (window.automationInBlackout) {
                            countdownEl.textContent = 'BLACKOUT';
                            return;
                        }
                        const elapsed = Math.floor((Date.now() - window.automationLastCheck) / 1000);
                        const intervalSec = CONFIG.automation.intervalMs / 1000;
                        const remaining = Math.max(0, intervalSec - elapsed);
                        countdownEl.textContent = remaining + 's';
                        if (remaining === 0 && window.automationEnabled && !window.automationCycleRunning) {
                            // Run the actual automation cycle on the backend
                            runAutomationCycle();
                        }
                    }, CONFIG.automation.countdownUpdateMs);
                } else {
                    window.automationCountdownStarted = false;
                    // Keep PAUSED or BLACKOUT visible
                    const countdownEl = document.getElementById('automationCountdown');
                    if (countdownEl) countdownEl.textContent = window.automationInBlackout ? 'BLACKOUT' : 'PAUSED';
                }
            }
            } catch (e) {
                console.error('[Automation] updateBackendAutomationUI failed:', e);
                const container = document.getElementById('backendAutomationStatus');
                if (container) {
                    container.innerHTML = '<div style="color:#f85149;font-size:12px">‚ö†Ô∏è UI Error: ' + e.message + '</div>';
                }
            }
        }
        
        // Run the automation cycle - called by the countdown timer when it hits 0
        async function runAutomationCycle() {
            // Prevent multiple simultaneous calls
            if (window.automationCycleRunning) {
                console.log('[Automation] Cycle already running, skipping');
                return;
            }
            window.automationCycleRunning = true;
            
            // Immediately update lastCheck to reset the countdown
            window.automationLastCheck = Date.now();
            
            const countdownEl = document.getElementById('automationCountdown');
            if (countdownEl) countdownEl.textContent = '‚è≥';
            
            try {
                console.log('[Automation] Running automation cycle...');
                const resp = await authenticatedFetch('/api/automation/cycle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                const data = await resp.json();
                
                if (data.errno === 0) {
                    console.log('[Automation] Cycle complete:', data.result);
                    
                    // If a rule was triggered, show a notification and refresh status to show it as active
                    if (data.result?.triggered && data.result?.rule) {
                        const ruleName = data.result.rule.name || 'Unknown';
                        showMessage('success', `ü§ñ Automation triggered: ${ruleName}`, 5000);
                        
                        // Refresh automation status to show the active rule
                        try {
                            const statusResp = await authenticatedFetch('/api/automation/status');
                            const statusData = await statusResp.json();
                            if (statusData.errno === 0) {
                                window.automationStatus = statusData.result;
                                console.log('[Automation] Status refreshed after trigger:', statusData.result);
                                // Trigger UI update
                                const tab = document.querySelector('[data-tab-content="automation"]');
                                if (tab && tab.style.display !== 'none') {
                                    renderAutomationRulesPanel();
                                }
                            }
                        } catch (statusErr) {
                            console.warn('[Automation] Failed to refresh status:', statusErr);
                        }
                    } else if (data.result?.skipped) {
                        console.log('[Automation] Cycle skipped:', data.result.reason);
                    } else {
                        console.log('[Automation] No rules triggered this cycle');
                    }
                    
                    // Update lastCheck from server response (ensures sync)
                    if (data.result?.lastCheck) {
                        window.automationLastCheck = data.result.lastCheck;
                    }
                } else {
                    console.warn('[Automation] Cycle error:', data.error);
                    showMessage('warning', `Automation cycle error: ${data.error}`, 5000);
                }
            } catch (e) {
                console.error('[Automation] Cycle failed:', e);
                showMessage('error', `Automation cycle failed: ${e.message}`, 5000);
            } finally {
                window.automationCycleRunning = false;
                // Reset countdown display
                if (countdownEl) {
                    const intervalSec = CONFIG.automation.intervalMs / 1000;
                    countdownEl.textContent = intervalSec + 's';
                }
            }
        }
        
        // Show modal to add a new automation rule
        function showAddRuleModal() {
            const modalHtml = `
                <div id="addRuleModal" style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000">
                    <div style="background:#161b22;border:1px solid #30363d;border-radius:12px;padding:24px;width:95%;max-width:700px;max-height:90vh;overflow-y:auto">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px">
                            <h3 style="margin:0;font-size:18px;color:#e6edf3">‚ûï Create New Automation Rule</h3>
                            <button onclick="closeAddRuleModal()" style="background:none;border:none;color:#8b949e;font-size:20px;cursor:pointer">‚úï</button>
                        </div>
                        
                        <!-- Basic Info -->
                        <input type="hidden" id="newRuleId" value="">
                        <input type="hidden" id="editingRuleId" value="">
                        <div style="display:grid;grid-template-columns:2fr 1fr;gap:12px;margin-bottom:16px">
                            <div>
                                <label style="display:block;font-size:12px;color:#8b949e;margin-bottom:4px">Rule Name</label>
                                <input type="text" id="newRuleName" placeholder="e.g., Low Buy Cost Charge" style="width:100%;padding:8px;background:#0d1117;border:1px solid #30363d;border-radius:6px;color:#e6edf3;font-size:13px">
                            </div>
                            <div>
                                <label style="display:block;font-size:12px;color:#8b949e;margin-bottom:4px">Priority (1=highest)</label>
                                <input type="number" id="newRulePriority" value="5" min="1" max="99" style="width:100%;padding:8px;background:#0d1117;border:1px solid #30363d;border-radius:6px;color:#e6edf3;font-size:13px">
                            </div>
                        </div>
                        
                        <!-- CONDITIONS SECTION -->
                        <div style="background:#0d1117;border:1px solid #30363d;border-radius:8px;padding:16px;margin-bottom:16px">
                            <h4 style="margin:0 0 12px 0;font-size:14px;color:#58a6ff">üìã Conditions (ALL must be true)</h4>
                            
                            <!-- Feed-in Price -->
                            <div style="display:flex;align-items:center;gap:12px;padding:10px;background:#161b22;border-radius:6px;margin-bottom:8px">
                                <label style="display:flex;align-items:center;gap:6px;min-width:160px;cursor:pointer">
                                    <input type="checkbox" id="condFeedInEnabled" style="width:16px;height:16px">
                                    <span style="color:#e6edf3;font-size:13px">üí∞ Feed-in Price</span>
                                </label>
                                <select id="condFeedInOp" style="padding:6px;background:#0d1117;border:1px solid #30363d;border-radius:4px;color:#e6edf3;font-size:12px">
                                    <option value=">">&gt;</option>
                                    <option value=">=">&gt;=</option>
                                    <option value="<">&lt;</option>
                                    <option value="<=">&lt;=</option>
                                    <option value="between">between</option>
                                </select>
                                <input type="number" id="condFeedInVal" placeholder="¬¢/kWh" value="20" style="width:80px;padding:6px;background:#0d1117;border:1px solid #30363d;border-radius:4px;color:#e6edf3;font-size:12px">
                                <span id="condFeedInVal2Wrap" style="display:none;color:#8b949e;font-size:12px">and <input type="number" id="condFeedInVal2" value="50" style="width:60px;padding:4px;background:#0d1117;border:1px solid #30363d;border-radius:4px;color:#e6edf3;font-size:12px"></span>
                                <span style="color:#8b949e;font-size:11px">¬¢/kWh</span>
                            </div>
                            
                            <!-- Buy Price -->
                            <div style="display:flex;align-items:center;gap:12px;padding:10px;background:#161b22;border-radius:6px;margin-bottom:8px">
                                <label style="display:flex;align-items:center;gap:6px;min-width:160px;cursor:pointer">
                                    <input type="checkbox" id="condBuyEnabled" style="width:16px;height:16px">
                                    <span style="color:#e6edf3;font-size:13px">üõí Buy Price</span>
                                </label>
                                <select id="condBuyOp" style="padding:6px;background:#0d1117;border:1px solid #30363d;border-radius:4px;color:#e6edf3;font-size:12px">
                                    <option value="<">&lt;</option>
                                    <option value="<=">&lt;=</option>
                                    <option value=">">&gt;</option>
                                    <option value=">=">&gt;=</option>
                                    <option value="between">between</option>
                                </select>
                                <input type="number" id="condBuyVal" placeholder="¬¢/kWh" value="10" style="width:80px;padding:6px;background:#0d1117;border:1px solid #30363d;border-radius:4px;color:#e6edf3;font-size:12px">
                                <span id="condBuyVal2Wrap" style="display:none;color:#8b949e;font-size:12px">and <input type="number" id="condBuyVal2" value="20" style="width:60px;padding:4px;background:#0d1117;border:1px solid #30363d;border-radius:4px;color:#e6edf3;font-size:12px"></span>
                                <span style="color:#8b949e;font-size:11px">¬¢/kWh</span>
                            </div>
                            
                            <!-- Battery SoC -->
                            <div style="display:flex;align-items:center;gap:12px;padding:10px;background:#161b22;border-radius:6px;margin-bottom:8px">
                                <label style="display:flex;align-items:center;gap:6px;min-width:160px;cursor:pointer">
                                    <input type="checkbox" id="condSocEnabled" style="width:16px;height:16px">
                                    <span style="color:#e6edf3;font-size:13px">üîã Battery SoC</span>
                                </label>
                                <select id="condSocOp" style="padding:6px;background:#0d1117;border:1px solid #30363d;border-radius:4px;color:#e6edf3;font-size:12px">
                                    <option value=">">&gt;</option>
                                    <option value=">=">&gt;=</option>
                                    <option value="<">&lt;</option>
                                    <option value="<=">&lt;=</option>
                                    <option value="between">between</option>
                                </select>
                                <input type="number" id="condSocVal" placeholder="%" value="80" min="0" max="100" style="width:80px;padding:6px;background:#0d1117;border:1px solid #30363d;border-radius:4px;color:#e6edf3;font-size:12px">
                                <span id="condSocVal2Wrap" style="display:none;color:#8b949e;font-size:12px">and <input type="number" id="condSocVal2" value="100" min="0" max="100" style="width:60px;padding:4px;background:#0d1117;border:1px solid #30363d;border-radius:4px;color:#e6edf3;font-size:12px"></span>
                                <span style="color:#8b949e;font-size:11px">%</span>
                            </div>
                            
                            <!-- Temperature -->
                            <div style="display:flex;align-items:center;gap:12px;padding:10px;background:#161b22;border-radius:6px;margin-bottom:8px">
                                <label style="display:flex;align-items:center;gap:6px;min-width:160px;cursor:pointer">
                                    <input type="checkbox" id="condTempEnabled" style="width:16px;height:16px">
                                    <span style="color:#e6edf3;font-size:13px">üå°Ô∏è Temperature</span>
                                </label>
                                <select id="condTempType" style="padding:6px;background:#0d1117;border:1px solid #30363d;border-radius:4px;color:#e6edf3;font-size:12px">
                                    <option value="battery">Battery</option>
                                    <option value="ambient">Ambient</option>
                                    <option value="inverter">Inverter</option>
                                </select>
                                <select id="condTempOp" style="padding:6px;background:#0d1117;border:1px solid #30363d;border-radius:4px;color:#e6edf3;font-size:12px">
                                    <option value="<">&lt;</option>
                                    <option value="<=">&lt;=</option>
                                    <option value=">">&gt;</option>
                                    <option value=">=">&gt;=</option>
                                </select>
                                <input type="number" id="condTempVal" placeholder="¬∞C" value="40" style="width:70px;padding:6px;background:#0d1117;border:1px solid #30363d;border-radius:4px;color:#e6edf3;font-size:12px">
                                <span style="color:#8b949e;font-size:11px">¬∞C</span>
                            </div>
                            
                            <!-- Time Window -->
                            <div style="display:flex;align-items:center;gap:12px;padding:10px;background:#161b22;border-radius:6px">
                                <label style="display:flex;align-items:center;gap:6px;min-width:160px;cursor:pointer">
                                    <input type="checkbox" id="condTimeEnabled" style="width:16px;height:16px">
                                    <span style="color:#e6edf3;font-size:13px">üïê Time Window</span>
                                </label>
                                <input type="time" id="condTimeStart" value="06:00" style="padding:6px;background:#0d1117;border:1px solid #30363d;border-radius:4px;color:#e6edf3;font-size:12px">
                                <span style="color:#8b949e;font-size:12px">to</span>
                                <input type="time" id="condTimeEnd" value="18:00" style="padding:6px;background:#0d1117;border:1px solid #30363d;border-radius:4px;color:#e6edf3;font-size:12px">
                            </div>
                        </div>
                        
                        <!-- ACTION SECTION -->
                        <div style="background:#0d1117;border:1px solid #30363d;border-radius:8px;padding:16px;margin-bottom:16px">
                            <h4 style="margin:0 0 12px 0;font-size:14px;color:#238636">‚ö° Action (when conditions met)</h4>
                            
                            <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-bottom:12px">
                                <div>
                                    <label style="display:block;font-size:11px;color:#8b949e;margin-bottom:4px">Work Mode</label>
                                    <select id="newRuleWorkMode" style="width:100%;padding:8px;background:#161b22;border:1px solid #30363d;border-radius:6px;color:#e6edf3;font-size:13px">
                                        <option value="ForceDischarge">Force Discharge</option>
                                        <option value="ForceCharge">Force Charge</option>
                                        <option value="SelfUse">Self Use</option>
                                        <option value="Feedin">Feed In</option>
                                        <option value="Backup">Backup</option>
                                    </select>
                                </div>
                                <div>
                                    <label style="display:block;font-size:11px;color:#8b949e;margin-bottom:4px">Duration (min)</label>
                                    <input type="number" id="newRuleDuration" value="30" min="5" max="120" style="width:100%;padding:8px;background:#161b22;border:1px solid #30363d;border-radius:6px;color:#e6edf3;font-size:13px">
                                </div>
                                <div>
                                    <label style="display:block;font-size:11px;color:#8b949e;margin-bottom:4px">Cooldown (min)</label>
                                    <input type="number" id="newRuleCooldown" value="5" min="1" max="60" style="width:100%;padding:8px;background:#161b22;border:1px solid #30363d;border-radius:6px;color:#e6edf3;font-size:13px">
                                </div>
                            </div>
                            
                            <div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:12px">
                                <div>
                                    <label style="display:block;font-size:11px;color:#8b949e;margin-bottom:4px">FD Power (W)</label>
                                    <input type="number" id="newRuleFdPwr" value="5000" min="0" max="10500" step="100" style="width:100%;padding:8px;background:#161b22;border:1px solid #30363d;border-radius:6px;color:#e6edf3;font-size:13px">
                                </div>
                                <div>
                                    <label style="display:block;font-size:11px;color:#8b949e;margin-bottom:4px">FD SoC (%)</label>
                                    <input type="number" id="newRuleFdSoc" value="35" min="10" max="100" style="width:100%;padding:8px;background:#161b22;border:1px solid #30363d;border-radius:6px;color:#e6edf3;font-size:13px">
                                </div>
                                <div>
                                    <label style="display:block;font-size:11px;color:#8b949e;margin-bottom:4px">Min SoC Grid</label>
                                    <input type="number" id="newRuleMinSoc" value="20" min="10" max="100" style="width:100%;padding:8px;background:#161b22;border:1px solid #30363d;border-radius:6px;color:#e6edf3;font-size:13px">
                                </div>
                                <div>
                                    <label style="display:block;font-size:11px;color:#8b949e;margin-bottom:4px">Max SoC (%)</label>
                                    <input type="number" id="newRuleMaxSoc" value="90" min="10" max="100" style="width:100%;padding:8px;background:#161b22;border:1px solid #30363d;border-radius:6px;color:#e6edf3;font-size:13px">
                                </div>
                            </div>
                        </div>
                        
                        <div style="display:flex;gap:12px">
                            <button onclick="closeAddRuleModal()" style="flex:1;padding:12px;background:#21262d;border:1px solid #30363d;border-radius:6px;color:#e6edf3;cursor:pointer;font-size:14px">Cancel</button>
                            <button onclick="testNewRule()" style="flex:1;padding:12px;background:#1f6feb;border:none;border-radius:6px;color:#fff;cursor:pointer;font-size:14px">üß™ Test Rule</button>
                            <button onclick="createBackendRule()" style="flex:1;padding:12px;background:#238636;border:none;border-radius:6px;color:#fff;cursor:pointer;font-size:14px;font-weight:600">Create Rule</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            // Hide the floating automation toggle while modal is open so it doesn't overlay the dialog
            try {
                const t = document.getElementById('automationToggleBtn');
                if (t) t.style.display = 'none';
            } catch (e) {}
            
            // Add event listeners for "between" operator toggle
            ['FeedIn', 'Buy', 'Soc'].forEach(type => {
                const opSelect = document.getElementById('cond' + type + 'Op');
                const val2Wrap = document.getElementById('cond' + type + 'Val2Wrap');
                if (opSelect && val2Wrap) {
                    opSelect.addEventListener('change', () => {
                        val2Wrap.style.display = opSelect.value === 'between' ? 'inline' : 'none';
                    });
                }
            });
        }
        
        function closeAddRuleModal() {
            const modal = document.getElementById('addRuleModal');
            if (modal) modal.remove();
            try {
                const t = document.getElementById('automationToggleBtn');
                if (t) t.style.display = '';
            } catch (e) {}
        }
        
        async function createBackendRule() {
            const editingId = document.getElementById('editingRuleId')?.value;
            const name = document.getElementById('newRuleName').value.trim();
            // Auto-generate rule ID from name if not editing
            const ruleName = editingId || name.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, '') || ('rule_' + Date.now());
            const priority = parseInt(document.getElementById('newRulePriority').value) || 5;
            const cooldownMinutes = parseInt(document.getElementById('newRuleCooldown').value) || 5;
            const workMode = document.getElementById('newRuleWorkMode').value;
            const durationMinutes = parseInt(document.getElementById('newRuleDuration').value) || 30;
            const fdPwr = parseInt(document.getElementById('newRuleFdPwr').value) || 0;
            const fdSoc = parseInt(document.getElementById('newRuleFdSoc').value) || 10;
            const minSocOnGrid = parseInt(document.getElementById('newRuleMinSoc').value) || 10;
            const maxSoc = parseInt(document.getElementById('newRuleMaxSoc').value) || 100;
            
            if (!name) {
                alert('Please enter a rule name');
                return;
            }
            
            // Collect conditions - use modal scoping for time fields to avoid duplicate ID conflicts
            const modal = document.getElementById('addRuleModal');
            const conditions = {
                feedInPrice: {
                    enabled: document.getElementById('condFeedInEnabled').checked,
                    operator: document.getElementById('condFeedInOp').value,
                    value: parseFloat(document.getElementById('condFeedInVal').value) || 0,
                    value2: parseFloat(document.getElementById('condFeedInVal2')?.value) || 0
                },
                buyPrice: {
                    enabled: document.getElementById('condBuyEnabled').checked,
                    operator: document.getElementById('condBuyOp').value,
                    value: parseFloat(document.getElementById('condBuyVal').value) || 0,
                    value2: parseFloat(document.getElementById('condBuyVal2')?.value) || 0
                },
                soc: {
                    enabled: document.getElementById('condSocEnabled').checked,
                    operator: document.getElementById('condSocOp').value,
                    value: parseFloat(document.getElementById('condSocVal').value) || 50,
                    value2: parseFloat(document.getElementById('condSocVal2')?.value) || 100
                },
                temperature: {
                    enabled: document.getElementById('condTempEnabled').checked,
                    type: document.getElementById('condTempType').value,
                    operator: document.getElementById('condTempOp').value,
                    value: parseFloat(document.getElementById('condTempVal').value) || 40
                },
                time: {
                    enabled: modal?.querySelector('#condTimeEnabled')?.checked || false,
                    startTime: modal?.querySelector('#condTimeStart')?.value || '00:00',
                    endTime: modal?.querySelector('#condTimeEnd')?.value || '23:59'
                }
            };
            
            // Check at least one condition is enabled
            const hasCondition = conditions.feedInPrice.enabled || conditions.buyPrice.enabled || 
                                 conditions.soc.enabled || conditions.temperature.enabled || conditions.time.enabled;
            if (!hasCondition) {
                alert('Please enable at least one condition');
                return;
            }
            
            try {
                // Use update endpoint if editing, create if new
                const endpoint = editingId ? '/api/automation/rule/update' : '/api/automation/rule/create';
                const resp = await authenticatedFetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ruleName,
                        name: name || ruleName,
                        priority,
                        conditions,
                        cooldownMinutes,
                        enabled: true,
                        action: { workMode, durationMinutes, fdPwr, fdSoc, minSocOnGrid, maxSoc }
                    })
                });
                const data = await resp.json();
                
                if (data.errno === 0) {
                    closeAddRuleModal();
                    loadBackendAutomationStatus();
                } else {
                    alert('Failed to ' + (editingId ? 'update' : 'create') + ' rule: ' + (data.error || 'Unknown error'));
                }
            } catch (e) {
                alert('Error ' + (editingId ? 'updating' : 'creating') + ' rule: ' + e.message);
            }
        }
        
        async function testNewRule() {
            // Test the rule with current live data (dry run)
            alert('Testing rule with current live data... Check the /test.html page for detailed testing.');
            window.open('/test.html', '_blank');
        }
        
        // Edit an existing rule - opens modal with pre-filled values
        async function editBackendRule(ruleName) {
            try {
                const resp = await authenticatedFetch('/api/automation/status');
                const data = await resp.json();
                const rule = data.result?.rules?.[ruleName];
                if (!rule) {
                    alert('Rule not found');
                    return;
                }
                
                // Open the add modal
                showAddRuleModal();
                
                // Wait for modal to render
                await new Promise(r => setTimeout(r, 50));
                
                // Change modal title
                const modalTitle = document.querySelector('#addRuleModal h3');
                if (modalTitle) modalTitle.innerHTML = '‚úèÔ∏è Edit Automation Rule';
                
                // Set editing flag
                document.getElementById('editingRuleId').value = ruleName;
                
                // Fill in basic info
                document.getElementById('newRuleName').value = rule.name || ruleName;
                document.getElementById('newRulePriority').value = rule.priority || 5;
                document.getElementById('newRuleCooldown').value = rule.cooldownMinutes || 5;
                
                // Fill in conditions
                const conditions = rule.conditions || {};
                if (conditions.feedInPrice) {
                    document.getElementById('condFeedInEnabled').checked = conditions.feedInPrice.enabled || false;
                    document.getElementById('condFeedInOp').value = conditions.feedInPrice.operator || '>';
                    document.getElementById('condFeedInVal').value = conditions.feedInPrice.value || 0;
                }
                if (conditions.buyPrice) {
                    document.getElementById('condBuyEnabled').checked = conditions.buyPrice.enabled || false;
                    document.getElementById('condBuyOp').value = conditions.buyPrice.operator || '<';
                    document.getElementById('condBuyVal').value = conditions.buyPrice.value || 0;
                }
                if (conditions.soc) {
                    document.getElementById('condSocEnabled').checked = conditions.soc.enabled || false;
                    document.getElementById('condSocOp').value = conditions.soc.operator || '>';
                    document.getElementById('condSocVal').value = conditions.soc.value || 50;
                }
                if (conditions.temperature) {
                    document.getElementById('condTempEnabled').checked = conditions.temperature.enabled || false;
                    document.getElementById('condTempType').value = conditions.temperature.type || 'battery';
                    document.getElementById('condTempOp').value = conditions.temperature.operator || '<';
                    document.getElementById('condTempVal').value = conditions.temperature.value || 40;
                }
                const timeCondition = conditions.time || conditions.timeWindow;
                // Use querySelector scoped to the addRuleModal to avoid conflicts with the old ruleModal
                const modal = document.getElementById('addRuleModal');
                if (timeCondition && modal) {
                    const timeEnabledEl = modal.querySelector('#condTimeEnabled');
                    const timeStartEl = modal.querySelector('#condTimeStart');
                    const timeEndEl = modal.querySelector('#condTimeEnd');
                    
                    if (timeEnabledEl) timeEnabledEl.checked = timeCondition.enabled || false;
                    if (timeStartEl) timeStartEl.value = timeCondition.startTime || timeCondition.start || '06:00';
                    if (timeEndEl) timeEndEl.value = timeCondition.endTime || timeCondition.end || '18:00';
                }
                
                // Fill in action
                const action = rule.action || {};
                document.getElementById('newRuleWorkMode').value = action.workMode || 'SelfUse';
                document.getElementById('newRuleDuration').value = action.durationMinutes || 30;
                document.getElementById('newRuleFdPwr').value = action.fdPwr || 0;
                document.getElementById('newRuleFdSoc').value = action.fdSoc || 10;
                document.getElementById('newRuleMinSoc').value = action.minSocOnGrid || 10;
                document.getElementById('newRuleMaxSoc').value = action.maxSoc || 100;
                
                // Change button text
                const createBtn = document.querySelector('#addRuleModal button[onclick="createBackendRule()"]');
                if (createBtn) createBtn.textContent = 'Save Changes';
            } catch (e) {
                alert('Error loading rule: ' + e.message);
            }
        }
        
        async function deleteBackendRule(ruleName) {
            if (!confirm(`Delete rule "${ruleName}"? This cannot be undone.`)) return;
            
            try {
                const resp = await authenticatedFetch('/api/automation/rule/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ruleName })
                });
                const data = await resp.json();
                
                if (data.errno === 0) {
                    loadBackendAutomationStatus();
                } else {
                    alert('Failed to delete rule: ' + (data.error || 'Unknown error'));
                }
            } catch (e) {
                alert('Error deleting rule: ' + e.message);
            }
        }

        // Toggle backend automation on/off
        async function toggleBackendAutomation() {
            try {
                const statusResp = await authenticatedFetch('/api/automation/status');
                const statusData = await statusResp.json();
                const currentEnabled = statusData.result?.enabled || false;
                
                const resp = await authenticatedFetch('/api/automation/enable', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: !currentEnabled })
                });
                const data = await resp.json();
                if (data.errno === 0) {
                    loadBackendAutomationStatus();
                }
            } catch (e) {
                console.error('Failed to toggle backend automation:', e);
            }
        }

        // Update a backend rule setting
        async function updateBackendRule(ruleName, field, value) {
            try {
                const body = { ruleName };
                body[field] = field === 'enabled' ? !!value : (field === 'threshold' ? parseFloat(value) : parseInt(value));
                
                const resp = await authenticatedFetch('/api/automation/rule/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const data = await resp.json();
                if (data.errno === 0) {
                    console.log(`Rule ${ruleName} updated:`, data.result);
                    // Refresh UI to show current state
                    loadBackendAutomationStatus();
                }
            } catch (e) {
                console.error('Failed to update backend rule:', e);
            }
        }

        // Update a backend rule action parameter
        async function updateBackendRuleAction(ruleName, field, value) {
            try {
                const body = { 
                    ruleName,
                    action: {}
                };
                // Parse value appropriately
                if (field === 'workMode') {
                    body.action[field] = value;
                } else {
                    body.action[field] = parseInt(value, 10);
                }
                
                const resp = await authenticatedFetch('/api/automation/rule/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const data = await resp.json();
                if (data.errno === 0) {
                    console.log(`Rule ${ruleName} action updated:`, data.result);
                }
            } catch (e) {
                console.error('Failed to update backend rule action:', e);
            }
        }

        // Test trigger a backend rule manually
        async function testBackendRule(ruleName) {
            if (!confirm(`Manually trigger the "${ruleName}" rule? This will immediately apply the automation action.`)) return;
            
            try {
                const resp = await authenticatedFetch('/api/automation/trigger', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ruleName })
                });
                const data = await resp.json();
                
                // Show result
                const resultEl = document.getElementById('result');
                const statusBar = document.getElementById('status-bar');
                if (panelCollapsed) togglePanel();
                statusBar.style.display = 'flex';
                statusBar.querySelector('.endpoint').textContent = `Automation Trigger - ${ruleName}`;
                resultEl.className = data.errno === 0 ? 'success' : 'error';
                resultEl.textContent = JSON.stringify(data, null, 2);
                
                // Reload status to show updated lastTriggered
                loadBackendAutomationStatus();
                // Also reload scheduler to see the changes
                setTimeout(loadSchedulerSegments, 1000);
            } catch (e) {
                console.error('Failed to trigger rule:', e);
                alert('Failed to trigger rule: ' + e.message);
            }
        }

        // Reset backend automation cooldowns
        async function resetBackendAutomation() {
            try {
                const resp = await authenticatedFetch('/api/automation/reset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await resp.json();
                if (data.errno === 0) {
                    loadBackendAutomationStatus();
                }
            } catch (e) {
                console.error('Failed to reset automation:', e);
            }
        }

        function saveAutomationRules() {
            try {
                localStorage.setItem('automationRules', JSON.stringify(automationRules));
                localStorage.setItem('automationEnabled', automationEnabled.toString());
            } catch (e) {
                console.error('Failed to save automation rules:', e);
            }
        }

        function toggleAutomation() {
            automationEnabled = !automationEnabled;
            saveAutomationRules();
            updateAutomationToggle();
        }

        function updateAutomationToggle() {
            // Some builds may not include the legacy DOM elements (automationToggle, automationStatusText)
            // guard access so missing nodes do not throw and break the rest of the page JS.
            const toggle = document.getElementById('automationToggle');
            const text = document.getElementById('automationStatusText');

            if (toggle) {
                try {
                    if (automationEnabled) toggle.classList.add('active');
                    else toggle.classList.remove('active');
                } catch (e) { console.warn('updateAutomationToggle toggle update failed:', e); }
            }

            if (text) {
                try {
                    text.textContent = automationEnabled ? 'Enabled' : 'Disabled';
                    if (automationEnabled) text.classList.add('active');
                    else text.classList.remove('active');
                } catch (e) { console.warn('updateAutomationToggle text update failed:', e); }
            }
        }

        function renderRules() {
            const container = document.getElementById('rulesContainer');
            const emptyMsg = document.getElementById('emptyRulesMessage');
            
            if (!container) return;

            // Clear existing rule cards (keep empty message and add button)
            const existingCards = container.querySelectorAll('.rule-card');
            existingCards.forEach(card => card.remove());
            
            if (automationRules.length === 0) {
                emptyMsg.style.display = 'block';
            } else {
                emptyMsg.style.display = 'none';
                
                // Sort by priority
                const sortedRules = [...automationRules].sort((a, b) => (a.priority || 3) - (b.priority || 3));
                
                sortedRules.forEach(rule => {
                    const card = createRuleCard(rule);
                    container.insertBefore(card, container.querySelector('.add-rule-card'));
                });
            }
        }

        function createRuleCard(rule) {
            const card = document.createElement('div');
            card.className = `rule-card ${rule.enabled === false ? 'disabled' : ''}`;
            card.dataset.ruleId = rule.id;
            
            // Build conditions display
            let conditionsHtml = '';
            if (rule.conditions) {
                if (rule.conditions.price && rule.conditions.price.enabled) {
                    const p = rule.conditions.price;
                    const typeLabel = p.type === 'feedin' ? 'Feed-in' : 'Buy';
                    let valueStr = p.op === 'between' ? `${p.value}¬¢ - ${p.value2}¬¢` : `${p.op} ${p.value}¬¢`;
                    conditionsHtml += `<span class="condition-tag price">üí∞ ${typeLabel} ${valueStr}</span>`;
                }
                if (rule.conditions.soc && rule.conditions.soc.enabled) {
                    const s = rule.conditions.soc;
                    let valueStr = s.op === 'between' ? `${s.value}% - ${s.value2}%` : `${s.op} ${s.value}%`;
                    conditionsHtml += `<span class="condition-tag soc">üîã SoC ${valueStr}</span>`;
                }
                if (rule.conditions.temp && rule.conditions.temp.enabled) {
                    const t = rule.conditions.temp;
                    let valueStr = t.op === 'between' ? `${t.value}¬∞C - ${t.value2}¬∞C` : `${t.op} ${t.value}¬∞C`;
                    conditionsHtml += `<span class="condition-tag temp">üå°Ô∏è Temp ${valueStr}</span>`;
                }
                if (rule.conditions.weather && rule.conditions.weather.enabled) {
                    const w = rule.conditions.weather;
                    conditionsHtml += `<span class="condition-tag weather">üå§Ô∏è ${w.type || 'Any'}</span>`;
                }
                if (rule.conditions.time && rule.conditions.time.enabled) {
                    const tm = rule.conditions.time;
                    conditionsHtml += `<span class="condition-tag weather">üïê ${tm.start} - ${tm.end}</span>`;
                }
            }
            if (!conditionsHtml) {
                conditionsHtml = '<span style="color:#6e7681;font-size:12px">No conditions set</span>';
            }
            
            // Build actions display
            let actionsHtml = '';
            if (rule.action) {
                if (rule.action.workMode) {
                    const modeClass = rule.action.workMode === 'ForceCharge' ? 'charge' : 
                                     rule.action.workMode === 'ForceDischarge' ? 'discharge' : 
                                     rule.action.workMode === 'Feedin' ? 'feedin' : '';
                    actionsHtml += `<span class="action-tag ${modeClass}">‚ö° ${rule.action.workMode}</span>`;
                }
                if (rule.action.minSoC) {
                    actionsHtml += `<span class="action-tag">Min ${rule.action.minSoC}%</span>`;
                }
                if (rule.action.maxSoC) {
                    actionsHtml += `<span class="action-tag">Max ${rule.action.maxSoC}%</span>`;
                }
            }
            if (!actionsHtml) {
                actionsHtml = '<span style="color:#6e7681;font-size:12px">No action set</span>';
            }
            
            card.innerHTML = `
                <div class="rule-card-header">
                    <div class="rule-card-title">
                        <span style="font-size:11px;color:#8b949e;background:rgba(0,0,0,0.3);padding:2px 6px;border-radius:4px">P${rule.priority || 3}</span>
                        ${rule.name || 'Unnamed Rule'}
                    </div>
                    <div class="rule-card-actions">
                        <button onclick="toggleRuleEnabled('${rule.id}')" title="${rule.enabled !== false ? 'Disable' : 'Enable'}">
                            ${rule.enabled !== false ? '‚úì' : '‚óã'}
                        </button>
                        <button onclick="editRule('${rule.id}')" title="Edit">‚úèÔ∏è</button>
                        <button class="delete" onclick="deleteRule('${rule.id}')" title="Delete">üóëÔ∏è</button>
                    </div>
                </div>
                <div class="rule-card-body">
                    <div class="rule-conditions">
                        <div class="rule-section-label">üìã When</div>
                        <div>${conditionsHtml}</div>
                    </div>
                    <div class="rule-actions-box">
                        <div class="rule-section-label">‚ö° Then</div>
                        <div>${actionsHtml}</div>
                    </div>
                </div>
            `;
            
            return card;
        }

        function openRuleModal(ruleId = null) {
            const modal = document.getElementById('ruleModal');
            const title = document.getElementById('ruleModalTitle');
            const form = document.getElementById('ruleForm');
            
            // Reset form
            form.reset();
            document.getElementById('ruleId').value = '';
            
            // Reset all condition items
            ['Price', 'SoC', 'Temp', 'Weather', 'Time'].forEach(cond => {
                document.getElementById(`cond${cond}Enabled`).checked = false;
                document.getElementById(`condition${cond}`).classList.remove('active');
            });
            
            // Hide "between" value2 fields
            ['condPriceValue2Row', 'condSoCValue2Row', 'condTempValue2Row'].forEach(id => {
                document.getElementById(id).style.display = 'none';
            });
            
            if (ruleId) {
                // Edit existing rule
                title.textContent = 'Edit Automation Rule';
                const rule = automationRules.find(r => r.id === ruleId);
                if (rule) {
                    populateRuleForm(rule);
                }
            } else {
                title.textContent = 'Create Automation Rule';
            }
            
            modal.classList.add('show');
            // Hide floating toggle to avoid it overlapping the modal
            try {
                const t = document.getElementById('automationToggleBtn');
                if (t) t.style.display = 'none';
            } catch (e) {}
        }

        function closeRuleModal() {
            document.getElementById('ruleModal').classList.remove('show');
            try {
                const t = document.getElementById('automationToggleBtn');
                if (t) t.style.display = '';
            } catch (e) {}
        }

        function populateRuleForm(rule) {
            document.getElementById('ruleId').value = rule.id;
            document.getElementById('ruleName').value = rule.name || '';
            document.getElementById('rulePriority').value = rule.priority || 3;
            
            // Populate conditions
            if (rule.conditions) {
                if (rule.conditions.price) {
                    const p = rule.conditions.price;
                    document.getElementById('condPriceEnabled').checked = p.enabled;
                    if (p.enabled) document.getElementById('conditionPrice').classList.add('active');
                    document.getElementById('condPriceType').value = p.type || 'buy';
                    document.getElementById('condPriceOp').value = p.op || '<';
                    document.getElementById('condPriceValue').value = p.value || '';
                    if (p.op === 'between') {
                        document.getElementById('condPriceValue2Row').style.display = 'flex';
                        document.getElementById('condPriceValue2').value = p.value2 || '';
                    }
                }
                if (rule.conditions.soc) {
                    const s = rule.conditions.soc;
                    document.getElementById('condSoCEnabled').checked = s.enabled;
                    if (s.enabled) document.getElementById('conditionSoC').classList.add('active');
                    document.getElementById('condSoCOp').value = s.op || '<';
                    document.getElementById('condSoCValue').value = s.value || '';
                    if (s.op === 'between') {
                        document.getElementById('condSoCValue2Row').style.display = 'flex';
                        document.getElementById('condSoCValue2').value = s.value2 || '';
                    }
                }
                if (rule.conditions.temp) {
                    const t = rule.conditions.temp;
                    document.getElementById('condTempEnabled').checked = t.enabled;
                    if (t.enabled) document.getElementById('conditionTemp').classList.add('active');
                    document.getElementById('condTempOp').value = t.op || '<';
                    document.getElementById('condTempValue').value = t.value || '';
                    if (t.op === 'between') {
                        document.getElementById('condTempValue2Row').style.display = 'flex';
                        document.getElementById('condTempValue2').value = t.value2 || '';
                    }
                }
                if (rule.conditions.weather) {
                    const w = rule.conditions.weather;
                    document.getElementById('condWeatherEnabled').checked = w.enabled;
                    if (w.enabled) document.getElementById('conditionWeather').classList.add('active');
                    document.getElementById('condWeatherType').value = w.type || 'any';
                    document.getElementById('condWeatherSolarOp').value = w.solarOp || 'any';
                    document.getElementById('condWeatherSolarValue').value = w.solarValue || '';
                }
                if (rule.conditions.time) {
                    const tm = rule.conditions.time;
                    document.getElementById('condTimeEnabled').checked = tm.enabled;
                    if (tm.enabled) document.getElementById('conditionTime').classList.add('active');
                    document.getElementById('condTimeStart').value = tm.start || '00:00';
                    document.getElementById('condTimeEnd').value = tm.end || '23:59';
                }
            }
            
            // Populate actions
            if (rule.action) {
                document.getElementById('actionWorkMode').value = rule.action.workMode || '';
                document.getElementById('actionMinSoC').value = rule.action.minSoC || '';
                document.getElementById('actionMaxSoC').value = rule.action.maxSoC || '';
                document.getElementById('actionFdPwr').value = rule.action.fdPwr || '';
            }
        }

        function toggleCondition(condName) {
            const checkbox = document.getElementById(`cond${condName}Enabled`);
            const item = document.getElementById(`condition${condName}`);
            if (!item || !checkbox) return;
            
            if (checkbox.checked) {
                item.classList.add('active');
            } else {
                item.classList.remove('active');
            }
        }

        // Handle operator change to show/hide between value2 field
        document.addEventListener('DOMContentLoaded', () => {
            ['Price', 'SoC', 'Temp'].forEach(cond => {
                const opSelect = document.getElementById(`cond${cond}Op`);
                const value2Row = document.getElementById(`cond${cond}Value2Row`);
                if (opSelect && value2Row) {
                    opSelect.addEventListener('change', () => {
                        value2Row.style.display = opSelect.value === 'between' ? 'flex' : 'none';
                    });
                }
            });
            // Allow pressing Enter in the location input to trigger Get Forecast
            try {
                const wInput = document.getElementById('weatherPlace');
                if (wInput) {
                    wInput.addEventListener('keydown', (ev) => {
                        if (ev.key === 'Enter') {
                            ev.preventDefault();
                            try { getWeather(); } catch(e) { /* ignore */ }
                        }
                    });
                }
            } catch(e) { /* ignore */ }
        });

        function saveRule() {
            const ruleId = document.getElementById('ruleId').value;
            const ruleName = document.getElementById('ruleName').value.trim();
            
            if (!ruleName) {
                alert('Please enter a rule name');
                return;
            }
            
            const rule = {
                id: ruleId || 'rule_' + Date.now(),
                name: ruleName,
                enabled: true,
                priority: parseInt(document.getElementById('rulePriority').value) || 3,
                conditions: {
                    price: {
                        enabled: document.getElementById('condPriceEnabled').checked,
                        type: document.getElementById('condPriceType').value,
                        op: document.getElementById('condPriceOp').value,
                        value: parseFloat(document.getElementById('condPriceValue').value) || null,
                        value2: parseFloat(document.getElementById('condPriceValue2').value) || null
                    },
                    soc: {
                        enabled: document.getElementById('condSoCEnabled').checked,
                        op: document.getElementById('condSoCOp').value,
                        value: parseInt(document.getElementById('condSoCValue').value) || null,
                        value2: parseInt(document.getElementById('condSoCValue2').value) || null
                    },
                    temp: {
                        enabled: document.getElementById('condTempEnabled').checked,
                        op: document.getElementById('condTempOp').value,
                        value: parseInt(document.getElementById('condTempValue').value) || null,
                        value2: parseInt(document.getElementById('condTempValue2').value) || null
                    },
                    weather: {
                        type: document.getElementById('condWeatherType').value,
                        solarOp: document.getElementById('condWeatherSolarOp').value,
                        solarValue: parseFloat(document.getElementById('condWeatherSolarValue').value) || null
                    },
                    time: {
                        enabled: document.getElementById('condTimeEnabled').checked,
                        start: document.getElementById('condTimeStart').value,
                        end: document.getElementById('condTimeEnd').value
                    }
                },
                action: {
                    workMode: document.getElementById('actionWorkMode').value || null,
                    minSoC: parseInt(document.getElementById('actionMinSoC').value) || null,
                    maxSoC: parseInt(document.getElementById('actionMaxSoC').value) || null,
                    fdPwr: parseInt(document.getElementById('actionFdPwr').value) || null
                }
            };
            
            // Validate at least one action
            if (!rule.action.workMode && !rule.action.minSoC && !rule.action.maxSoC) {
                alert('Please configure at least one action (Work Mode or SoC limits)');
                return;
            }
            
            // Update or add rule
            if (ruleId) {
                const idx = automationRules.findIndex(r => r.id === ruleId);
                if (idx !== -1) {
                    rule.enabled = automationRules[idx].enabled; // Preserve enabled state
                    automationRules[idx] = rule;
                }
            } else {
                automationRules.push(rule);
            }
            
            saveAutomationRules();
            renderRules();
            closeRuleModal();
        }

        function editRule(ruleId) {
            openRuleModal(ruleId);
        }

        function deleteRule(ruleId) {
            if (!confirm('Delete this rule?')) return;
            automationRules = automationRules.filter(r => r.id !== ruleId);
            saveAutomationRules();
            renderRules();
        }

        function toggleRuleEnabled(ruleId) {
            const rule = automationRules.find(r => r.id === ruleId);
            if (rule) {
                rule.enabled = rule.enabled === false ? true : false;
                saveAutomationRules();
                renderRules();
            }
        }

        AppShell.init({
            pageName: 'overview',
            autoMetrics: false,
            onReady: () => {
                try { initializePageData(); } catch (err) { console.error('Failed to initialize dashboard', err); }
            }
        });
    </script>
</body>
</html>
