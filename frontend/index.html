<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FoxESS Automation</title>
    <link rel="manifest" href="/manifest.webmanifest">
    <link rel="apple-touch-icon" href="/icons/apple-touch-icon.png">
    <meta name="theme-color" content="#0d1117">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="FoxESS Automation">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics-compat.js"></script>
    <!-- Firebase Auth Configuration -->
    <script src="js/firebase-config.js"></script>
    <script src="js/firebase-auth.js"></script>
    <script src="js/api-client.js"></script>
    <script src="js/shared-utils.js"></script>
    <script src="js/app-shell.js?v=9"></script>
    <script src="js/tour.js?v=8"></script>
    <script src="js/theme-init.js"></script>
    <link rel="stylesheet" href="css/shared-styles.css?v=7" />
    <link rel="stylesheet" href="css/tour.css" />
    <style>
        
        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 14px;
            background: color-mix(in srgb, var(--bg-primary) 80%, transparent);
            border-bottom: 1px solid var(--border-secondary);
            backdrop-filter: blur(8px);
            margin: 6px 0 10px 0;
        }
        .header h1 {
            font-size: 1.15rem;
            font-weight: 600;
            color: var(--accent-blue);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .header h1 .logo {
            font-size: 1.25rem;
        }

        .auth-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100dvh;
            flex-direction: column;
            gap: 16px;
        }
        .auth-loading .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid color-mix(in srgb, var(--accent-blue) 20%, transparent);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Main Layout */
        .main-layout {
            display: flex;
            height: calc(100dvh - 65px);
        }
        .left-panel {
            flex: 1;
            padding: 14px;
            /* Allow child panels to manage their own scrolling. This prevents the
               left-panel's scrollbar from capturing scroll events intended for the
               automation panel's internal scroller (FAQ worked because it set its
               inner card-body to scroll). */
            overflow-y: visible;
            transition: margin-right 0.3s ease;
        }
        .left-panel.panel-open {
            margin-right: 0;
        }

        /* Priority Row - Weather, Prices, Inverter */
        .priority-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }
        @media (max-width: 900px) {
            .priority-row {
                grid-template-columns: 1fr;
            }
        }

        .dashboard-visibility-card {
            margin-bottom: 10px;
        }
        .dashboard-visibility-card .card-header {
            padding: 10px 14px;
            gap: 10px;
            flex-wrap: nowrap;
            justify-content: flex-start;
        }
        .dashboard-visibility-inline {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-left: 8px;
            flex: 1;
            justify-content: space-evenly;
            flex-wrap: nowrap;
            overflow-x: auto;
            scrollbar-width: thin;
        }
        .card-visibility-toggle {
            display: inline-flex;
            align-items: center;
            gap: 7px;
            font-size: 12px;
            color: var(--text-primary);
            user-select: none;
            white-space: nowrap;
        }
        .card-visibility-toggle input {
            appearance: none;
            -webkit-appearance: none;
            width: 40px;
            height: 22px;
            border-radius: 999px;
            border: 1px solid var(--border-primary);
            background: var(--bg-tertiary);
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            cursor: pointer;
        }
        .card-visibility-toggle input::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--text-primary);
            transition: transform 0.2s ease;
        }
        .dashboard-visibility-collapse-btn {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 999px;
            border: 1px solid var(--border-primary);
            background: color-mix(in srgb, var(--bg-primary) 80%, transparent);
            color: var(--text-primary);
            font-size: 11px;
            cursor: pointer;
            margin-left: auto;
        }
        .card-visibility-toggle input:checked {
            background: var(--color-success-dark);
            border-color: var(--color-success);
        }
        .card-visibility-toggle input:checked::after {
            transform: translateX(18px);
        }
        @media (max-width: 900px) {
            .dashboard-visibility-card .card-header {
                padding: 8px 10px;
                gap: 8px;
                flex-direction: row;
                align-items: center;
                flex-wrap: nowrap;
            }
            .dashboard-visibility-collapse-btn {
                display: inline-flex;
            }
            .dashboard-visibility-inline {
                margin-left: 0;
                width: 100%;
                flex: 1 1 100%;
                flex-wrap: wrap;
                overflow: hidden;
                gap: 8px 10px;
                justify-content: space-between;
                display: none;
                padding-top: 8px;
            }
            .card-visibility-toggle {
                font-size: 11px;
                flex: 1 1 calc(50% - 8px);
            }
            .dashboard-visibility-card.mobile-expanded .card-header {
                flex-wrap: wrap;
                align-items: flex-start;
            }
            .dashboard-visibility-card.mobile-expanded .dashboard-visibility-inline {
                display: flex;
            }
        }
        .is-hidden-preference {
            display: none !important;
        }

        /* Priority Badge for Automation Rules */
        .priority-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            min-width: 24px;
        }

        /* Priority color scale: Red (P1) → Orange → Yellow → Green (P10) */
        .priority-badge.p1 { background: #ff4757; color: #fff; } /* P1: Critical Red */
        .priority-badge.p2 { background: #ff6b6b; color: #fff; } /* P2: Red */
        .priority-badge.p3 { background: #ff8c42; color: #fff; } /* P3: Red-Orange */
        .priority-badge.p4 { background: #ffa24d; color: #000; } /* P4: Orange-Red */
        .priority-badge.p5 { background: #ffb84d; color: #000; } /* P5: Orange */
        .priority-badge.p6 { background: #ffd43b; color: #000; } /* P6: Yellow-Orange */
        .priority-badge.p7 { background: #ffe066; color: #000; } /* P7: Yellow */
        .priority-badge.p8 { background: #a8d400; color: #000; } /* P8: Lime */
        .priority-badge.p9 { background: #69db4d; color: #000; } /* P9: Light Green */
        .priority-badge.p10 { background: #51cf66; color: #000; } /* P10: Green */
        .priority-badge.p-low { background: var(--bg-tertiary); color: var(--text-secondary); } /* P>10: Very low / Gray */

        /* Secondary Grid */
        .secondary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 16px;
        }

        /* Cards */
        .card {
            background: var(--gradient-card);
            border-radius: 12px;
            border: 1px solid var(--border-secondary);
            overflow: hidden;
            transition: all 0.2s ease;
        }
        .card:hover {
            border-color: color-mix(in srgb, var(--accent-blue) 30%, transparent);
            box-shadow: 0 8px 32px var(--shadow-lg);
        }
        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 18px;
            background: var(--bg-overlay);
            border-bottom: 1px solid color-mix(in srgb, var(--border-primary) 40%, transparent);
        }
        .card-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .card-title .icon {
            font-size: 18px;
        }
        .card-badge {
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 12px;
            background: color-mix(in srgb, var(--accent-blue) 15%, transparent);
            color: var(--accent-blue);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .card-body {
            padding: 16px 18px;
        }

        /* Priority Card Variants */
        .card.priority {
            border-color: color-mix(in srgb, var(--accent-blue) 20%, transparent);
        }
        .card.priority .card-header {
            background: linear-gradient(135deg, color-mix(in srgb, var(--accent-blue) 8%, transparent), transparent);
        }

        /* Buttons */
        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 14px;
            background: var(--bg-card);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
            margin-bottom: 6px;
        }
        .btn:hover {
            background: var(--border-primary);
            border-color: color-mix(in srgb, var(--accent-blue) 40%, transparent);
            transform: translateY(-1px);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn-primary {
            background: var(--gradient-success);
            border-color: var(--color-success-dark);
        }
        .btn-primary:hover {
            background: var(--gradient-success);
            filter: brightness(1.1);
            border-color: var(--color-success);
        }
        .btn-sm {
            padding: 8px 12px;
            font-size: 12px;
        }
        .btn-icon {
            width: auto;
            padding: 8px 12px;
        }

        /* Inputs */
        .input {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-input);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            transition: all 0.2s ease;
        }
        .input:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px var(--accent-blue-bg);
        }
        
        /* Range Slider Styling */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: linear-gradient(to right, var(--color-success-dark) 0%, var(--accent-blue) 50%, var(--color-orange) 100%);
            border-radius: 4px;
            outline: none;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-blue);
            border: 2px solid var(--bg-primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px color-mix(in srgb, var(--accent-blue) 50%, transparent);
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: color-mix(in srgb, var(--accent-blue) 80%, white);
            box-shadow: 0 0 12px color-mix(in srgb, var(--accent-blue) 80%, transparent);
            transform: scale(1.1);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--accent-blue);
            border: 2px solid var(--bg-primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px color-mix(in srgb, var(--accent-blue) 50%, transparent);
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-moz-range-thumb:hover {
            background: color-mix(in srgb, var(--accent-blue) 80%, white);
            box-shadow: 0 0 12px color-mix(in srgb, var(--accent-blue) 80%, transparent);
            transform: scale(1.1);
        }
        .input::placeholder {
            color: var(--text-placeholder);
        }
        .input-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        .input-group {
            flex: 1;
        }
        .input-group label {
            display: block;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        select.input {
            cursor: pointer;
        }

        /* Data Display Cards */
        .data-card {
            background: var(--bg-input);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
            min-height: 80px;
        }
        .data-card.success {
            border-left: 3px solid var(--color-success-dark);
        }
        .data-card.info {
            border-left: 3px solid var(--accent-blue);
        }

        #inverterCard {
            border-left: none !important;
        }

        /* Live Data Display */
        .live-stat {
            display: flex;
            align-items: baseline;
            gap: 8px;
            padding: 8px 0;
        }
        .live-stat .value {
            font-size: 28px;
            font-weight: 700;
            color: var(--accent-blue);
        }
        .live-stat .unit {
            font-size: 14px;
            color: var(--text-secondary);
        }
        .live-stat .label {
            font-size:12px;
            color: var(--text-secondary);
            margin-left: 6px;
        }
        .stat-row {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }
        .stat-item {
            flex: 1;
            min-width: 100px;
            padding: 12px;
            background: var(--bg-input);
            border-radius: 8px;
            text-align: center;
            position: relative;
        }
        .stat-item .value {
            font-size: 20px;
            font-weight: 600;
            color: var(--color-terminal-text);
        }
        /* Smaller inline status (e.g. "(discharging)") shown next to main value */
        .stat-item .value .substatus {
            font-size: 0.55em;
            font-weight: 400;
            color: var(--text-secondary);
            margin-left: 6px;
            vertical-align: baseline;
        }
        .stat-item .label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 4px;
        }
        .stat-item .tile-icon {
            font-size: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 6px auto;
            width: 54px;
            height: 54px;
            border-radius: 6px;
            color: inherit;
            background: rgba(255,255,255,0.02);
            position: relative;
        }
        /* Curtailment badge on solar tile */
        .stat-item.curtailed .tile-icon::after {
            content: '';
            position: absolute;
            top: -2px;
            right: -2px;
            width: 14px;
            height: 14px;
            background: radial-gradient(circle, #ff6b35 0%, #f0883e 100%);
            border-radius: 50%;
            border: 2px solid rgba(13, 17, 23, 0.95);
            box-shadow: 0 0 8px rgba(255, 107, 53, 0.6), inset 0 0 3px rgba(255, 255, 255, 0.3);
            animation: curtailment-pulse 2s ease-in-out infinite;
        }
        @keyframes curtailment-pulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 8px rgba(255, 107, 53, 0.6), inset 0 0 3px rgba(255, 255, 255, 0.3);
            }
            50% { 
                transform: scale(1.15);
                box-shadow: 0 0 12px rgba(255, 107, 53, 0.8), inset 0 0 4px rgba(255, 255, 255, 0.4);
            }
        }
        /* Border glow effect when curtailed */
        .stat-item.curtailed {
            border: 1px solid rgba(255, 107, 53, 0.4);
            background: linear-gradient(135deg, rgba(13, 17, 23, 0.5), rgba(22, 27, 34, 0.6));
            box-shadow: inset 0 0 12px rgba(255, 107, 53, 0.08), 0 0 16px rgba(255, 107, 53, 0.12);
        }
        /* Thermometer variant: 50% size of default tile icons */
        .tile-icon.thermometer {
            width: 27px;
            height: 27px;
            padding: 2px 0 0 0;
            background: transparent;
        }
        .tile-icon.thermometer .therm-svg { width: 18px; height: 36px; display:block; }
        .therm-fill { transition: height 600ms cubic-bezier(.2,.9,.2,1), y 600ms cubic-bezier(.2,.9,.2,1), fill 300ms ease; }
        /* Battery SVG sizing and charging animation */
        /* Larger battery tile for improved alignment */
        .stat-item.battery-tile { min-width: 180px; padding: 12px 18px; display:flex; flex-direction:column; align-items:center; justify-content:center; }
        .tile-icon.battery { width: 54px; height: 60px; padding-top: 2px; }
        .tile-icon.battery svg { width: 36px; height: 52px; display:block; }
        .tile-icon.battery .level { transition: all 600ms cubic-bezier(.2,.9,.2,1); }
        .tile-icon.battery.charging { box-shadow: 0 6px 18px rgba(88,166,255,0.12); }
        .tile-icon.battery.charging svg { filter: drop-shadow(0 4px 8px rgba(88,166,255,0.18)); }
        @keyframes batt-pulse { 0% { opacity: 0.95 } 50% { opacity: 1 } 100% { opacity: 0.95 } }
        .tile-icon.battery.charging { animation: batt-pulse 1.2s infinite ease-in-out; }
        .stat-item.warning .value { color: var(--color-warning); }
        .stat-item.danger .value { color: var(--color-danger); }

        /* Extreme daily forecast tiles (stronger amber tint for visibility) */
        .stat-item.extreme {
            border: 1px solid rgba(255,176,32,0.45);
            background: linear-gradient(180deg, rgba(255,176,32,0.14), rgba(22,27,34,0.60));
            box-shadow: 0 8px 28px rgba(255,176,32,0.12), inset 0 1px 0 rgba(255,255,255,0.02);
        }

        /* Weather days specific layout: override default .stat-item flex for day tiles */
        .weather-days {
            display:flex;
            gap:6px;
            flex-wrap:wrap;
            margin-top:10px;
        }
        .weather-days .stat-item {
            box-sizing: border-box;
            /* Allow forecast tiles to grow slightly so the last row doesn't leave
               a large empty gap when there are many items. Also restrict maximum
               width so items remain card-like on very wide screens. */
            flex: 1 1 140px;
            max-width: 180px;
            min-width: 0;
            padding: 8px;
            text-align: left;
            position: relative; /* allow icon overlay */
        }

        /* Money bag indicator for very large feed-in prices */
        .money-bag {
            display:inline-block;
            font-size:14px;
            margin-left:6px;
            filter: drop-shadow(0 1px 0 rgba(0,0,0,0.6));
            line-height:1;
        }
        @media (max-width: 600px) {
            .weather-days .stat-item { flex: 0 0 120px; }
        }

        /* Price Colors */
        .price-low { color: #7ee787 !important; }
        .price-mid { color: #d29922 !important; }
        .price-high { color: #f85149 !important; }
        .price-neutral { color: #8b949e !important; }
        .price-darkgreen { color: #238636 !important; }

        /* Feed-in highlight for very large export prices (bright green tile) */
        .stat-item.feedin-highlight {
            background: linear-gradient(180deg, #e6ffef, #bff6d4);
            border: 1px solid rgba(34,139,34,0.35);
            box-shadow: 0 8px 20px rgba(34,139,34,0.06);
            color: #053012;
        }
        .stat-item.feedin-highlight .value { color: #053012 !important; }

        /* Button Grid */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }
        .btn-grid .btn {
            margin-bottom: 0;
        }

        /* Right Panel */
        .right-panel {
            width: 480px;
            min-width: 380px;
            max-width: 600px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-primary);
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease, min-width 0.3s ease;
            position: relative;
            flex-shrink: 0;
        }
        /* Left panel split: main content + automation panel */
        .left-panel {
            display: flex;
            gap: 16px;
            /* Stretch children so the automation panel can fill available height
               and its internal scrollbar becomes reachable when content is long. */
            align-items: stretch;
        }
        .main-content {
            flex: 1 1 auto;
            min-width: 320px;
        }
        .automation-panel {
            width: 520px;
            min-width: 280px;
            max-width: 900px;
            transition: width 0.12s ease;
            display: flex;
            flex-direction: column;
            gap: 12px;
            /* Fixed height panel that doesn't scroll itself; children scroll */
            position: -webkit-sticky;
            position: sticky;
            top: 80px;
            /* Increase the available vertical space by 55% (was 44%, now +11% more) */
            height: calc((100dvh - 100px) * 1.55);
            overflow: hidden; /* panel itself doesn't scroll */
            padding-bottom: 12px;
        }
        .automation-panel.collapsed {
            width: 0 !important;
            min-width: 0 !important;
            overflow: hidden;
            transform: translateX(100%);
        }
        /* Make the Active Automation card expand to fill available space and scroll internally */
        .automation-panel > .card:first-child {
            flex: 1 1 auto;
            min-height: 500px; /* Increased from default to make it taller */
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .automation-panel > .card:first-child > .card-body {
            flex: 1 1 auto;
            min-height: 0;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
            padding-right: 6px;
        }
        /* Keep the FAQ card at fixed small size */
        .automation-panel > .card.faq-card {
            flex: 0 0 auto;
            margin-top: 56px; /* Increased from 32px to push FAQ further down */
        }

        /* FAQ card in automation panel - small default size and scrollable content */
        .automation-panel .faq-card {
            /* Reduced height to make FAQ card smaller */
            max-height: 480px; /* reduced from 728px */
            min-height: 200px; /* reduced from 280px */
            overflow: hidden; /* prevent the FAQ card from expanding the automation panel */
        }
        .automation-panel .faq-card .card-body {
            /* Allow only the inner FAQ area to scroll — height adjusted to match
               the smaller FAQ card container so content inside has more room */
            max-height: calc(480px - 50px); /* account for header height */
            overflow-y: auto;
            padding-right: 6px;
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch;
        }
        /* Force Manual Scheduler into row 2 and span full width */
        .manual-scheduler-card {
            grid-column: 1 / -1 !important; /* take whole row */
            grid-row: 2; /* ensure it is placed on the second row */
        }
        .automation-toggle-btn {
            align-self: center;
            margin-left: -46px;
            margin-top: 190px;
            width: 56px;
            height: 100px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 1px solid rgba(255,255,255,0.15);
            border-left: none;
            border-radius: 16px 0 0 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            font-size: 16px;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 10001;
            box-shadow: 0 10px 40px rgba(102,126,234,0.25), inset 0 1px 0 rgba(255,255,255,0.2);
        }
        @media (max-height: 900px) {
            .automation-toggle-btn { margin-top: 150px; }
        }
        @media (max-height: 700px) {
            .automation-toggle-btn { margin-top: 100px; }
        }
        @media (max-width: 900px) {
            .main-layout {
                display: block;
                height: auto;
            }
            .left-panel {
                display: block;
                padding: 12px;
            }
            .main-content {
                min-width: 0;
                padding-bottom: calc(132px + env(safe-area-inset-bottom));
            }
            .automation-panel {
                width: min(92vw, 460px);
                min-width: 0;
                max-width: 92vw;
                position: fixed;
                top: 118px;
                right: 0;
                height: calc(100dvh - 130px);
                max-height: calc(100dvh - 130px);
                background: var(--bg-secondary);
                border-left: 1px solid var(--border-primary);
                box-shadow: -16px 0 36px var(--shadow-lg);
                z-index: 10001;
                overflow-y: auto;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch;
                transform: translateX(0);
                transition: transform 0.2s ease;
            }
            .automation-panel > .card:first-child {
                flex: 0 0 auto;
                min-height: 0;
                overflow: visible;
            }
            .automation-panel > .card:first-child > .card-body {
                max-height: none;
                overflow-y: visible;
            }
            .automation-panel > .card.faq-card {
                margin-top: 0;
            }
            .automation-panel .faq-card {
                max-height: none;
                overflow: visible;
            }
            .automation-panel .faq-card .card-body {
                max-height: none;
                overflow-y: visible;
            }
            .right-panel {
                display: none !important;
            }
            .toggle-panel {
                display: none !important;
            }
            .panel-resizer {
                display: none !important;
            }
            .automation-toggle-btn {
                display: flex !important;
                position: fixed;
                right: 0;
                top: 52%;
                transform: translateY(-50%);
                margin: 0;
                width: 52px;
                height: 88px;
                border-radius: 14px 0 0 14px;
                z-index: 10002;
            }
            .automation-panel.collapsed {
                transform: translateX(100%);
            }
            .automation-toggle-btn:hover,
            .automation-toggle-btn {
                transform: translateY(-50%);
            }
        }
        .automation-toggle-btn:hover { transform: translateY(-8px); box-shadow: 0 16px 52px rgba(102,126,234,0.35), inset 0 1px 0 rgba(255,255,255,0.2); }
        .automation-toggle-btn:active { transform: translateY(-2px); }

        /* Inline icon & arrow inside the toggle */
        .automation-toggle-btn .automation-toggle-icon { display:flex; align-items:center; justify-content:center; width:38px; height:38px; border-radius:12px; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .automation-toggle-btn .automation-toggle-icon svg { width:28px; height:28px; display:block; }
        .automation-toggle-btn .automation-toggle-arrow { font-size:20px; margin-left:6px; color: rgba(255,255,255,0.9); font-weight: 600; }
        .automation-toggle-btn:hover .automation-toggle-arrow { color: #fff; }
        .panel-resizer {
            width: 20px; /* larger hit area */
            cursor: col-resize;
            touch-action: none; /* allow pointer events to control dragging */
            background: transparent;
            transition: background 0.12s ease;
            align-self: stretch;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999; /* make sure it's on top */
            pointer-events: auto;
        }
        .panel-resizer:hover { background: rgba(88,166,255,0.06); }
        .panel-resizer::before {
            content: '';
            width: 2px;
            height: 48%;
            background: linear-gradient(180deg, rgba(255,255,255,0.15), rgba(255,255,255,0.06));
            border-radius: 3px;
            box-shadow: 0 0 0 1px rgba(255,255,255,0.01) inset;
            opacity: 0.9;
        }
        .right-panel.collapsed {
            width: 0;
            min-width: 0;
            border-left: none;
            overflow: hidden;
        }
        .right-panel.collapsed .result-container {
            display: none;
        }
        .toggle-panel {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 36px;
            height: 72px;
            background: var(--bg-card);
            border: 1px solid var(--border-primary);
            border-right: none;
            border-radius: 8px 0 0 8px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: right 0.3s ease;
            z-index: 1000;
        }
        .toggle-panel:hover {
            background: var(--border-primary);
            color: var(--text-primary);
        }
        .result-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 18px;
            background: var(--bg-overlay);
            border-bottom: 1px solid color-mix(in srgb, var(--border-primary) 40%, transparent);
        }
        .result-header h2 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .header-btns {
            display: flex;
            gap: 8px;
        }
        .header-btns button {
            padding: 6px 12px;
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .copy-btn {
            background: var(--accent-blue-bg);
            color: var(--accent-blue);
        }
        .copy-btn:hover {
            background: color-mix(in srgb, var(--accent-blue) 20%, transparent);
        }
        .clear-btn {
            background: color-mix(in srgb, var(--color-danger) 10%, transparent);
            color: var(--color-danger);
        }
        .clear-btn:hover {
            background: color-mix(in srgb, var(--color-danger) 20%, transparent);
        }
        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 8px 18px;
            background: var(--bg-overlay);
            font-size: 11px;
            border-bottom: 1px solid color-mix(in srgb, var(--border-primary) 20%, transparent);
        }
        .status-bar .endpoint { color: var(--accent-blue); }
        .status-bar .time { color: var(--text-secondary); }
        .result-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px 18px;
        }
        #result {
            background: var(--bg-terminal);
            border-radius: 8px;
            padding: 14px;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 12px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 100%;
            color: var(--text-secondary);
        }
        .success { color: var(--color-success); }
        .error { color: var(--color-danger); }

        /* Resize Handle */
        .resize-handle {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            cursor: ew-resize;
            background: transparent;
        }
        .resize-handle:hover {
            background: color-mix(in srgb, var(--accent-blue) 30%, transparent);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: var(--bg-overlay);
        }
        ::-webkit-scrollbar-thumb {
            background: color-mix(in srgb, var(--accent-blue) 30%, transparent);
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: color-mix(in srgb, var(--accent-blue) 50%, transparent);
        }

        /* Settings Forms */
        .settings-form {
            background: var(--bg-input);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 12px;
            border: 1px solid var(--border-secondary);
            transition: all 0.2s ease;
        }
        .settings-form:hover {
            border-color: var(--border-primary);
        }
        .settings-form .form-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-secondary);
        }
        .settings-form .form-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .settings-form .endpoint-tag {
            font-size: 10px;
            color: var(--text-secondary);
            background: var(--bg-overlay);
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'SF Mono', monospace;
        }
        .settings-form .form-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .settings-form .form-group {
            flex: 1;
        }
        .settings-form .form-group.sm {
            flex: 0 0 70px;
        }
        .settings-form .form-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid color-mix(in srgb, var(--border-primary) 30%, transparent);
        }
        .settings-form .checkbox-row {
            display: flex;
            gap: 12px;
            margin-bottom: 10px;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-overlay);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            color: var(--text-secondary);
            transition: all 0.2s;
        }
        .checkbox-label:hover {
            background: color-mix(in srgb, var(--bg-overlay) 150%, transparent);
            color: var(--text-primary);
        }
        .checkbox-label input {
            accent-color: var(--accent-blue);
        }
        .time-input {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .time-input input {
            width: 50px;
            text-align: center;
        }
        .time-input .sep {
            color: var(--text-placeholder);
            font-weight: bold;
        }

        /* Section Titles */
        .section-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-secondary);
        }

        /* Automation Rules Styles */
        .automation-section {
            margin-top: 20px;
        }
        .automation-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }
        .automation-header h2 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .automation-header h2 .icon {
            font-size: 22px;
        }
        .automation-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .automation-toggle {
            position: relative;
            width: 48px;
            height: 28px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 1.5px solid rgba(255, 255, 255, 0.25);
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        .automation-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.35);
        }
        .automation-toggle.active {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.85));
            border-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3), inset 0 1px 2px rgba(255, 255, 255, 0.5);
        }
        .automation-toggle.active:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35), inset 0 1px 2px rgba(255, 255, 255, 0.5);
        }
        .automation-toggle::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.35);
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: all 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .automation-toggle.active::after {
            left: 24px;
            background: var(--accent-blue);
            box-shadow: 0 2px 6px color-mix(in srgb, var(--accent-blue) 40%, transparent);
        }
        .automation-toggle.active::after:hover {
            box-shadow: 0 2px 8px color-mix(in srgb, var(--accent-blue) 60%, transparent);
        }
        .automation-status-text {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .automation-status-text.active {
            color: var(--color-success);
        }
        .rules-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 16px;
        }
        .rule-card {
            background: var(--gradient-card);
            border-radius: 12px;
            border: 1px solid var(--border-secondary);
            overflow: hidden;
            transition: all 0.2s ease;
        }
        .rule-card:hover {
            border-color: color-mix(in srgb, var(--accent-blue) 30%, transparent);
            box-shadow: 0 8px 32px var(--shadow-lg);
        }
        .rule-card.disabled {
            opacity: 0.6;
        }
        .rule-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: var(--bg-overlay);
            border-bottom: 1px solid var(--border-secondary);
        }
        .rule-card-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .rule-card-actions {
            display: flex;
            gap: 6px;
        }
        .rule-card-actions button {
            padding: 4px 8px;
            background: var(--bg-card);
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        .rule-card-actions button:hover {
            background: var(--border-primary);
            color: var(--text-primary);
        }
        .rule-card-actions button.delete:hover {
            background: color-mix(in srgb, var(--color-danger) 20%, transparent);
            border-color: color-mix(in srgb, var(--color-danger) 40%, transparent);
            color: var(--color-danger);
        }
        .rule-card-body {
            padding: 14px 16px;
        }
        .rule-conditions, .rule-actions-box {
            margin-bottom: 12px;
        }
        .rule-section-label {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .condition-tag, .action-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            margin: 3px;
        }
        .condition-tag {
            background: var(--accent-blue-bg);
            border: 1px solid color-mix(in srgb, var(--accent-blue) 20%, transparent);
            color: var(--accent-blue);
        }
        .condition-tag.price { border-color: color-mix(in srgb, var(--color-success) 30%, transparent); color: var(--color-success); }
        .condition-tag.soc { border-color: color-mix(in srgb, var(--color-purple) 30%, transparent); color: var(--color-purple); }
        .condition-tag.temp { border-color: color-mix(in srgb, var(--color-warning) 30%, transparent); color: var(--color-warning); }
        .condition-tag.weather { border-color: color-mix(in srgb, var(--accent-blue) 30%, transparent); color: var(--accent-blue); }
        .action-tag {
            background: color-mix(in srgb, var(--color-success-dark) 15%, transparent);
            border: 1px solid color-mix(in srgb, var(--color-success-dark) 30%, transparent);
            color: var(--color-success);
        }
        .action-tag.charge { background: color-mix(in srgb, var(--accent-blue) 15%, transparent); border-color: color-mix(in srgb, var(--accent-blue) 30%, transparent); color: var(--accent-blue); }
        .action-tag.discharge { background: color-mix(in srgb, var(--color-orange) 15%, transparent); border-color: color-mix(in srgb, var(--color-orange) 30%, transparent); color: var(--color-orange); }
        .action-tag.feedin { background: color-mix(in srgb, var(--color-warning) 15%, transparent); border-color: color-mix(in srgb, var(--color-warning) 30%, transparent); color: var(--color-warning); }
        
        /* Rule Builder Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            z-index: 11000;
            align-items: center;
            justify-content: center;
        }
        .modal-overlay.show {
            display: flex;
        }
        .modal-content {
            background: var(--gradient-card);
            border: 1px solid var(--border-primary);
            border-radius: 16px;
            width: 90%;
            max-width: 840px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px var(--shadow-lg);
        }
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 18px 24px;
            border-bottom: 1px solid var(--border-secondary);
            background: var(--bg-overlay);
        }
        .modal-header h3 {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .modal-close {
            width: 32px;
            height: 32px;
            border: none;
            background: color-mix(in srgb, var(--border-primary) 60%, transparent);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .modal-close:hover {
            background: color-mix(in srgb, var(--color-danger) 20%, transparent);
            color: var(--color-danger);
        }
        .modal-body {
            padding: 24px;
        }
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 16px 24px;
            border-top: 1px solid var(--border-secondary);
            background: var(--bg-overlay);
        }
        .form-section {
            margin-bottom: 24px;
        }
        .form-section-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .form-section-title .icon {
            font-size: 16px;
        }
        .condition-builder {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        @media (max-width: 600px) {
            .condition-builder {
                grid-template-columns: 1fr;
            }
        }
        .condition-item {
            background: var(--bg-input);
            border: 1px solid var(--border-secondary);
            border-radius: 10px;
            padding: 14px;
            transition: all 0.2s ease;
        }
        .condition-item:hover {
            border-color: color-mix(in srgb, var(--accent-blue) 30%, transparent);
        }
        .condition-item.active {
            border-color: color-mix(in srgb, var(--accent-blue) 50%, transparent);
            background: color-mix(in srgb, var(--accent-blue) 5%, transparent);
        }
        .condition-item-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .condition-item-header input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--accent-blue);
        }
        .condition-item-header label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
        }
        .condition-item-header .icon {
            font-size: 16px;
        }
        .condition-fields {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding-left: 28px;
        }
        .condition-field {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .condition-field label {
            font-size: 11px;
            color: var(--text-secondary);
            min-width: 60px;
        }
        .condition-field select,
        .condition-field input {
            flex: 1;
            padding: 6px 10px;
            background: color-mix(in srgb, var(--bg-primary) 80%, transparent);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 12px;
        }
        .condition-field select:focus,
        .condition-field input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }
        .action-builder {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .action-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-input);
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
        }
        .action-item label {
            font-size: 13px;
            color: var(--text-secondary);
            min-width: 100px;
        }
        .action-item select,
        .action-item input {
            flex: 1;
            padding: 8px 12px;
            background: color-mix(in srgb, var(--bg-primary) 80%, transparent);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
        }
        .add-rule-card {
            background: color-mix(in srgb, var(--bg-card) 50%, transparent);
            border: 2px dashed var(--border-primary);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 180px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .add-rule-card:hover {
            border-color: color-mix(in srgb, var(--accent-blue) 40%, transparent);
            background: color-mix(in srgb, var(--accent-blue) 5%, transparent);
        }
        .add-rule-card .icon {
            font-size: 36px;
            color: var(--accent-blue);
            margin-bottom: 10px;
        }
        .add-rule-card span {
            font-size: 14px;
            color: var(--text-secondary);
        }
        .empty-rules {
            grid-column: 1 / -1;
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }
        .empty-rules .icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        .empty-rules p {
            font-size: 14px;
            margin-bottom: 8px;
        }
        .empty-rules .hint {
            font-size: 12px;
            color: var(--text-muted);
        }
        
        /* Spinner for loading states */
        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* FAQ Section */
        .faq-section { margin-top: 16px; }
        .faq-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            margin-bottom: 6px;
            overflow: hidden;
        }
        .faq-question {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            cursor: pointer;
            font-weight: 500;
            font-size: 12px;
            color: var(--text-primary);
            transition: background 0.2s;
        }
        .faq-question:hover { background: var(--bg-tertiary); }
        .faq-question .icon {
            transition: transform 0.2s;
            font-size: 10px;
            color: var(--text-secondary);
        }
        .faq-item.open .faq-question .icon { transform: rotate(180deg); }
        .faq-answer {
            display: none;
            padding: 0 12px 12px;
            font-size: 11px;
            line-height: 1.5;
            color: var(--text-secondary);
        }
        .faq-item.open .faq-answer { display: block; }
        .faq-answer code {
            background: var(--bg-terminal);
            padding: 1px 4px;
            border-radius: 3px;
            font-family: 'Consolas', monospace;
            color: var(--accent-blue);
            font-size: 10px;
        }
        .faq-answer ul { margin: 6px 0; padding-left: 16px; }
        .faq-answer li { margin-bottom: 4px; }
        .faq-highlight {
            background: var(--color-success-bg);
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            border-left: 2px solid var(--color-success);
            font-size: 10px;
        }
        
        /* Tooltip styles for action field info */
        .field-label-with-tooltip {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .tooltip-icon {
            position: relative;
            width: 14px;
            height: 14px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: help;
            color: var(--accent-blue);
            font-size: 11px;
            font-weight: bold;
            border-radius: 50%;
            border: 1px solid var(--accent-blue);
            margin-left: 2px;
        }
        .tooltip-icon:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-terminal);
            color: var(--text-primary);
            padding: 8px 10px;
            border-radius: 4px;
            border: 1px solid var(--border-primary);
            white-space: nowrap;
            font-size: 11px;
            font-weight: normal;
            z-index: 10000;
            box-shadow: 0 2px 8px var(--shadow-lg);
        }
        .tooltip-icon:hover::before {
            content: '';
            position: absolute;
            bottom: 118%;
            left: 50%;
            transform: translateX(-50%);
            border: 4px solid transparent;
            border-top-color: var(--bg-terminal);
            z-index: 10000;
        }
    </style>
    <style>
        /* Small inline weather map */
        .weather-map {
            width: 100%;
            min-height: 120px;
            height: 120px !important;
            border-radius: 6px;
            margin-top: 12px;
            overflow: hidden;
            background: var(--bg-secondary) !important;
            border: 1px solid var(--border-secondary) !important;
            position: relative;
        }
        /* Simple modal for Amber history date selection */
        .modal-backdrop { position: fixed; inset: 0; background: rgba(3,6,9,0.6); display:none; align-items:center; justify-content:center; z-index:1200 }
        .modal-backdrop.show { display:flex }
        .modal { background: var(--bg-terminal); border:1px solid var(--border-secondary); padding:16px; border-radius:8px; width:360px; max-width:92%; box-shadow:0 10px 30px var(--shadow-lg) }
        .modal h3 { margin:0 0 8px 0; font-size:16px }
        .modal .row { display:flex; gap:8px; align-items:center; margin-bottom:8px }
        .modal .row input[type=date] { flex:1; padding:8px; background:transparent; border:1px solid var(--border-secondary); color:var(--text-primary) }
        .modal .actions { display:flex; gap:8px; justify-content:flex-end; margin-top:8px }
        .leaflet-container {
            min-height: 120px !important;
            background: var(--bg-secondary) !important;
        }
        /* Force tile images visible if leaflet.css is missing or some rules hide them */
        .leaflet-tile, .leaflet-tile-loaded { opacity: 1 !important; visibility: visible !important; filter: none !important; }
        /* Ensure tiles are stacked above any card overlays */
        .weather-map .leaflet-map-pane, .weather-map .leaflet-tile-pane { z-index: 1 !important; position: relative !important; }
        .weather-map .leaflet-overlay-pane, .weather-map .leaflet-shadow-pane { z-index: 2 !important; }
        /* Make Leaflet tiles blend with dark UI when tiles fail to load quickly */
        .leaflet-container { background: var(--bg-primary); }

        /* ── Light-theme overrides ── */
        [data-theme="light"] .stat-item.curtailed .tile-icon::after {
            border-color: #ffffff;
        }
        [data-theme="light"] .stat-item.curtailed {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.7), rgba(246, 248, 250, 0.8));
        }
        [data-theme="light"] .stat-item.extreme {
            background: linear-gradient(180deg, rgba(255,176,32,0.10), rgba(246,248,250,0.85));
        }
        [data-theme="light"] .automation-toggle {
            background: rgba(0, 0, 0, 0.08);
            border-color: rgba(0, 0, 0, 0.15);
        }
        [data-theme="light"] .automation-toggle:hover {
            background: rgba(0, 0, 0, 0.12);
            border-color: rgba(0, 0, 0, 0.2);
        }
        [data-theme="light"] .automation-toggle.active {
            background: linear-gradient(135deg, rgba(9, 105, 218, 0.15), rgba(9, 105, 218, 0.1));
            border-color: rgba(9, 105, 218, 0.4);
        }
        [data-theme="light"] .automation-toggle::after {
            background: rgba(0, 0, 0, 0.2);
        }
        [data-theme="light"] .automation-toggle.active::after {
            background: #0969da;
        }
    </style>
</head>
<body>
    <nav class="nav-main">
        <button type="button" class="nav-toggle" data-nav-toggle="1" aria-label="Toggle navigation menu" aria-expanded="false">☰</button>
        <div class="nav-links">
            <a href="/" class="nav-link">🏠 Overview</a>
            <a href="/roi.html" class="nav-link">💲 Automation ROI</a>
            <a href="/test.html" class="nav-link">🧪 Automation Lab</a>
            <a href="/history.html" class="nav-link">📊 Reports</a>
            <a href="/control.html" class="nav-link">🎮 Controls</a>
            <a href="/settings.html" class="nav-link">⚙️ Settings</a>
            <a href="/curtailment-discovery.html" class="nav-link" id="topologyNavLink" style="display: none;">🔬 WIP - Topology Discovery</a>
            <a href="/tesla-integration.html" class="nav-link" id="teslaNavLink" style="display: none;">⚡ WIP - Tesla Integration</a>
            <a href="/admin.html" class="nav-link" id="adminNavLink" style="display: none;">🛡️ Admin</a>
        </div>
        <div class="nav-right">
            <input type="hidden" id="deviceSn" value="">
            <div class="user-menu" data-user-menu>
                <button class="user-avatar" type="button" data-user-avatar>
                    <span data-user-initials>?</span>
                </button>
                <div class="user-dropdown" data-user-dropdown>
                    <div class="user-dropdown-header">
                        <div class="user-name" data-user-name>Guest</div>
                        <div class="user-email" data-user-email>Not signed in</div>
                    </div>
                    <button class="user-dropdown-item" type="button" data-go-settings>⚙️ Settings</button>
                    <button class="user-dropdown-item" type="button" data-contact-us>💬 Contact Us</button>
                    <button class="user-dropdown-item danger" type="button" data-signout>🚪 Sign Out</button>
                </div>
            </div>
        </div>
    </nav>
    
    <div class="main-layout">
        <div class="left-panel panel-open">
            <div class="main-content">

            <div class="card dashboard-visibility-card">
                <div class="card-header">
                    <div class="card-title"><span class="icon">🧩</span> Customise Dashboard</div>
                    <button
                        id="dashboardVisibilityToggleBtn"
                        class="dashboard-visibility-collapse-btn"
                        type="button"
                        aria-expanded="false"
                        aria-controls="dashboardVisibilityInline"
                    >
                        Show
                    </button>
                    <div id="dashboardVisibilityInline" class="dashboard-visibility-inline">
                        <label class="card-visibility-toggle"><input type="checkbox" data-dashboard-toggle="inverter" onchange="toggleDashboardCardVisibility('inverter', this)"> Inverter</label>
                        <label class="card-visibility-toggle"><input type="checkbox" data-dashboard-toggle="prices" onchange="toggleDashboardCardVisibility('prices', this)"> Prices</label>
                        <label class="card-visibility-toggle"><input type="checkbox" data-dashboard-toggle="weather" onchange="toggleDashboardCardVisibility('weather', this)"> Weather</label>
                        <label class="card-visibility-toggle"><input type="checkbox" data-dashboard-toggle="quickControls" onchange="toggleDashboardCardVisibility('quickControls', this)"> Quick Controls</label>
                        <label class="card-visibility-toggle"><input type="checkbox" data-dashboard-toggle="scheduler" onchange="toggleDashboardCardVisibility('scheduler', this)"> Scheduler</label>
                    </div>
                </div>
            </div>
            
            <!-- Priority Row: Inverter, Prices, Weather -->
            <div class="priority-row" id="priorityRow">
                
                <!-- Inverter Status -->
                <div class="card priority" data-dashboard-card="inverter">
                    <div class="card-header">
                        <div class="card-title"><span class="icon">⚡</span> Inverter Status</div>
                            <div style="display:flex;align-items:center;gap:8px;flex-direction:column;align-items:flex-end">
                            <div style="display:flex;gap:8px;align-items:center">
                                <span class="card-badge">Live</span>
                                <div id="inverterLastUpdate" style="font-size:11px;color:var(--text-secondary);">—</div>
                                <button class="btn btn-icon" onclick="callAPI('/api/inverter/real-time?forceRefresh=true', 'Real-time Data')" title="Refresh inverter data (bypasses cache)">🔄</button>
                            </div>

                                <!-- API call metrics footer -->
                                <div id="apiMetricsFooter" class="api-metrics-footer">
                                    <div class="metrics-icon">📊</div>
                                    <div id="metricsDate" class="metrics-date">—</div>
                                    <div id="metricsCounts" class="metrics-counts">
                                        <div class="metric-fox">Fox: <span id="countFox" class="metric-value">0</span></div>
                                        <div class="metric-amber">Amb: <span id="countAmber" class="metric-value">0</span></div>
                                        <div class="metric-weather">Wea: <span id="countWeather" class="metric-value">0</span></div>
                                    </div>
                                    <button class="btn btn-sm" onclick="loadApiMetrics(1)" title="Refresh metrics">🔄</button>
                                </div>
                            <div style="font-size:11px;color:var(--text-secondary);margin-top:4px;text-align:right">
                                <span id="inverterCloudTime">—</span>
                                <span style="color:var(--text-muted);margin-left:8px;font-size:10px" id="inverterFetchLabel">(fetched • <span id="inverterFetchAgo">—</span>)</span>
                            </div>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="data-card" id="inverterCard">
                            <div style="color:var(--text-secondary);font-size:12px">Loading inverter data...</div>
                        </div>
                    </div>
                </div>

                <!-- Amber Prices -->
                <div class="card priority" data-dashboard-card="prices">
                    <div class="card-header">
                        <div class="card-title"><span class="icon">💰</span> Electricity Prices</div>
                        <div style="display:flex;align-items:center;gap:8px">
                            <span class="card-badge">Amber</span>
                            <div id="amberLastUpdate" style="font-size:11px;color:var(--text-secondary);">—</div>
                            <button class="btn btn-icon" onclick="getAmberCurrent(true)" title="Force refresh from API (bypasses cache)">🔄</button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="input-row">
                            <select id="amberSiteId" class="input">
                                <option value="">Loading sites...</option>
                            </select>
                            <button class="btn btn-sm" id="amberShowMore" onclick="toggleAmberMore()" style="width:auto;margin:0;padding:6px 12px;font-size:12px">Show all</button>
                        </div>
                        <!-- Hidden input for compatibility with existing code -->
                        <input type="hidden" id="amberNext" value="288">
                        <div class="data-card" id="amberCard">
                            <div style="color:var(--text-secondary);font-size:12px">Loading Amber sites...</div>
                        </div>
                    </div>
                </div>

                <!-- Weather -->
                <div class="card priority" data-dashboard-card="weather">
                    <div class="card-header">
                        <div class="card-title"><span class="icon">🌤️</span> Weather Forecast <span style="display:inline-flex;align-items:center;justify-content:center;width:14px;height:14px;border-radius:50%;background:rgba(139,148,158,0.2);color:var(--text-secondary);font-size:10px;font-weight:600;cursor:default;margin-left:4px;vertical-align:middle;position:relative;top:-1px" title="Location also controls the timezone used by automation rules">i</span></div>
                        <div style="display:flex;align-items:center;gap:8px">
                            <span class="card-badge">Open-Meteo</span>
                            <div id="weatherLastUpdate" style="font-size:11px;color:var(--text-secondary);">—</div>
                            <button class="btn btn-icon" onclick="getWeather(true)" title="Force refresh from API (bypasses cache)">🔄</button>
                        </div>
                    </div>
                    <div class="card-body">
                        <!-- Hidden input preserved so getWeather() JS reads .value as before -->
                        <input type="text" id="weatherPlace" style="display:none" aria-hidden="true">
                        <div style="display:flex;align-items:center;flex-wrap:wrap;gap:8px;">
                            <!-- Location display (read-only — change in Settings) -->
                            <div style="flex:1;min-width:160px;display:flex;align-items:center;gap:8px;background:var(--bg-input);border:1px solid var(--border-primary);border-radius:6px;padding:7px 12px;">
                                <span style="color:var(--text-secondary);font-size:12px;white-space:nowrap;">📍</span>
                                <span id="weatherPlaceDisplay"
                                      style="flex:1;color:var(--text-primary);font-size:13px;font-weight:500;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"
                                      title="Weather location — also sets the timezone used by automation rules. Change in Settings → Preferences.">—</span>
                                <a href="settings.html#preferences" style="font-size:11px;color:var(--accent-blue);white-space:nowrap;text-decoration:none;opacity:0.85;" title="Open Settings to change location">Edit ›</a>
                            </div>
                            <!-- Days slider -->
                            <div style="display:flex;align-items:center;gap:6px;background:var(--bg-input);border:1px solid var(--border-primary);border-radius:6px;padding:7px 12px;min-width:180px;">
                                <span style="font-size:11px;color:var(--text-secondary);white-space:nowrap;">1d</span>
                                <input type="range" id="weatherDays" min="1" max="16" step="1" value="6"
                                       oninput="updateWeatherRequestedLabel()"
                                       style="flex:1;min-width:0;height:6px;background:var(--border-primary);border-radius:3px;outline:none;-webkit-appearance:none;cursor:pointer;">
                                <span style="font-size:11px;color:var(--text-secondary);white-space:nowrap;">16d</span>
                                <span id="weatherRequestedLabel" style="font-size:12px;color:var(--text-primary);font-weight:600;white-space:nowrap;min-width:28px;text-align:right;">6d</span>
                            </div>
                            <button id="getWeatherBtn" class="btn btn-primary" onclick="getWeather(true)" style="white-space:nowrap;padding:7px 14px;font-size:13px;width:auto;flex-shrink:0;" title="Fetch fresh forecast (bypasses cache)">Get Forecast</button>
                        </div>
                        <div class="data-card" id="weatherCard">
                            <div style="color:var(--text-secondary);font-size:12px">Enter a location and click Get Forecast</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Quick Controls -->
            <div class="card" style="margin-bottom: 20px;" data-dashboard-card="quickControls">
                <div class="card-header">
                    <div class="card-title"><span class="icon">🕹️</span> Quick Controls</div>
                    <button class="btn" onclick="refreshQuickControlStatus(true)" style="font-size:11px;padding:4px 10px;width:auto;margin:0">🔄 Refresh</button>
                </div>
                <div class="card-body">
                    <!-- Message Status Banner -->
                    <div id="quickControlMessage" style="padding:8px;margin-bottom:10px;border-radius:6px;font-size:12px;display:none;"></div>
                    
                    <!-- Status Display -->
                    <div id="quickControlStatus" style="display:none;padding:12px;margin-bottom:16px;border-radius:6px;font-size:13px;">
                        <!-- Active status will be displayed here -->
                    </div>

                    <!-- Automation Warning -->
                    <div id="quickControlAutomationWarning" style="display:none;padding:12px;margin-bottom:16px;background:rgba(210,153,34,0.15);border:1px solid rgba(210,153,34,0.4);border-radius:6px;font-size:13px;color:var(--color-warning);">
                        <div style="font-weight:600;margin-bottom:6px">ℹ️ Automation Mode</div>
                        <div style="font-size:12px;line-height:1.5;color:var(--text-secondary);">
                            Automation is currently <strong style="color:var(--color-orange)">enabled</strong>. While quick control is active, automation will be paused automatically and resume after the quick control expires.
                        </div>
                    </div>

                    <!-- Control Form -->
                    <div id="quickControlForm">
                        <div style="display:grid;grid-template-columns:repeat(auto-fit, minmax(280px, 1fr));gap:16px;margin-bottom:16px;">
                            <!-- Type Selection -->
                            <div class="input-group">
                                <label style="font-weight:600;color:var(--accent-blue);font-size:13px">Control Type</label>
                                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:6px;">
                                    <button id="btnChargeType" class="btn" onclick="selectQuickControlType('charge')" style="background:var(--accent-blue);border-color:var(--accent-blue);padding:10px;font-size:13px;font-weight:600;">
                                        🔋 Charge
                                    </button>
                                    <button id="btnDischargeType" class="btn" onclick="selectQuickControlType('discharge')" style="padding:10px;font-size:13px;">
                                        ⚡ Discharge
                                    </button>
                                </div>
                            </div>

                            <!-- Duration Selection -->
                            <div class="input-group">
                                <label style="font-weight:600;color:var(--accent-blue);font-size:13px">
                                    Duration: <span id="quickControlDurationDisplay" style="color:var(--text-primary);font-weight:700;">20</span> min
                                </label>
                                <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
                                    <span style="font-size:11px;color:var(--text-secondary);white-space:nowrap;">2m</span>
                                    <input type="range" id="quickControlDuration" min="2" max="300" step="1" value="20" 
                                           oninput="updateQuickControlDurationDisplay(this.value)" 
                                           style="flex:1;min-width:0;height:8px;background:var(--border-primary);border-radius:4px;outline:none;-webkit-appearance:none;">
                                    <span style="font-size:11px;color:var(--text-secondary);white-space:nowrap;">300m</span>
                                </div>
                                <div style="margin-top:8px;display:flex;gap:4px;flex-wrap:wrap;">
                                    <button class="btn" onclick="setQuickControlDuration(5)" style="font-size:11px;padding:4px 6px;flex:1;min-width:44px;">5m</button>
                                    <button class="btn" onclick="setQuickControlDuration(15)" style="font-size:11px;padding:4px 6px;flex:1;min-width:44px;">15m</button>
                                    <button class="btn" onclick="setQuickControlDuration(30)" style="font-size:11px;padding:4px 6px;flex:1;min-width:44px;">30m</button>
                                    <button class="btn" onclick="setQuickControlDuration(60)" style="font-size:11px;padding:4px 6px;flex:1;min-width:44px;">60m</button>
                                    <button class="btn" onclick="toggleQuickControlCustomDuration()" style="font-size:11px;padding:4px 6px;flex:1;min-width:44px;">Custom</button>
                                </div>
                                <input type="number" id="quickControlDurationCustom" class="input" min="2" max="360" value="20" placeholder="Minutes (2-360)" 
                                       onchange="setQuickControlDuration(this.value)" 
                                       style="display:none;margin-top:8px;padding:8px;">
                            </div>
                        </div>

                        <!-- Power Selection -->
                        <div class="input-group" style="margin-bottom:16px;">
                            <label style="font-weight:600;color:var(--accent-blue);font-size:13px">
                                Power: <span id="quickControlPowerDisplay" style="color:var(--text-primary);font-weight:700;">5.0</span> kW
                            </label>
                            <div style="display:flex;gap:12px;align-items:center;margin-top:8px;">
                                <span style="font-size:12px;color:var(--text-secondary);min-width:30px;">0 kW</span>
                                <input type="range" id="quickControlPower" min="0" max="10000" step="100" value="5000" 
                                       oninput="updateQuickControlPowerDisplay(this.value)" 
                                       style="flex:1;height:8px;background:var(--border-primary);border-radius:4px;outline:none;-webkit-appearance:none;">
                                <span id="quickControlMaxLabel" style="font-size:12px;color:var(--text-secondary);min-width:40px;text-align:right;">10 kW</span>
                            </div>
                            <div style="margin-top:8px;display:flex;gap:6px;">
                                <button class="btn" onclick="setQuickControlPower(2000)" style="font-size:11px;padding:4px 8px;flex:1;">2 kW</button>
                                <button class="btn" onclick="setQuickControlPower(3000)" style="font-size:11px;padding:4px 8px;flex:1;">3 kW</button>
                                <button class="btn" onclick="setQuickControlPower(5000)" style="font-size:11px;padding:4px 8px;flex:1;">5 kW</button>
                                <button class="btn" onclick="setQuickControlPower(7000)" style="font-size:11px;padding:4px 8px;flex:1;">7 kW</button>
                                <button id="quickControlMaxBtn" class="btn" onclick="setQuickControlPower(10000)" style="font-size:11px;padding:4px 8px;flex:1;">10 kW</button>
                            </div>
                        </div>

                        <!-- Start Button -->
                        <button id="btnStartQuickControl" class="btn btn-primary" onclick="startQuickControl()" style="width:100%;padding:12px;font-size:14px;font-weight:600;">
                            ▶️ Start Quick Control
                        </button>
                    </div>

                    <div style="margin-top:12px;padding-top:12px;border-top:1px solid var(--border-primary);font-size:12px;color:var(--text-secondary);line-height:1.6;">
                        <strong style="color:var(--accent-blue);">💡 Quick Controls</strong> let you immediately charge or discharge your battery for a set duration without creating automation rules. 
                        Perfect for ad-hoc adjustments based on weather, price changes, or upcoming events.
                    </div>
                </div>
            </div>

            <!-- Manual Scheduler (Time Segments) - moved up for prominence -->
            <div class="card" style="margin-bottom: 20px;" data-dashboard-card="scheduler">
                <div class="card-header">
                    <div class="card-title"><span class="icon">📅</span> Manual Scheduler (Time Segments)</div>
                    <div style="display:flex;gap:8px;">
                        <button class="btn" onclick="clearAllSchedulerSegments()" style="font-size:11px;padding:4px 10px;width:auto;margin:0;background:var(--color-danger);border-color:var(--color-danger);">🗑️ Clear All</button>
                        <button class="btn" onclick="loadSchedulerSegments()" style="font-size:11px;padding:4px 10px;width:auto;margin:0">🔄 Load Current</button>
                    </div>
                </div>
                <div class="card-body">
                    <!-- Automation Conflict Warning -->
                    <div id="schedulerAutomationWarning" style="display:none;padding:12px;margin-bottom:16px;background:rgba(210,153,34,0.15);border:1px solid rgba(210,153,34,0.4);border-radius:6px;font-size:13px;color:var(--color-warning);">
                        <div style="font-weight:600;margin-bottom:6px">⚠️ Warning: Automation is Currently Enabled</div>
                        <div style="font-size:12px;line-height:1.5;color:var(--text-secondary);">
                            Manual scheduler segments will be <strong style="color:var(--color-orange)">overwritten and cleared</strong> when automation triggers a rule. 
                            If you want to use manual segments, please disable automation first to avoid conflicts.
                        </div>
                    </div>
                    <div id="schedulerStatus" style="padding:8px;margin-bottom:10px;border-radius:6px;font-size:12px;display:none;"></div>
                    <div id="schedulerSegments" style="display:grid;grid-template-columns:repeat(auto-fit, minmax(300px, 1fr));gap:10px;">
                        <!-- Segments will be loaded here -->
                        <div style="color:var(--text-secondary);font-size:12px;padding:20px;text-align:center">
                            Click "Load Current" to fetch your scheduler segments, or add a new segment below.
                        </div>
                    </div>
                    
                    <!-- Add New Segment -->
                    <div style="margin-top:16px;padding-top:16px;border-top:1px solid var(--border-primary);">
                        <div style="font-weight:600;color:var(--accent-blue);margin-bottom:10px">➕ Add/Edit Segment</div>
                        <form id="form-scheduler-segment" onsubmit="submitSchedulerSegment(event)" style="display:grid;grid-template-columns:repeat(auto-fit, minmax(140px, 1fr));gap:10px;align-items:end;">
                            <div class="input-group">
                                <label style="font-size:11px">Segment #</label>
                                <select name="segmentIndex" class="input" style="padding:6px">
                                    <option value="0">1</option>
                                    <option value="1">2</option>
                                    <option value="2">3</option>
                                    <option value="3">4</option>
                                    <option value="4">5</option>
                                    <option value="5">6</option>
                                    <option value="6">7</option>
                                    <option value="7">8</option>
                                </select>
                            </div>
                            <div class="input-group">
                                <label style="font-size:11px">Enable</label>
                                <select name="enable" class="input" style="padding:6px">
                                    <option value="1">Yes</option>
                                    <option value="0">No</option>
                                </select>
                            </div>
                            <div class="input-group">
                                <label style="font-size:11px">Work Mode</label>
                                <select name="workMode" class="input" style="padding:6px">
                                    <option value="SelfUse">Self Use</option>
                                    <option value="ForceCharge">Force Charge</option>
                                    <option value="ForceDischarge">Force Discharge</option>
                                    <option value="Feedin">Feed In</option>
                                    <option value="Backup">Backup</option>
                                </select>
                            </div>
                            <div class="input-group">
                                <label style="font-size:11px">Start Time</label>
                                <input type="time" name="startTime" class="input" value="00:00" style="padding:5px">
                            </div>
                            <div class="input-group">
                                <label style="font-size:11px">End Time</label>
                                <input type="time" name="endTime" class="input" value="00:00" style="padding:5px">
                            </div>
                            <div class="input-group">
                                <label style="font-size:11px">Min SoC (Grid) %</label>
                                <input type="number" name="minSocOnGrid" class="input" min="10" max="100" value="20" style="padding:6px">
                            </div>
                            <div class="input-group">
                                <label style="font-size:11px">Stop SoC %</label>
                                <input type="number" name="fdSoc" class="input" min="10" max="100" value="35" style="padding:6px">
                            </div>
                            <div class="input-group">
                                <label style="font-size:11px">Power (W)</label>
                                <input type="number" name="fdPwr" class="input" min="0" max="10500" value="5000" style="padding:6px">
                            </div>
                            <div class="input-group">
                                <label style="font-size:11px">Max SoC %</label>
                                <input type="number" name="maxSoc" class="input" min="10" max="100" value="90" style="padding:6px">
                            </div>
                            <div style="display:flex;gap:6px">
                                <button class="btn btn-primary" type="submit" style="flex:1">💾 Save Segment</button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>

        </div>

            </div> <!-- /.main-content -->

            <div id="automationResizer" class="panel-resizer" title="Drag to resize rules panel"></div>
            <button class="automation-toggle-btn" id="automationToggleBtn" onclick="toggleAutomationPanel()" title="Collapse automation panel" aria-label="Toggle automation panel"><span class="automation-toggle-icon"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"><defs><linearGradient id="robotBody" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:#667eea;stop-opacity:1" /><stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" /></linearGradient></defs><rect x="5" y="8" width="14" height="10" rx="3" fill="url(#robotBody)" stroke="#5567d8" stroke-width="0.5"/><rect x="7" y="4" width="10" height="4" rx="2" fill="#667eea" stroke="#5567d8" stroke-width="0.5"/><circle cx="9.5" cy="11" r="1.3" fill="#fff"/><circle cx="14.5" cy="11" r="1.3" fill="#fff"/><circle cx="9.5" cy="11" r="0.7" fill="#667eea"/><circle cx="14.5" cy="11" r="0.7" fill="#667eea"/><rect x="10" y="15" width="4" height="1.5" rx="0.7" fill="#764ba2"/><circle cx="6" y="4" r="0.8" fill="#ffd700"/></svg></span><span class="automation-toggle-arrow">◀</span></button>

            <div class="automation-panel collapsed">
                <!-- Backend Automation Status -->
                <div class="card" style="margin-bottom:16px">
                    <div class="card-header">
                        <div class="card-title"><span class="icon">⚡</span> Active Automation</div>
                    </div>
                    <div class="card-body" id="backendAutomationStatus">
                        <div style="color:var(--text-secondary);font-size:12px">Loading automation status...</div>
                    </div>
                </div>

                <!-- FAQ Section -->
                <div class="card faq-card" style="margin-bottom:16px">
                    <div class="card-header">
                        <div class="card-title"><span class="icon">❓</span> How It Works</div>
                    </div>
                    <div class="card-body">
                        <div class="faq-section">
                            <div class="faq-item">
                                <div class="faq-question" onclick="this.parentElement.classList.toggle('open')">
                                    <span>How often are conditions checked?</span>
                                    <span class="icon">▼</span>
                                </div>
                                <div class="faq-answer">
                                    Every <code id="faqAutomationInterval">60 seconds</code> using <strong>cached data</strong>:
                                    <ul>
                                        <li>Amber prices: refreshed every <span id="faqAmberCache">60s</span></li>
                                        <li>Inverter (SoC, temps): every <span id="faqInverterCache">5 min</span></li>
                                        <li>Weather: every <span id="faqWeatherCache">30 min</span></li>
                                    </ul>
                                </div>
                            </div>
                            <div class="faq-item">
                                <div class="faq-question" onclick="this.parentElement.classList.toggle('open')">
                                    <span>What is cooldown?</span>
                                    <span class="icon">▼</span>
                                </div>
                                <div class="faq-answer">
                                    After a rule triggers, it can't trigger again for <code id="faqCooldown">5 minutes</code> (default). Prevents rapid switching when values hover near thresholds.
                                </div>
                            </div>
                            <div class="faq-item">
                                <div class="faq-question" onclick="this.parentElement.classList.toggle('open')">
                                    <span>What if conditions change mid-segment?</span>
                                    <span class="icon">▼</span>
                                </div>
                                <div class="faq-answer">
                                    <div class="faq-highlight">
                                        <strong>Active Cancellation:</strong> If the triggering rule's conditions are no longer met, the segment is cancelled within ~<span id="faqCancelInterval">60 seconds</span>. Higher-priority rules can also replace active lower-priority rules immediately.
                                    </div>
                                </div>
                            </div>
                            <div class="faq-item">
                                <div class="faq-question" onclick="this.parentElement.classList.toggle('open')">
                                    <span>How does priority work?</span>
                                    <span class="icon">▼</span>
                                </div>
                                <div class="faq-answer">
                                    <strong>Lower number = Higher priority.</strong> Rules evaluated in order; first match wins. Use priority 1-2 for safety rules.
                                </div>
                            </div>
                        </div>
                        <div style="text-align:center;margin-top:10px">
                            <a href="/test.html" style="color:var(--accent-blue);font-size:11px;text-decoration:none">🧪 Full FAQ in Automation Lab →</a>
                        </div>
                    </div>
                </div>
            </div> <!-- /.automation-panel -->

            <!-- Right Panel - Response -->
            <div class="right-panel collapsed" id="rightPanel">
                <div class="resize-handle" id="resizeHandle"></div>
                
                <div class="result-container">
                    <div class="result-header">
                        <h2>📋 API Response</h2>
                        <div class="header-btns">
                            <button class="copy-btn" onclick="copyResult()">📋 Copy</button>
                            <button class="clear-btn" onclick="clearResult()">Clear</button>
                        </div>
                    </div>
                    <div id="status-bar" class="status-bar" style="display: none;">
                        <span class="endpoint"></span>
                        <span class="time"></span>
                    </div>
                    <div class="result-content">
                        <pre id="result">Click any button to see the API response here...</pre>
                    </div>
                </div>
            </div>

        </div> <!-- /.main-layout -->

        <!-- Toggle button outside main-layout, fixed position, always visible -->
        <button class="toggle-panel" onclick="togglePanel()" id="toggleBtn">R ◀</button>

        <!-- Rule Builder Modal -->
        <div class="modal-overlay" id="ruleModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3><span class="icon">⚙️</span> <span id="ruleModalTitle">Create Automation Rule</span></h3>
                    <button class="modal-close" onclick="closeRuleModal()">×</button>
                </div>
                <div class="modal-body">
                    <form id="ruleForm">
                        <!-- Rule Name -->
                        <div class="form-section">
                            <div class="form-section-title"><span class="icon">📝</span> Rule Name</div>
                            <input type="text" id="ruleName" class="input" placeholder="e.g., Cheap Rate Charging" required>
                        </div>
                        
                        <!-- Conditions -->
                        <div class="form-section">
                            <div class="form-section-title"><span class="icon">🎯</span> Conditions (when to trigger)</div>
                            <div class="condition-builder">
                                <!-- Amber Price Condition -->
                                <div class="condition-item" id="conditionPrice">
                                    <div class="condition-item-header">
                                        <input type="checkbox" id="condPriceEnabled" onchange="toggleCondition('Price')">
                                        <span class="icon">💰</span>
                                        <label for="condPriceEnabled">Amber Price</label>
                                    </div>
                                    <div class="condition-fields" id="condPriceFields">
                                        <div class="condition-field">
                                            <label>Type</label>
                                            <select id="condPriceType">
                                                <option value="buy">Buy Price</option>
                                                <option value="feedin">Feed-in Price</option>
                                            </select>
                                        </div>
                                        <div class="condition-field">
                                            <label>Operator</label>
                                            <select id="condPriceOp">
                                                <option value="<">Less than</option>
                                                <option value="<=">Less or equal</option>
                                                <option value=">">Greater than</option>
                                                <option value=">=">Greater or equal</option>
                                                <option value="between">Between</option>
                                            </select>
                                        </div>
                                        <div class="condition-field">
                                            <label>Value (¢)</label>
                                            <input type="number" id="condPriceValue" placeholder="15" step="0.1">
                                        </div>
                                        <div class="condition-field" id="condPriceValue2Row" style="display:none">
                                            <label>And (¢)</label>
                                            <input type="number" id="condPriceValue2" placeholder="25" step="0.1">
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Battery SoC Condition -->
                                <div class="condition-item" id="conditionSoC">
                                    <div class="condition-item-header">
                                        <input type="checkbox" id="condSoCEnabled" onchange="toggleCondition('SoC')">
                                        <span class="icon">🔋</span>
                                        <label for="condSoCEnabled">Battery SoC</label>
                                    </div>
                                    <div class="condition-fields" id="condSoCFields">
                                        <div class="condition-field">
                                            <label>Operator</label>
                                            <select id="condSoCOp">
                                                <option value="<">Less than</option>
                                                <option value="<=">Less or equal</option>
                                                <option value=">">Greater than</option>
                                                <option value=">=">Greater or equal</option>
                                                <option value="between">Between</option>
                                            </select>
                                        </div>
                                        <div class="condition-field">
                                            <label>Value (%)</label>
                                            <input type="number" id="condSoCValue" min="0" max="100" placeholder="20">
                                        </div>
                                        <div class="condition-field" id="condSoCValue2Row" style="display:none">
                                            <label>And (%)</label>
                                            <input type="number" id="condSoCValue2" min="0" max="100" placeholder="80">
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Battery Temperature Condition -->
                                <div class="condition-item" id="conditionTemp">
                                    <div class="condition-item-header">
                                        <input type="checkbox" id="condTempEnabled" onchange="toggleCondition('Temp')">
                                        <span class="icon">🌡️</span>
                                        <label for="condTempEnabled">Battery Temperature</label>
                                    </div>
                                    <div class="condition-fields" id="condTempFields">
                                        <div class="condition-field">
                                            <label>Operator</label>
                                            <select id="condTempOp">
                                                <option value="<">Less than</option>
                                                <option value="<=">Less or equal</option>
                                                <option value=">">Greater than</option>
                                                <option value=">=">Greater or equal</option>
                                                <option value="between">Between</option>
                                            </select>
                                        </div>
                                        <div class="condition-field">
                                            <label>Value (°C)</label>
                                            <input type="number" id="condTempValue" placeholder="35">
                                        </div>
                                        <div class="condition-field" id="condTempValue2Row" style="display:none">
                                            <label>And (°C)</label>
                                            <input type="number" id="condTempValue2" placeholder="45">
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Weather Condition -->
                                <div class="condition-item" id="conditionWeather">
                                    <div class="condition-item-header">
                                        <input type="checkbox" id="condWeatherEnabled" onchange="toggleCondition('Weather')">
                                        <span class="icon">🌤️</span>
                                        <label for="condWeatherEnabled">Weather Forecast</label>
                                    </div>
                                    <div class="condition-fields" id="condWeatherFields">
                                        <div class="condition-field">
                                            <label>Condition</label>
                                            <select id="condWeatherType">
                                                <option value="sunny">Sunny / Clear</option>
                                                <option value="cloudy">Cloudy / Overcast</option>
                                                <option value="rainy">Rainy</option>
                                                <option value="any">Any</option>
                                            </select>
                                        </div>
                                        <div class="condition-field">
                                            <label>Solar (kWh)</label>
                                            <select id="condWeatherSolarOp">
                                                <option value="any">Any</option>
                                                <option value=">">Expected &gt;</option>
                                                <option value="<">Expected &lt;</option>
                                            </select>
                                        </div>
                                        <div class="condition-field" id="condWeatherSolarValueRow">
                                            <label>Value</label>
                                            <input type="number" id="condWeatherSolarValue" placeholder="20" step="0.1">
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Time Window Condition -->
                                <div class="condition-item" id="conditionTime">
                                    <div class="condition-item-header">
                                        <input type="checkbox" id="condTimeEnabled" onchange="toggleCondition('Time')">
                                        <span class="icon">🕐</span>
                                        <label for="condTimeEnabled">Time Window</label>
                                    </div>
                                    <div class="condition-fields" id="condTimeFields">
                                        <div class="condition-field">
                                            <label>From</label>
                                            <input type="time" id="condTimeStart" value="00:00">
                                        </div>
                                        <div class="condition-field">
                                            <label>To</label>
                                            <input type="time" id="condTimeEnd" value="23:59">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Actions -->
                        <div class="form-section">
                            <div class="form-section-title"><span class="icon">⚡</span> Action (what to do)</div>
                            <div class="action-builder">
                                <div class="action-item">
                                    <label>Work Mode</label>
                                    <select id="actionWorkMode">
                                        <option value="">-- Select --</option>
                                        <option value="SelfUse">Self Use</option>
                                        <option value="ForceCharge">Force Charge</option>
                                        <option value="ForceDischarge">Force Discharge</option>
                                        <option value="Feedin">Feed In</option>
                                        <option value="Backup">Backup</option>
                                    </select>
                                </div>
                                <div class="action-item">
                                    <label>Min SoC (Grid) (%)</label>
                                    <input type="number" id="actionMinSoC" min="10" max="100" placeholder="Optional">
                                </div>
                                <div class="action-item">
                                    <label>Max SoC (%)</label>
                                    <input type="number" id="actionMaxSoC" min="10" max="100" placeholder="Optional">
                                </div>
                                <div class="action-item">
                                    <label>Power (W)</label>
                                    <input type="number" id="actionFdPwr" min="0" max="10500" placeholder="Optional">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Priority -->
                        <div class="form-section">
                            <div class="form-section-title"><span class="icon">📊</span> Priority</div>
                            <div class="action-item">
                                <label>Rule Priority</label>
                                <select id="rulePriority">
                                    <option value="1">1 - Highest</option>
                                    <option value="2">2 - High</option>
                                    <option value="3" selected>3 - Normal</option>
                                    <option value="4">4 - Low</option>
                                    <option value="5">5 - Lowest</option>
                                </select>
                            </div>
                        </div>
                        
                        <input type="hidden" id="ruleId" value="">
                    </form>
                </div>
                <div class="modal-footer">
                    <button class="btn" onclick="closeRuleModal()">Cancel</button>
                    <button class="btn btn-primary" onclick="saveRule()">💾 Save Rule</button>
                </div>
            </div>
        </div>

    <script>
        // Helper to read a CSS variable from the current theme (respects light/dark mode)
        function cssVar(name) {
            return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        }

        // default collapsed state for right response panel; value persisted in localStorage
        let panelCollapsed = false;
        // When true, suppress auto-opening the right response panel (used during init)
        window.suppressPanelAutoOpen = false;
        // User timezone (populated from backend `/api/config` during initialization)
        // Used throughout render functions and time formatting to respect user's local timezone
        let USER_TZ = 'Australia/Sydney';

        // Hardware config — per-user inverter and battery specs loaded from /api/config.
        // Defaults match legacy hard-coded values so existing users see no change.
        let _batteryCapacityKwh = 41.93; // kWh; overridden from user config on load
        let _inverterCapacityW  = 10000; // Watts; overridden from user config on load

        // apiClient is declared in api-client.js and initialized after Firebase auth is ready

        /**
         * Helper function to make authenticated API calls.
         * Uses apiClient.fetch to include the Authorization header and normalize responses.
         */
        async function authenticatedFetch(url, options = {}) {
            if (window.AppShell && typeof AppShell.authFetch === 'function') {
                return AppShell.authFetch(url, options);
            }
            try {
                if (typeof waitForAPIClient === 'function') {
                    await waitForAPIClient(3000);
                } else {
                    const start = Date.now();
                    while (!apiClient && (Date.now() - start) < 3000) {
                        await new Promise(r => setTimeout(r, 50));
                    }
                }
            } catch (e) {
                console.warn('[API] apiClient not initialized yet');
                throw new Error('API client not ready');
            }
            return apiClient.fetch(url, options);
        }
        // Dismiss the weather fallback banner for a given location key
        function dismissWeatherFallback(key) {
            try {
                localStorage.setItem('weatherFallbackDismissed:' + key, String(Date.now()));
            } catch (e) { /* ignore storage errors */ }
            const el = document.getElementById('weather-fallback-banner-' + key);
            if (el && el.remove) el.remove();
            // Also clear status bar border if it was indicating fallback
            try {
                const statusBar = document.getElementById('status-bar');
                if (statusBar) statusBar.style.border = '';
            } catch (e) {}

            // Ensure the toggle button remains clickable; keep pointer events enabled
            try {
                const tbtn = document.getElementById('automationToggleBtn');
                if (tbtn) tbtn.style.pointerEvents = 'auto';
            } catch (e) { /* ignore */ }
        }

        function syncAutomationToggleVisibility() {
            try {
                const toggle = document.getElementById('automationToggleBtn');
                if (!toggle) return;

                const addRuleModalOpen = !!document.getElementById('addRuleModal');
                const ruleModal = document.getElementById('ruleModal');
                const ruleModalOpen = !!(ruleModal && ruleModal.classList.contains('show'));

                if (addRuleModalOpen || ruleModalOpen) {
                    toggle.style.display = 'none';
                } else {
                    toggle.style.display = '';
                    toggle.style.pointerEvents = 'auto';
                }
            } catch (e) { /* ignore */ }
        }

        window.addEventListener('pageshow', () => {
            setTimeout(syncAutomationToggleVisibility, 0);
        });

        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                setTimeout(syncAutomationToggleVisibility, 0);
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(syncAutomationToggleVisibility, 0);
        });

        // Dynamically load Leaflet CSS+JS once and return a Promise when ready
        function ensureLeafletLoaded() {
            if (window.__leafletLoading) return window.__leafletLoading;
            if (window.L) return Promise.resolve();

            window.__leafletLoading = new Promise((resolve, reject) => {
                try {
                    // CSS
                    const cssHref = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                    const existing = Array.from(document.getElementsByTagName('link')).find(l => l.href && l.href.indexOf('unpkg.com/leaflet') !== -1);
                    if (!existing) {
                        const link = document.createElement('link');
                        link.rel = 'stylesheet';
                        link.href = cssHref;
                        document.head.appendChild(link);
                    }

                    // JS
                    const existingScript = Array.from(document.getElementsByTagName('script')).find(s => s.src && s.src.indexOf('unpkg.com/leaflet') !== -1);
                    if (existingScript) {
                        existingScript.addEventListener('load', () => resolve());
                        existingScript.addEventListener('error', () => reject(new Error('Leaflet script failed to load')));
                        return;
                    }
                    const script = document.createElement('script');
                    script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                    script.async = true;
                    script.onload = () => setTimeout(() => resolve(), 20);
                    script.onerror = () => reject(new Error('Leaflet script failed to load'));
                    document.body.appendChild(script);
                } catch (e) {
                    reject(e);
                }
            });
            return window.__leafletLoading;
        }
        
        function updateToggleBtnPosition() {
            const panel = document.getElementById('rightPanel');
            const toggleBtn = document.getElementById('toggleBtn');
            if (!panel || !toggleBtn) return;
            const panelWidth = panel.offsetWidth || 0;
            toggleBtn.style.right = panelWidth + 'px';
        }
        
        function togglePanel() {
            if (window.innerWidth <= 900) return;
            const panel = document.getElementById('rightPanel');
            const toggleBtn = document.getElementById('toggleBtn');
            if (!panel) return;
            
            panelCollapsed = !panelCollapsed;
            if (panelCollapsed) {
                panel.classList.add('collapsed');
                // Panel is collapsed — clicking should open it (move left), so show left-facing arrow
                toggleBtn.textContent = 'R ◀';
                toggleBtn.style.right = '0px';
                try { localStorage.setItem('rightPanelCollapsed', 'true'); } catch(e) {}
            } else {
                // Force reflow before removing class
                void panel.offsetWidth;
                panel.classList.remove('collapsed');
                // Panel is expanded — clicking should collapse it (move right), so show right-facing arrow
                toggleBtn.textContent = 'R ▶';
                // Set button position to target width immediately - CSS transition will animate both smoothly
                toggleBtn.style.right = '480px';
                try { localStorage.setItem('rightPanelCollapsed', 'false'); } catch(e) {}
            }
        }
        
        async function callAPI(endpoint, name, autoOpen = false, forceRefresh = false) {
            // Only auto-open the right-panel if caller explicitly requests it.
            // Suppress during initial boot to keep panel collapsed by default.
            if (autoOpen && panelCollapsed && !window.suppressPanelAutoOpen) togglePanel();
            const resultEl = document.getElementById('result');
            const statusBar = document.getElementById('status-bar');
            const sn = document.getElementById('deviceSn').value;
            
            let url = endpoint;
            // Add forceRefresh parameter if provided to bypass backend cache
            if (forceRefresh && !url.includes('forceRefresh')) {
                const separator = url.includes('?') ? '&' : '?';
                url += separator + 'forceRefresh=true';
            }
            if (sn && (endpoint.includes('/inverter') || endpoint.includes('/scheduler/') || endpoint.includes('/module/signal'))) {
                // Use & if URL already has query parameters, otherwise use ?
                const separator = url.includes('?') ? '&' : '?';
                url += `${separator}sn=${encodeURIComponent(sn)}`;
            }
            
            resultEl.className = '';
            resultEl.textContent = `Loading ${name}...`;
            const startTime = Date.now();
            
                try {
                    // Ensure a global in-flight map exists for deduplication
                    if (!window._inflightRequests) window._inflightRequests = {};
                    const inflightKey = `GET ${url}`;
                    let fetchPromise = window._inflightRequests[inflightKey];
                    if (!fetchPromise) {
                        fetchPromise = (async () => {
                            try {
                                const response = await authenticatedFetch(url);
                                return await response.json();
                            } finally {
                                // Clear the in-flight entry when finished (success or error)
                                try { delete window._inflightRequests[inflightKey]; } catch (e) {}
                            }
                        })();
                        window._inflightRequests[inflightKey] = fetchPromise;
                    }
                    const data = await fetchPromise;
                const endTime = Date.now();
                
                statusBar.style.display = 'flex';
                statusBar.querySelector('.endpoint').textContent = `${name} - ${endpoint}`;
                statusBar.querySelector('.time').textContent = `${endTime - startTime}ms`;
                
                resultEl.className = (data.errno === 0 || data.result) ? 'success' : 'error';
                resultEl.textContent = JSON.stringify(data, null, 2);
                
                // Cache data for automation test page (no API calls there)
                if (data.errno === 0) {
                    if (endpoint.includes('/inverter/real-time') || name === 'Real-time Data') {
                        try {
                            const items = [];
                            const result = data.result || [];
                            if (Array.isArray(result) && result.length > 0 && Array.isArray(result[0].datas)) {
                                result.forEach(r => { if (Array.isArray(r.datas)) items.push(...r.datas); });
                            }
                            const invCache = {};
                            items.forEach(item => {
                                if (item.variable && item.value !== undefined) {
                                    invCache[item.variable] = item.value;
                                }
                            });
                            localStorage.setItem('cachedInverter', JSON.stringify(invCache));
                        } catch (e) { /* ignore cache errors */ }
                    } else if (endpoint.includes('/amber/prices/current')) {
                        try {
                            const prices = data.result || [];
                            const general = prices.find(p => p.channelType === 'general');
                            const feedIn = prices.find(p => p.channelType === 'feedIn');
                            const forecasts = prices.filter(p => p.type === 'ForecastInterval');
                            const priceCache = {
                                general: general ? { perKwh: general.perKwh } : null,
                                feedIn: feedIn ? { perKwh: feedIn.perKwh } : null,
                                forecastHigh: forecasts.length > 0 ? Math.max(...forecasts.map(f => f.perKwh || 0)) : null
                            };
                            localStorage.setItem('cachedPrices', JSON.stringify(priceCache));
                        } catch (e) { /* ignore cache errors */ }
                    } else if (endpoint.includes('/weather')) {
                        try {
                            // API now returns {errno, result: {source, hourly, current, ...}}
                            const weatherData = data.result || data;
                            const hourly = weatherData?.hourly || {};
                            const current = weatherData?.current || {};
                            // Find current hour index for accurate solar radiation
                            // Use API's current time (which is in local timezone) instead of JS Date (which is UTC)
                            let currentHourIdx = 0;
                            if (hourly.time && Array.isArray(hourly.time)) {
                                const currentTime = current?.time || new Date().toISOString();
                                const currentHourStr = currentTime.substring(0, 13); // YYYY-MM-DDTHH
                                currentHourIdx = hourly.time.findIndex(t => t && t.substring(0, 13) === currentHourStr);
                                if (currentHourIdx < 0) currentHourIdx = 0;
                            }
                            const wxCache = {
                                solarRadiation: hourly.shortwave_radiation?.[currentHourIdx] || 0,
                                cloudCover: hourly.cloudcover?.[currentHourIdx] || hourly.cloud_cover?.[currentHourIdx] || 0
                            };
                            localStorage.setItem('cachedWeather', JSON.stringify(wxCache));
                        } catch (e) { /* ignore cache errors */ }
                    }
                }
                
                // Update inverter card if relevant
                if (endpoint.includes('/inverter/')) {
                    updateInverterCard(data, name);
                }

                // If this was a real-time inverter fetch, prefer the cloud timestamp when available
                try {
                    if (endpoint.includes('/inverter/real-time') || name === 'Real-time Data') {
                        // Save the client fetch time
                        setLastUpdated('inverter');

                        // If the API provided a server/cloud timestamp (result[0].time), parse and use it
                        try {
                            const frame = (data && data.result && Array.isArray(data.result) && data.result[0]) ? data.result[0] : null;
                            if (frame && frame.time) {
                                const parsed = parseFoxESSCloudTime(frame.time);
                                if (parsed) {
                                    // store cloud timestamp (ms since epoch)
                                    lastUpdated.inverterCloud = parsed;
                                    // also show formatted cloud time in the header (DD/MM/YYYY HH:MM)
                                    const el = document.getElementById('inverterCloudTime');
                                    if (el) el.textContent = 'cloud: ' + formatDate(parsed, true);
                                }
                            }
                        } catch (e) {/* ignore parse errors */}
                    }
                } catch (e) { /* ignore */ }
            } catch (error) {
                resultEl.className = 'error';
                resultEl.textContent = `Error: ${error.message}`;
                statusBar.style.display = 'none';
            }
        }

        async function callAPIPost(endpoint, name, bodyTemplate = {}, autoOpen = false) {
            // Only auto-open the right-panel if caller explicitly requests it.
            if (autoOpen && panelCollapsed && !window.suppressPanelAutoOpen) togglePanel();
            const resultEl = document.getElementById('result');
            const statusBar = document.getElementById('status-bar');
            const sn = document.getElementById('deviceSn').value;
            const body = Object.assign({}, bodyTemplate);
            if (sn) body.sn = sn;

            resultEl.className = '';
            resultEl.textContent = `Sending ${name}...`;
            const startTime = Date.now();

            try {
                // POST dedupe: include body in the key so identical requests reuse the same in-flight Promise
                if (!window._inflightRequests) window._inflightRequests = {};
                let bodyKey = '';
                try { bodyKey = JSON.stringify(body); } catch (e) { bodyKey = String(Date.now()); }
                const inflightKey = `POST ${endpoint} ${bodyKey}`;
                let postPromise = window._inflightRequests[inflightKey];
                if (!postPromise) {
                    postPromise = (async () => {
                        try {
                            const response = await authenticatedFetch(endpoint, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(body)
                            });
                            return await response.json();
                        } finally {
                            try { delete window._inflightRequests[inflightKey]; } catch (e) {}
                        }
                    })();
                    window._inflightRequests[inflightKey] = postPromise;
                }
                const data = await postPromise;
                const endTime = Date.now();

                statusBar.style.display = 'flex';
                statusBar.querySelector('.endpoint').textContent = `${name} - ${endpoint}`;
                statusBar.querySelector('.time').textContent = `${endTime - startTime}ms`;

                resultEl.className = (data.errno === 0 || data.result) ? 'success' : 'error';
                resultEl.textContent = JSON.stringify(data, null, 2);
            } catch (error) {
                resultEl.className = 'error';
                resultEl.textContent = `Error: ${error.message}`;
                statusBar.style.display = 'none';
            }
        }

        async function getSetting() {
            const key = document.getElementById('settingKey').value;
            callAPI(`/api/inverter/settings?key=${encodeURIComponent(key)}`, `Setting: ${key}`);
        }

        // Get current inverter work mode (direct setting, not scheduler)
        async function getWorkMode() {
            const displayEl = document.getElementById('currentWorkMode');
            const sn = document.getElementById('deviceSn').value;
            displayEl.textContent = 'Loading...';
            displayEl.style.color = cssVar('--text-secondary');
            
            try {
                let url = '/api/device/workmode/get';
                if (sn) url += `?sn=${encodeURIComponent(sn)}`;
                const fetchStart = Date.now();
                const response = await authenticatedFetch(url);
                const data = await response.json();
                
                if (data.errno === 0 && data.result) {
                    const result = data.result;
                    const currentMode = result.value;
                    const enumList = result.enumList || [];
                    
                    displayEl.innerHTML = `<span style="color:${cssVar('--color-success')}">Current:</span> ${currentMode}`;
                    
                    // Select matching option in dropdown
                    const select = document.getElementById('workModeSelect');
                    for (let opt of select.options) {
                        if (opt.value === currentMode) {
                            select.value = opt.value;
                            break;
                        }
                    }
                } else {
                    displayEl.textContent = data.msg || 'Failed to get mode';
                    displayEl.style.color = cssVar('--color-danger');
                }
                
                // Also show in the right panel using the fetched data (avoid duplicate network call)
                try {
                    const resultEl = document.getElementById('result');
                    const statusBar = document.getElementById('status-bar');
                    const fetchEnd = Date.now();
                    if (resultEl) {
                        resultEl.className = (data.errno === 0 && data.result) ? 'success' : 'error';
                        resultEl.textContent = JSON.stringify(data, null, 2);
                    }
                    if (statusBar) {
                        statusBar.style.display = 'flex';
                        const endpointLabel = `Work Mode Setting - ${url}`;
                        try { statusBar.querySelector('.endpoint').textContent = endpointLabel; } catch (e) {}
                        try { statusBar.querySelector('.time').textContent = `${fetchEnd - fetchStart}ms`; } catch (e) {}
                    }
                } catch (e) { /* ignore panel update errors */ }
            } catch (error) {
                displayEl.textContent = `Error: ${error.message}`;
                displayEl.style.color = cssVar('--color-danger');
            }
        }

        // Set inverter work mode (direct setting, not scheduler)
        async function setWorkMode() {
            const displayEl = document.getElementById('currentWorkMode');
            const select = document.getElementById('workModeSelect');
            const workMode = select.value;
            const sn = document.getElementById('deviceSn').value;
            
            if (!workMode) {
                displayEl.textContent = 'Please select a mode';
                displayEl.style.color = cssVar('--color-danger');
                return;
            }
            
            displayEl.textContent = `Setting to ${workMode}...`;
            displayEl.style.color = cssVar('--accent-blue');
            
            try {
                const body = { workMode };
                if (sn) body.sn = sn;
                
                const response = await authenticatedFetch('/api/device/workmode/set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const data = await response.json();
                
                if (data.errno === 0) {
                    displayEl.innerHTML = `<span style="color:${cssVar('--color-success')}">✓ Set to:</span> ${workMode}`;
                } else {
                    displayEl.textContent = data.msg || 'Failed to set mode';
                    displayEl.style.color = cssVar('--color-danger');
                }
                
                // Show response in right panel
                if (panelCollapsed) togglePanel();
                const resultEl = document.getElementById('result');
                const statusBar = document.getElementById('status-bar');
                statusBar.style.display = 'flex';
                statusBar.querySelector('.endpoint').textContent = `Set Work Mode - /api/device/workmode/set`;
                statusBar.querySelector('.time').textContent = '';
                resultEl.className = data.errno === 0 ? 'success' : 'error';
                resultEl.textContent = JSON.stringify(data, null, 2);
            } catch (error) {
                displayEl.textContent = `Error: ${error.message}`;
                displayEl.style.color = cssVar('--color-danger');
            }
        }

        async function getAllSettings() {
            if (panelCollapsed) togglePanel();
            const resultEl = document.getElementById('result');
            const statusBar = document.getElementById('status-bar');
            const card = document.getElementById('inverterCard');
            const keys = ['MinSoc', 'MinSocOnGrid'];
            
            resultEl.className = '';
            resultEl.textContent = 'Loading all settings...';
            const startTime = Date.now();
            
            try {
                const results = await Promise.all(keys.map(key => 
                    fetch(`/api/inverter/settings?key=${encodeURIComponent(key)}`).then(r => r.json())
                ));
                const endTime = Date.now();
                
                const settings = {};
                keys.forEach((key, i) => {
                    if (results[i].errno === 0 && results[i].result) {
                        settings[key] = results[i].result;
                    } else {
                        settings[key] = { error: results[i].msg || 'Failed' };
                    }
                });
                
                statusBar.style.display = 'flex';
                statusBar.querySelector('.endpoint').textContent = 'All Settings';
                statusBar.querySelector('.time').textContent = `${endTime - startTime}ms`;
                
                resultEl.className = 'success';
                resultEl.textContent = JSON.stringify(settings, null, 2);
                
                // Update inverter card with settings
                card.innerHTML = `<div class="stat-row">
                    <div class="stat-item"><div class="value">${settings.MinSoc?.value || '-'}%</div><div class="label">Min SoC</div></div>
                    <div class="stat-item"><div class="value">${settings.MinSocOnGrid?.value || '-'}%</div><div class="label">Min On-Grid</div></div>
                </div>`;
            } catch (error) {
                resultEl.className = 'error';
                resultEl.textContent = `Error: ${error.message}`;
                statusBar.style.display = 'none';
            }
        }

        function updateInverterCard(data, name) {
            const card = document.getElementById('inverterCard');
            if (!data || data.errno !== 0) {
                card.innerHTML = `<div style="color:var(--color-danger);font-size:12px">Error loading data</div>`;
                return;
            }
            
            const result = data.result || [];
            if (name === 'Real-time Data' && Array.isArray(result)) {
                // Helper to find a numeric value from common variable keys or variable name patterns
                function findValue(arr, keysOrPatterns) {
                    if (!Array.isArray(arr)) return null;
                    for (const k of keysOrPatterns) {
                        // try exact match on variable
                        const exact = arr.find(it => (it.variable && it.variable.toString().toLowerCase() === k.toString().toLowerCase()) || (it.key && it.key.toString().toLowerCase() === k.toString().toLowerCase()));
                        if (exact && exact.value !== undefined && exact.value !== null) return exact.value;
                        // try includes match on variable name
                        const incl = arr.find(it => (it.variable && it.variable.toString().toLowerCase().includes(k.toString().toLowerCase())) || (it.key && it.key.toString().toLowerCase().includes(k.toString().toLowerCase())));
                        if (incl && incl.value !== undefined && incl.value !== null) return incl.value;
                    }
                    return null;
                }

                // Normalize a list of datapoints from various FoxESS response shapes
                let items = [];
                if (Array.isArray(result)) {
                    // result may be an array of frames, each with a `datas` array
                    if (result.length > 0 && Array.isArray(result[0].datas)) {
                        result.forEach(r => { if (Array.isArray(r.datas)) items.push(...r.datas); });
                    } else {
                        // assume array of simple datapoints
                        items = result.slice();
                    }
                } else if (result && typeof result === 'object') {
                    if (Array.isArray(result.datas)) items = result.datas.slice();
                    else if (Array.isArray(result.data)) items = result.data.slice();
                    else if (result.result && Array.isArray(result.result.datas)) items = result.result.datas.slice();
                    else if (Array.isArray(result.result)) items = result.result.slice();
                }

                // Try a set of common keys for each concept (case-insensitive)
                // Keys expanded to match FoxESS responses (observe real-time payload)
                const solarKeys = ['generationpower', 'generation', 'pvpower','pv_power','pv','solar','generationpower','acpower','pv1power','pv2power','powerpv'];
                // 'loadsPower' is the FoxESS variable for house load
                const loadKeys = ['loadspower','load','loadpower','houseload','house_load','consumption','load_active_power','loadactivepower','loadsPower'];
                // Grid may come as gridConsumptionPower or feedinPower - handle both
                const gridKeys = ['gridconsumptionpower','grid_consumption_power','gridpower','grid_power','grid','meterpower','gridactivepower','grid_active_power','eim','feedinpower','feed_in'];
                // Battery values may appear as batChargePower / batDischargePower
                const battKeys = ['batchargepower','batcharge','batpower','battery','bms_chg_power','batterycharge','batterydischarge','batdischargepower','battery_current','batchargepower','batdischargepower'];

                // Primary raw values
                const solar = findValue(items, solarKeys);
                const houseLoad = findValue(items, loadKeys);
                // Prefer feed-in and grid consumption separately so we can decide import vs export
                const feedIn = findValue(items, ['feedinpower', 'feed_in', 'feed-in', 'feedin']);
                const gridConsumption = findValue(items, ['gridconsumptionpower', 'grid_consumption_power', 'gridconsumption', 'gridconsumption']);
                const grid = gridConsumption !== null && gridConsumption !== undefined ? gridConsumption : findValue(items, gridKeys);
                // Battery: prefer discharge/charge specific keys
                const batDis = findValue(items, ['batdischargepower', 'bat_discharge_power', 'batdischarge', 'dischargepower']);
                const batChg = findValue(items, ['batchargepower', 'bat_charge_power', 'batcharge', 'chargepower']);
                const battery = (batChg !== null && batChg !== undefined) || (batDis !== null && batDis !== undefined) ? { charge: batChg, discharge: batDis } : findValue(items, battKeys);

                // Compute solar production as manufacturer app expects:
                // PV = load + batteryCharge + feedIn - batteryDischarge - gridImport
                // Fallbacks: if any part missing, try generationPower + batCharge as approximation
                const gen = findValue(items, ['generationpower', 'generation', 'outputpower']);
                function asNumber(v) { return v === null || v === undefined || v === '-' ? 0 : Number(v); }
                let computedSolar = null;
                if (houseLoad !== null || batChg !== null || feedIn !== null || batDis !== null || grid !== null) {
                    // Use numeric values (treat missing as 0)
                    const L = asNumber(houseLoad);
                    const C = asNumber(batChg);
                    const F = asNumber(feedIn);
                    const D = asNumber(batDis);
                    const Gc = asNumber(grid);
                    // grid is reported as gridConsumptionPower (positive when importing)
                    computedSolar = L + C + F - D - Gc;
                }
                // If computedSolar is effectively zero and generation is present, prefer generation + charge
                if ((!computedSolar || computedSolar === 0) && gen !== null && (batChg !== null)) {
                    computedSolar = asNumber(gen) + asNumber(batChg);
                }
                // Prefer aggregated pvPower from the device when available (more accurate for total PV)
                const pvTotal = findValue(items, ['pvPower','pvpower','pv_total','pv_total_power']);
                const meterPower2 = findValue(items, ['meterPower2', 'meter_power_2', 'meter2power']);

                function normalizeTopologyPower(v) {
                    if (v === null || v === undefined || v === '-') return null;
                    const n = Number(v);
                    if (isNaN(n)) return null;
                    // FoxESS payloads are usually kW here; if a large value appears, treat as W.
                    return Math.abs(n) > 100 ? (n / 1000) : n;
                }

                const pvTotalKW = normalizeTopologyPower(pvTotal);
                const meterPower2KW = normalizeTopologyPower(meterPower2);
                const isLikelyACCoupled =
                    (pvTotalKW === null || Math.abs(pvTotalKW) < 0.05) &&
                    (meterPower2KW !== null && meterPower2KW > 0.05);

                let finalSolar = null;
                if (isLikelyACCoupled) {
                    finalSolar = meterPower2KW;
                } else if (pvTotal !== null && pvTotal !== undefined && !isNaN(Number(pvTotal))) {
                    finalSolar = pvTotal;
                } else {
                    // If computedSolar set use it, otherwise fall back to raw solar field
                    finalSolar = (computedSolar !== null && !isNaN(Number(computedSolar))) ? computedSolar : solar;
                }

                // Format helper (kW, one decimal). Some APIs return W — if value seems large, convert to kW.
                function fmtKW(v) {
                    if (v === null || v === undefined || v === '-') return '-';
                    let n = Number(v);
                    if (isNaN(n)) return '-';
                    // if value looks like watts (>2000), convert to kW
                    if (Math.abs(n) > 2000) n = n / 1000;
                    return n.toFixed(2) + ' kW';
                }

                // Interpret grid using feedIn and gridConsumption when available
                function gridLabel(feedInVal, gridVal) {
                    try {
                        const f = feedInVal !== null && feedInVal !== undefined ? Number(feedInVal) : null;
                        const g = gridVal !== null && gridVal !== undefined ? Number(gridVal) : null;

                        // if both provided and non-zero, show both
                        if (f !== null && !isNaN(f) && Math.abs(f) > 0 && g !== null && !isNaN(g) && Math.abs(g) > 0) {
                            return `Import ${Math.abs(g).toFixed(2)} kW / Export ${Math.abs(f).toFixed(2)} kW`;
                        }
                        if (g !== null && !isNaN(g) && Math.abs(g) > 0) return `${Math.abs(g).toFixed(2)} kW <span class="substatus">(import)</span>`;
                        if (f !== null && !isNaN(f) && Math.abs(f) > 0) return `${Math.abs(f).toFixed(2)} kW <span class="substatus">(export)</span>`;
                        return '0.00 kW';
                    } catch (e) { return '0.00 kW'; }
                }

                // Interpret battery using separate charge/discharge values when available
                function batteryLabelComposite(objOrVal) {
                    try {
                        if (!objOrVal) return '—';
                        if (typeof objOrVal === 'object') {
                            const ch = objOrVal.charge !== null && objOrVal.charge !== undefined ? Number(objOrVal.charge) : 0;
                            const dis = objOrVal.discharge !== null && objOrVal.discharge !== undefined ? Number(objOrVal.discharge) : 0;
                            if (!isNaN(dis) && dis > 0) return `${Math.abs(dis).toFixed(2)} kW <span class="substatus">(discharging)</span>`;
                            if (!isNaN(ch) && ch > 0) return `${Math.abs(ch).toFixed(2)} kW <span class="substatus">(charging)</span>`;
                            return '—';
                        }
                        const n = Number(objOrVal);
                        if (isNaN(n)) return '—';
                        return n > 0 ? `${Math.abs(n).toFixed(2)} kW <span class="substatus">(charging)</span>` : `${Math.abs(n).toFixed(2)} kW <span class="substatus">(discharging)</span>`;
                    } catch (e) { return '—'; }
                }

                const solarDisplay = fmtKW(finalSolar);
                const loadDisplay = fmtKW(houseLoad);
                const gridDisplay = grid !== null || feedIn !== null ? gridLabel(feedIn, grid) : '-';
                const batteryDisplay = (typeof battery === 'object' || battery !== null) ? batteryLabelComposite(battery) : batteryLabelComposite(null);

                // Determine coloring for grid and battery
                let batteryIsCharging = false, batteryIsDischarging = false;
                if (typeof battery === 'object') {
                    batteryIsCharging = battery.charge !== null && battery.charge !== undefined && Number(battery.charge) > 0;
                    batteryIsDischarging = battery.discharge !== null && battery.discharge !== undefined && Number(battery.discharge) > 0;
                } else if (battery !== null && battery !== undefined) {
                    const bn = Number(battery);
                    if (!isNaN(bn)) {
                        batteryIsCharging = bn > 0;
                        batteryIsDischarging = bn < 0;
                    }
                }

                // Determine import/export presence robustly. grid/feed in some payloads can be strings
                // (eg "0.01 kW (import)") so we attempt to extract a numeric value when needed.
                let gridIsImport = false, gridIsExport = false;
                const rawG = (grid !== null && grid !== undefined) ? grid : null;
                const rawF = (feedIn !== null && feedIn !== undefined) ? feedIn : null;

                function extractNumberFromRaw(r) {
                    if (r === null || r === undefined) return null;
                    if (typeof r === 'number') return r;
                    // Try to parse direct numeric string
                    if (typeof r === 'string') {
                        // match first number (including decimals and negative)
                        const m = r.match(/-?\d+\.?\d*/);
                        if (m) return Number(m[0]);
                    }
                    const n = Number(r);
                    return isNaN(n) ? null : n;
                }

                const gNumRaw = extractNumberFromRaw(rawG);
                const fNumRaw = extractNumberFromRaw(rawF);
                if (gNumRaw !== null && !isNaN(gNumRaw) && gNumRaw > 0) gridIsImport = true;
                if (fNumRaw !== null && !isNaN(fNumRaw) && fNumRaw > 0) gridIsExport = true;

                // Helper: simple normalization to kW for small-value checks
                function _normToKWForSmall(v) {
                    if (v === null || v === undefined) return null;
                    const n = Number(v);
                    if (isNaN(n)) return null;
                    // Heuristic: large numbers are likely in watts
                    if (Math.abs(n) > 100) return n / 1000;
                    return n;
                }

                // Compute a battery power (kW) for small-value heuristics
                let batteryPowerKW = null;
                if (typeof battery === 'object') {
                    if (batteryIsCharging && battery.charge !== undefined && battery.charge !== null) batteryPowerKW = _normToKWForSmall(battery.charge);
                    else if (batteryIsDischarging && battery.discharge !== undefined && battery.discharge !== null) batteryPowerKW = _normToKWForSmall(battery.discharge);
                    else {
                        // fallback to raw keys if present in payload
                        batteryPowerKW = batteryIsCharging && typeof batChg !== 'undefined' ? _normToKWForSmall(batChg) : (batteryIsDischarging && typeof batDis !== 'undefined' ? _normToKWForSmall(batDis) : null);
                    }
                } else if (battery !== null && battery !== undefined) {
                    batteryPowerKW = _normToKWForSmall(battery);
                }

                // If the battery power is tiny (<0.05 kW) show it as neutral/gray
                const SMALL_BATT_THRESHOLD = 0.05; // kW
                let batteryClass = '';
                if (batteryPowerKW !== null && !isNaN(batteryPowerKW) && Math.abs(batteryPowerKW) < SMALL_BATT_THRESHOLD) {
                    batteryClass = 'price-neutral';
                } else {
                    batteryClass = batteryIsCharging ? 'price-low' : (batteryIsDischarging ? 'price-high' : '');
                }
                // Normalise grid/feed values to kW and keep very small values (close to zero)
                // displayed as neutral/gray. User requested values under 0.05 kW remain gray.
                // Try to find the original items so we can detect units (W vs kW)
                function findItemByKeys(keys) {
                    if (!Array.isArray(items)) return null;
                    for (const k of keys) {
                        const exact = items.find(it => (it.variable && it.variable.toString().toLowerCase() === k.toString().toLowerCase()) || (it.key && it.key.toString().toLowerCase() === k.toString().toLowerCase()));
                        if (exact) return exact;
                        const incl = items.find(it => (it.variable && it.variable.toString().toLowerCase().includes(k.toString().toLowerCase())) || (it.key && it.key.toString().toLowerCase().includes(k.toString().toLowerCase())));
                        if (incl) return incl;
                    }
                    return null;
                }

                function normalizedKWFromValue(val, item) {
                    if (val === null || val === undefined) return null;
                    const n = Number(val);
                    if (isNaN(n)) return null;

                    // If the variable includes a unit string, prefer that
                    const unit = (item && item.unit) ? item.unit.toString().toLowerCase() : '';
                    if (unit.includes('kw')) return n; // already kW
                    if (unit.includes('w')) return n / 1000; // watts -> kW

                    // Fallback heuristics: if value looks large assume watts, otherwise assume kW
                    // Treat values > 100 as watts, convert to kW
                    if (Math.abs(n) > 100) return n / 1000;

                    // If dividing by 1000 produces a value that would be considered "close to zero"
                    // (e.g., 10 -> 0.01), prefer the divided value because many small W values are reported
                    // and should be interpreted as kW when deciding if they're 'near zero'. This is safer
                    // for tiny readings (e.g. 10 -> 0.01 kW) which we want to keep neutral.
                    if (Math.abs(n) / 1000 < 0.05 && Math.abs(n) >= 1) return n / 1000;

                    // Otherwise treat as already kW
                    return n;
                }

                // Use raw values (or extracted numeric) to normalise to kW
                const gKW = normalizedKWFromValue(gNumRaw !== null ? gNumRaw : rawG, findItemByKeys(['gridconsumptionpower','grid_consumption_power','gridpower','grid_power','grid','meterpower','gridactivepower','grid_active_power','eim','feedin','feed_in','feed-in']));
                const fKW = normalizedKWFromValue(fNumRaw !== null ? fNumRaw : rawF, findItemByKeys(['feedinpower','feed_in','feed-in','feedin']));
                let gridClass = '';
                if (gridIsImport && gKW !== null && Math.abs(gKW) < 0.05) {
                    // small import — show neutral/gray
                    gridClass = 'price-neutral';
                } else if (gridIsExport && fKW !== null && Math.abs(fKW) < 0.05) {
                    // small export — show neutral/gray
                    gridClass = 'price-neutral';
                } else {
                    gridClass = gridIsImport ? 'price-high' : (gridIsExport ? 'price-low' : 'price-neutral');
                }

                // Fallback: if the formatted label contains a numeric reading and that number is < 0.05 kW
                // treat it as near-zero and keep the display neutral. This covers cases where raw
                // values weren't easily parseable earlier.
                try {
                    if (typeof gridDisplay === 'string') {
                        const m = gridDisplay.match(/-?\d+\.?\d*/);
                        if (m) {
                            const parsed = Number(m[0]);
                            if (!isNaN(parsed) && Math.abs(parsed) < 0.05) {
                                gridClass = 'price-neutral';
                            }
                        }
                    }
                } catch (e) { /* ignore fallback parse errors */ }
                // end try

                // Battery capacity from user config (kWh). Defaulting to legacy value until config loads.
                const BATTERY_CAP_KWH = _batteryCapacityKwh;

                // Try to find SoC in the real-time feed
                const socVal = findValue(items, ['soc','socvalue','SoC','batSoc','bms_soc','stateofcharge','batterySoc','socpercent']);
                const socNum = (socVal !== null && socVal !== undefined && !isNaN(Number(socVal))) ? Number(socVal) : null;

                // helper to normalise numeric power into kW (some endpoints return W)
                function toKW(v) {
                    if (v === null || v === undefined || v === '-') return null;
                    let n = Number(v);
                    if (isNaN(n)) return null;
                    if (Math.abs(n) > 2000) n = n / 1000; // treat as W -> kW
                    return n;
                }

                // Compute estimated time to reach target energy when charging/discharging
                let batteryTimeText = '';
                const currentEnergyKWh = (socNum !== null) ? (socNum / 100.0) * BATTERY_CAP_KWH : null;
                const chKW = (batChg !== null && batChg !== undefined) ? toKW(batChg) : (battery && battery.charge ? toKW(battery.charge) : null);
                const disKW = (batDis !== null && batDis !== undefined) ? toKW(batDis) : (battery && battery.discharge ? toKW(battery.discharge) : null);

                function fmtTimeHours(h) {
                    if (!h || !isFinite(h) || h <= 0) return null;
                    const totMin = Math.round(h * 60);
                    const hours = Math.floor(totMin / 60);
                    const mins = totMin % 60;
                    if (hours === 0) return `${mins}m`;
                    return `${hours}h ${mins}m`;
                }

                if (batteryIsCharging && chKW && chKW > 0 && currentEnergyKWh !== null) {
                    const energyNeeded = Math.max(0, BATTERY_CAP_KWH - currentEnergyKWh);
                    if (energyNeeded <= 0) batteryTimeText = 'Full';
                    else {
                        // base hours to full at current power (kW)
                        let hrs = energyNeeded / chKW;

                        // Add a 5% buffer for the portion of charge above 90% SoC
                        // Battery slows when >90%, so if current or future charge includes >90% portion we increase time accordingly
                        const ninetyKwh = 0.9 * BATTERY_CAP_KWH;
                        if (currentEnergyKWh >= ninetyKwh) {
                            // already beyond 90% — apply full 5% buffer
                            hrs *= 1.05;
                        } else if ((currentEnergyKWh + energyNeeded) > ninetyKwh) {
                            // charging will cross 90% — only apply buffer proportional to the portion above 90%
                            const portionAbove90 = (currentEnergyKWh + energyNeeded) - ninetyKwh;
                            const proportion = portionAbove90 / energyNeeded; // 0..1
                            hrs *= (1 + 0.05 * proportion);
                        }

                        const s = fmtTimeHours(hrs);
                        batteryTimeText = s ? `≈ ${s} to ${BATTERY_CAP_KWH.toFixed(2)} kWh` : '';
                    }
                } else if (batteryIsDischarging && disKW && disKW > 0 && currentEnergyKWh !== null) {
                    const targetEnergy = 0.2 * BATTERY_CAP_KWH; // 20%
                    const energyAvailable = Math.max(0, currentEnergyKWh - targetEnergy);
                    if (energyAvailable <= 0) batteryTimeText = `≤ 20% (${targetEnergy.toFixed(3)} kWh)`;
                    else {
                        const hrs = energyAvailable / disKW;
                        const s = fmtTimeHours(hrs);
                        batteryTimeText = s ? `≈ ${s} to 20% (${targetEnergy.toFixed(3)} kWh)` : '';
                    }
                }

                // Helper for temperature class: <40 green, <55 amber, >=55 red
                function tempClassRealtime(v) {
                    if (v === undefined || v === null || isNaN(Number(v))) return '';
                    const n = Number(v);
                    if (n < 40) return 'price-low';
                    if (n < 55) return 'price-mid';
                    return 'price-high';
                }

                // Pull real-time temperatures if present
                const batTempVal = findValue(items, ['batTemperature','bat_temperature','batterytemperature','batTemp','batteryTemp','battemperation']);
                const ambTempVal = findValue(items, ['ambientTemperation','ambienttemperature','ambient_temp','ambientTemp','ambTemperature']);
                const invTempVal = findValue(items, ['invTemperation','invtemperature','invertertemperature','invTemp','inverterTemp']);

                function fmtTemp(v) { if (v === null || v === undefined || v === '-') return '-'; const n = Number(v); if (isNaN(n)) return '-'; return n.toFixed(1) + '°C'; }

                // Create an inline thermometer SVG string for a temperature value
                // Visual idea: a bulb + tube. Fill level mapped from 0..80°C (clamped).
                function makeThermSVG(v) {
                    const n = (v === null || v === undefined || v === '-') ? null : Number(v);
                    const minT = 0; const maxT = 80; // range mapped to 0..100%
                    const pct = (n === null || isNaN(n)) ? 0 : Math.max(0, Math.min(1, (n - minT) / (maxT - minT)));
                    // tube inner height (px) and geometry tuned for viewBox
                    const innerH = 34; // tube height
                    const fillH = Math.round(pct * innerH);
                    const tubeX = 8; const tubeW = 8; const tubeY = 4;
                    const y = tubeY + (innerH - fillH);
                    // color thresholds: <40 green, <55 amber, >=55 red
                    const fillColor = (n === null || isNaN(n)) ? 'rgba(255,255,255,0.06)' : (n < 40 ? 'var(--color-success-dark)' : (n < 55 ? 'var(--color-warning)' : 'var(--color-danger)'));
                    // return compact SVG (class "therm-svg" for styling)
                    return `
                        <div class="tile-icon thermometer" aria-hidden="true">
                            <svg class="therm-svg" viewBox="0 0 24 48" xmlns="http://www.w3.org/2000/svg">
                                <!-- outer tube -->
                                <rect x="${tubeX}" y="${tubeY}" width="${tubeW}" height="${innerH}" rx="4" fill="none" stroke="rgba(255,255,255,0.12)" stroke-width="1.5" />
                                <!-- fill (matches tube rounded corners) -->
                                <rect x="${tubeX}" y="${y}" width="${tubeW}" height="${fillH}" rx="3" fill="${fillColor}" class="therm-fill" />
                                <!-- bulb -->
                                <circle cx="12" cy="42" r="6.5" fill="${fillColor}" stroke="rgba(255,255,255,0.08)" stroke-width="1" />
                                <circle cx="12" cy="42" r="6.5" fill-opacity="0.12" />
                            </svg>
                        </div>`;
                }

                const batTempCls = tempClassRealtime(batTempVal);
                const ambTempCls = tempClassRealtime(ambTempVal);
                const invTempCls = tempClassRealtime(invTempVal);

                // Check if curtailment is active
                const curtailmentActive = window.curtailmentState && window.curtailmentState.active;
                const solarTileClass = curtailmentActive ? 'stat-item curtailed' : 'stat-item';
                const curtailmentLabel = curtailmentActive ? ' (Curtailed)' : '';

                const html = `<div class="stat-row">
                    <div class="${solarTileClass}" id="solar-tile"><div class="tile-icon">☀️</div><div class="value">${solarDisplay}</div><div class="label">Solar Production${curtailmentLabel}</div></div>
                    <div class="stat-item"><div class="tile-icon">🏠</div><div class="value">${loadDisplay}</div><div class="label">House Load</div></div>
                    <div class="stat-item"><div class="tile-icon">🔌</div><div class="value ${gridClass}">${gridDisplay}</div><div class="label">Grid Import/Export</div></div>
                    <div class="stat-item battery-tile"><div class="tile-icon battery ${batteryIsCharging ? 'charging' : ''}">
                                <!-- Inline SVG battery: fill level reflects SoC -->
                                ${(() => {
                                    const socPct = (socNum !== null && !isNaN(Number(socNum))) ? Math.max(0, Math.min(100, Number(socNum))) : 0;
                                    // innerHeight = 28 (y from 4..32). Compute rect y and height so fill starts at bottom
                                    const innerH = 28;
                                    const fillH = Math.round((socPct / 100) * innerH);
                                    const y = 4 + (innerH - fillH);
                                    // Conditional coloring: green >=50%, amber 25-44%, red <25%
                                    const fillColor = socPct >= 50 ? 'var(--color-success-dark)' : (socPct >= 25 ? 'var(--color-warning)' : 'var(--color-danger)');
                                    return `
                                    <svg viewBox="0 0 24 40" aria-hidden="true">
                                        <rect x="3" y="4" width="18" height="28" rx="3" ry="3" fill="none" stroke="rgba(255,255,255,0.12)" stroke-width="1.5"></rect>
                                        <rect x="3" y="${y}" width="18" height="${fillH}" rx="2" ry="2" class="level" fill="${fillColor}"></rect>
                                        <rect x="9" y="1" width="6" height="2" rx="1" ry="1" fill="rgba(255,255,255,0.12)"></rect>
                                    </svg>`;
                                })()}
                            </div>
                            <div class="value ${batteryClass}" style="font-size:20px;font-weight:600">${batteryDisplay}</div>
                        <div style="font-size:28px;font-weight:700;color:var(--accent-blue);margin-top:4px">${socNum !== null ? socNum.toFixed(0) + '%' : '-'}</div>
                        <div style="font-size:12px;color:var(--text-secondary);margin-top:2px">${currentEnergyKWh !== null ? (currentEnergyKWh.toFixed(2) + ' kWh') : ''}</div>
                        <div style="font-size:11px;color:var(--text-secondary);margin-top:4px">${batteryTimeText || ''}</div>
                    </div>
                </div>

                <!-- Inline temps row for real-time display -->
                <div class="stat-row" style="margin-top:8px">
                        <div class="stat-item" style="min-width:140px">
                            ${makeThermSVG(batTempVal)}
                            <div class="value ${batTempCls}" style="font-size:18px">${batTempVal !== null && batTempVal !== undefined ? fmtTemp(batTempVal) : '-'}</div>
                            <div class="label">Battery Temp</div>
                        </div>
                    <div class="stat-item" style="min-width:140px">
                        ${makeThermSVG(ambTempVal)}
                        <div class="value ${ambTempCls}" style="font-size:18px">${ambTempVal !== null && ambTempVal !== undefined ? fmtTemp(ambTempVal) : '-'}</div>
                        <div class="label">Ambient Temp</div>
                    </div>
                    <div class="stat-item" style="min-width:140px">
                        ${makeThermSVG(invTempVal)}
                        <div class="value ${invTempCls}" style="font-size:18px">${invTempVal !== null && invTempVal !== undefined ? fmtTemp(invTempVal) : '-'}</div>
                        <div class="label">Inverter Temp</div>
                    </div>
                </div>`;
                // Debug raw view removed for stable inverter status
                const rawHtml = '';

                // Display per-PV-string outputs if present (pv1Power..pv4Power)
                const pvStrings = [];
                for (let i = 1; i <= 4; i++) {
                    const pKey = `pv${i}power`;
                    const vKey = `pv${i}volt`;
                    const cKey = `pv${i}current`;
                    const p = findValue(items, [pKey, `pv${i}Power`]);
                    const v = findValue(items, [vKey, `pv${i}Volt`]);
                    const c = findValue(items, [cKey, `pv${i}Current`]);
                    if (p !== null && p !== undefined) pvStrings.push({ idx: i, power: p, volt: v, current: c });
                }
                // Also include aggregated pvPower if available
                const pvPowerTotal = findValue(items, ['pvPower','pvpower']);

                if (pvStrings.length) {
                    let pvHtml = '<div style="margin-top:12px;font-size:12px;color:var(--text-secondary);font-weight:600">🔸 PV String Outputs';
                    if (pvPowerTotal !== null && pvPowerTotal !== undefined) {
                        pvHtml += ` <span style="color:var(--color-success);font-weight:700">(Total: ${fmtKW(pvPowerTotal)})</span>`;
                    }
                    pvHtml += '</div>';
                    pvHtml += '<div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:8px">';
                    pvStrings.forEach(s => {
                        const voltStr = s.volt !== null && s.volt !== undefined ? `${Number(s.volt).toFixed(1)}V` : '-';
                        const currStr = s.current !== null && s.current !== undefined ? `${Number(s.current).toFixed(1)}A` : '-';
                        const pvColor = (Number(s.power) === 0) ? 'var(--text-secondary)' : 'var(--color-success)';
                        pvHtml += `<div class="stat-item" style="min-width:90px;padding:10px;text-align:center">
                            <div class="value" style="font-size:18px;font-weight:700;color:${pvColor}">${fmtKW(s.power)}</div>
                            <div class="label" style="font-size:12px;color:var(--accent-blue);margin-top:4px;font-weight:600">PV${s.idx}</div>
                            <div style="font-size:10px;color:var(--text-secondary);margin-top:4px">${voltStr} · ${currStr}</div>
                        </div>`;
                    });
                    pvHtml += '</div>';
                    card.innerHTML = html + pvHtml;
                } else {
                    card.innerHTML = html;
                }
            } else if (name === 'Battery SoC' && data.result) {
                const r = data.result;
                card.innerHTML = `<div class="stat-row">
                    <div class="stat-item"><div class="value">${r.minSoc || '-'}%</div><div class="label">Min SoC</div></div>
                    <div class="stat-item"><div class="value">${r.minSocOnGrid || '-'}%</div><div class="label">Min On-Grid</div></div>
                </div>`;
            } else if (name === 'Temperatures' && Array.isArray(result) && result[0]?.datas) {
                const temps = result[0].datas;
                const batTemp = temps.find(t => t.variable === 'batTemperature');
                const ambTemp = temps.find(t => t.variable === 'ambientTemperation');
                const invTemp = temps.find(t => t.variable === 'invTemperation');
                const time = result[0].time || '';

                // Temperature threshold helper: <40 green, <55 amber, >=55 red
                function tempClass(v) {
                    if (v === undefined || v === null || isNaN(Number(v))) return '';
                    const n = Number(v);
                    if (n < 40) return 'price-low';
                    if (n < 55) return 'price-mid';
                    return 'price-high';
                }

                const batCls = tempClass(batTemp?.value);
                const ambCls = tempClass(ambTemp?.value);
                const invCls = tempClass(invTemp?.value);

                card.innerHTML = `
                    <div class="stat-row">
                        <div class="stat-item" style="flex:2">
                            <div class="value ${batCls}" style="font-size:28px">🔋 ${batTemp ? batTemp.value : '-'}°C</div>
                            <div class="label">Battery Temperature</div>
                        </div>
                    </div>
                    <div class="stat-row" style="margin-top:8px">
                        <div class="stat-item"><div class="value ${ambCls}">${ambTemp ? ambTemp.value : '-'}°C</div><div class="label">Ambient</div></div>
                        <div class="stat-item"><div class="value ${invCls}">${invTemp ? invTemp.value : '-'}°C</div><div class="label">Inverter</div></div>
                    </div>
                    <div style="font-size:10px;color:var(--text-secondary);margin-top:6px;text-align:center">${time}</div>`;
            } else if (name === 'Generation' && data.result) {
                const r = data.result;
                card.innerHTML = `<div class="stat-row">
                    <div class="stat-item"><div class="value">${r.today?.toFixed(1) || '-'} kWh</div><div class="label">Today</div></div>
                    <div class="stat-item"><div class="value">${r.month?.toFixed(1) || '-'} kWh</div><div class="label">Month</div></div>
                    <div class="stat-item"><div class="value">${r.cumulative?.toFixed(0) || '-'} kWh</div><div class="label">Total</div></div>
                </div>`;
            } else {
                card.innerHTML = `<div style="color:var(--color-success);font-size:12px">✓ ${name} loaded - see response panel</div>`;
            }
        }

        // Weather
        async function getWeather(force = false) {
            const placeEl = document.getElementById('weatherPlace');
            const rawPlace = (placeEl && typeof placeEl.value === 'string') ? placeEl.value.trim() : '';
            // Guard against the literal string 'undefined' (can appear from bad inputs)
            const cleanRaw = (rawPlace && rawPlace !== 'undefined') ? rawPlace : '';
            const place = cleanRaw || 'Sydney, Australia';
            // normalize back into the input (helps when using autocomplete)
            try { if (placeEl) placeEl.value = (place === 'Sydney, Australia' ? placeEl.value || place : place); } catch (e) {}

            // Prefer the saved user preference input if present (settings page uses id
            // 'preferences_forecastDays'). If not present, use the weatherDays control.
            const prefEl = document.getElementById('preferences_forecastDays');
            const primaryEl = document.getElementById('weatherDays');
            let days = CONFIG?.preferences?.forecastDays || 6;
            try {
                if (prefEl && prefEl.value && String(prefEl.value).trim()) {
                    days = Number(prefEl.value);
                } else if (primaryEl && primaryEl.value && String(primaryEl.value).trim()) {
                    days = Number(primaryEl.value);
                }
            } catch (e) { /* use CONFIG value */ }
            
            // Check if cached weather is still fresh (30 minutes TTL matches backend)
            // IMPORTANT: Cache key must include the requested days so we don't return stale cache
            // when user requests a different number of forecast days
            // ALSO: Invalidate cache if the calendar day has changed to get fresh forecasts
            const cacheState = JSON.parse(localStorage.getItem('cacheState') || '{}');
            const cachedDays = cacheState.weatherDays || 0;
            const cachedDate = cacheState.weatherDate || null;  // Track the calendar day
            const today = new Date().toISOString().substring(0, 10);  // YYYY-MM-DD
            const age = Date.now() - (cacheState.weatherTime || 0);
            
            // Force refresh if requested, page reloaded, or currently impersonating another user
            // (impersonation: admin's localStorage cache has their location, not the target user's)
            const isImpersonating = typeof getImpersonationUid === 'function' && !!getImpersonationUid();
            const shouldBypassCache = force || isPageReload || isImpersonating;
            
            if (!shouldBypassCache && cacheState.weatherTime && age < CONFIG.cache.weather && cachedDays === days && cachedDate === today) {
                // Load cached full weather object and render it
                try {
                    const cachedWeatherFull = JSON.parse(localStorage.getItem('cachedWeatherFull') || '{}');
                    if (cachedWeatherFull.place || cachedWeatherFull.current) {
                        renderWeatherCard(cachedWeatherFull);
                        setLastUpdated('weather');
                        return;
                    }
                } catch (e) { console.error('[Cache] Error loading weather cache:', e); }
            }
            
            const card = document.getElementById('weatherCard');
            card.innerHTML = '<div style="color:var(--text-secondary)">Loading weather...</div>';

            try {
                let url = `/api/weather?place=${encodeURIComponent(place)}&days=${days}`;
                // Add forceRefresh if force flag is set
                if (force) {
                    url += '&forceRefresh=true';
                }
                const resp = await authenticatedFetch(url);
                const data = await resp.json();
                
                // Handle wrapped {errno, result} response format
                let weatherData = data;
                if (data.errno === 0 && data.result) {
                    weatherData = data.result;
                }
                
                // Cache weather data - full object for dashboard, simplified for test.html
                if (weatherData?.hourly) {
                    try {
                        // Cache FULL weather object for rendering on dashboard
                        localStorage.setItem('cachedWeatherFull', JSON.stringify(weatherData));
                        
                        // Also cache simplified data for automation test page
                        const hourly = weatherData.hourly;
                        const current = weatherData.current || {};
                        // Find current hour index for accurate solar radiation
                        // Use API's current time (which is in local timezone) instead of JS Date (which is UTC)
                        let currentHourIdx = 0;
                        if (hourly.time && Array.isArray(hourly.time)) {
                            const currentTime = current?.time || new Date().toISOString();
                            const currentHourStr = currentTime.substring(0, 13); // YYYY-MM-DDTHH
                            currentHourIdx = hourly.time.findIndex(t => t && t.substring(0, 13) === currentHourStr);
                            if (currentHourIdx < 0) currentHourIdx = 0;
                        }
                        const wxCache = {
                            solarRadiation: hourly.shortwave_radiation?.[currentHourIdx] || 0,
                            cloudCover: hourly.cloud_cover?.[currentHourIdx] || hourly.cloudcover?.[currentHourIdx] || 0
                        };
                        localStorage.setItem('cachedWeather', JSON.stringify(wxCache));
                        
                        // Update cache timestamp AND store the requested days and date so we know if cache is valid
                        const cacheState = JSON.parse(localStorage.getItem('cacheState') || '{}');
                        cacheState.weatherTime = Date.now();
                        cacheState.weatherDays = days;  // Store the days count for cache validation
                        cacheState.weatherDate = new Date().toISOString().substring(0, 10);  // Store today's date (YYYY-MM-DD)
                        localStorage.setItem('cacheState', JSON.stringify(cacheState));
                    } catch (e) { /* ignore cache errors */ }
                }
                
                renderWeatherCard(weatherData);
                // mark last updated for weather
                setLastUpdated('weather');

                // Update visible location display with API-resolved name when available
                try {
                    const resolvedDisplay = (weatherData?.place?.resolvedName && !weatherData?.place?.fallback)
                        ? weatherData.place.resolvedName
                        : place;
                    const wDisp = document.getElementById('weatherPlaceDisplay');
                    if (wDisp && resolvedDisplay) wDisp.textContent = resolvedDisplay;
                } catch (e) {}

                // Show full payload in the result panel
                document.getElementById('result').textContent = JSON.stringify(data, null, 2);
                // If API returned a resolved place name, prefer that in the status bar
                document.getElementById('status-bar').style.display = 'flex';
                // Prefer the API-resolved name for display, but only if it was
                // genuinely resolved (i.e. the server did not fall back to defaults).
                // We still derive the dismissal key from resolvedName or the query
                // (so it remains stable across page-load vs manual searches).
                const resolved = (data && data.place && data.place.resolvedName && !data.place.fallback) ? data.place.resolvedName : '';
                // Use the original query as the dismissal key when available so the
                // user-dismiss action applies to their typed query (not a backend
                // resolved/fallback name). Fallback to resolvedName if query missing.
                const locKeySource = (data && data.place && (data.place.query || data.place.resolvedName)) ? (data.place.query || data.place.resolvedName) : place;
                // build a sanitized key for dismissals (use locKeySource so key is stable)
                const locKey = (locKeySource || 'unknown').toString().trim().toLowerCase().replace(/\s+/g,'_').replace(/[^a-z0-9_-]/g,'');
                let endpointText = resolved ? `Weather - ${resolved}` : 'Weather';
                // If server indicated it used fallback coordinates, make that visible to user
                let dismissed = false;
                try { dismissed = !!localStorage.getItem('weatherFallbackDismissed:' + locKey); } catch (e) { dismissed = false; }
                if (data && data.place && data.place.fallback && !dismissed) {
                    endpointText += ' (used fallback coords)';
                    // also make status-bar visually noticeable
                    document.getElementById('status-bar').style.border = '1px solid var(--color-warning)';
                } else {
                    document.getElementById('status-bar').style.border = '';
                }
                document.getElementById('status-bar').querySelector('.endpoint').textContent = endpointText;
            } catch (e) {
                card.innerHTML = `<div style="color:var(--color-danger)">Error: ${e.message}</div>`;
            }
        }

        function weatherCodeToWord(code) {
            // Map Open-Meteo / WMO weather codes to simple one-word descriptions
            const c = Number(code);
            if (c === 0) return 'Clear';
            if (c === 1 || c === 2) return 'Partly Cloudy';
            if (c === 3) return 'Overcast';
            if (c === 45 || c === 48) return 'Fog';
            if ([51,53,55].includes(c)) return 'Drizzle';
            if ([56,57].includes(c)) return 'Freezing Drizzle';
            if ([61,63,65].includes(c)) return 'Rain';
            if ([66,67].includes(c)) return 'Freezing Rain';
            if ([71,73,75,77].includes(c)) return 'Snow';
            if ([80,81,82].includes(c)) return 'Showers';
            if ([85,86].includes(c)) return 'Snow Showers';
            if (c === 95 || c === 96 || c === 99) return 'Thunderstorm';
            return 'Unknown';
        }

        // Ensure Leaflet is loaded (returns a Promise). Loads CSS+JS once via CDN.
        function ensureLeafletLoaded() {
            if (window._leafletPromise) return window._leafletPromise;
            window._leafletPromise = new Promise((resolve, reject) => {
                // If L already exists, resolve immediately
                if (window.L) return resolve(window.L);

                // Load CSS
                try {
                    const cssId = 'leaflet-css';
                    if (!document.getElementById(cssId)) {
                        const link = document.createElement('link');
                        link.id = cssId;
                        link.rel = 'stylesheet';
                        link.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                        link.crossOrigin = '';
                        document.head.appendChild(link);
                    }
                } catch (e) { /* ignore */ }

                // Load script
                const jsId = 'leaflet-js';
                if (document.getElementById(jsId)) {
                    // wait for it to be available
                    const waitForL = setInterval(() => {
                        if (window.L) {
                            clearInterval(waitForL);
                            resolve(window.L);
                        }
                    }, 50);
                    // timeout safety
                    setTimeout(() => { clearInterval(waitForL); if (!window.L) reject(new Error('Leaflet failed to load')); }, 8000);
                    return;
                }

                const script = document.createElement('script');
                script.id = jsId;
                script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                script.async = true;
                script.onload = () => {
                    if (window.L) resolve(window.L);
                    else reject(new Error('Leaflet loaded but L not available'));
                };
                script.onerror = () => reject(new Error('Failed to load Leaflet script'));
                document.head.appendChild(script);
            });
            return window._leafletPromise;
        }

        // Update the small label showing how many days are requested by the control
        function updateWeatherRequestedLabel() {
            try {
                const prefEl = document.getElementById('preferences_forecastDays');
                const el = document.getElementById('weatherDays');
                const lbl = document.getElementById('weatherRequestedLabel');
                if (!lbl) return;
                // Prefer user preferences input if present (settings page may expose it)
                const prefVal = prefEl && prefEl.value ? String(prefEl.value).trim() : null;
                const controlVal = el && el.value ? String(el.value).trim() : null;
                const v = prefVal || controlVal || String(CONFIG?.preferences?.forecastDays || 6);
                lbl.textContent = `${v}d`;
            } catch (e) { /* ignore */ }
        }

        function renderWeatherCard(data) {
            const card = document.getElementById('weatherCard');
            if (!data) { card.innerHTML = '<div style="color:var(--color-danger)">No data</div>'; return; }

            const place = data.place || {};
            const current = data.current || null;
            const daily = data.daily || null;

            // Build a concise location header: prefer API-resolved name, show country and coords if available
            // Show the resolved name when available. If the server used fallback
            // coordinates, prefer a friendly `fallbackResolvedName` (provided by
            // the backend) so we can display a human-readable fallback place.
            let locName = '';
            if (place && typeof place === 'object') {
                const tryName = (v) => (v === undefined || v === null || String(v).toLowerCase() === 'undefined') ? '' : String(v);
                if (place.fallback && tryName(place.fallbackResolvedName)) {
                    locName = tryName(place.fallbackResolvedName);
                } else if (tryName(place.resolvedName) && !place.fallback) {
                    locName = tryName(place.resolvedName);
                }
            }
            const lat = (place.latitude !== undefined && place.latitude !== null) ? Number(place.latitude).toFixed(4) : null;
            const lon = (place.longitude !== undefined && place.longitude !== null) ? Number(place.longitude).toFixed(4) : null;
            // sanitized key for map/banner instances (based on user's query when available)
            const locKey = (place.query || place.resolvedName || 'unknown').toString().trim().toLowerCase().replace(/\s+/g,'_').replace(/[^a-z0-9_-]/g,'');
            const country = place.country || '';
            let locExtra = '';
            if (country) locExtra += country;
            if (lat !== null && lon !== null) locExtra += (locExtra ? ' • ' : '') + `${lat}, ${lon}`;
            // Show weather source (Open-Meteo)
            const source = data.source || 'open-meteo';
            if (locExtra) locExtra += ` • <span style="opacity:0.7">${source}</span>`;
            else if (lat !== null && lon !== null) locExtra = `${lat}, ${lon} • <span style="opacity:0.7">${source}</span>`;
            else locExtra = `<span style="opacity:0.7">${source}</span>`;
            // If the API resolved a location name, show it. If not, show a friendly
            // label and include an info icon when the server fell back to coordinates.
            let headerTooltip = '';
            if (place && place.fallback) {
                const reasonText = (place.fallbackReason || 'unknown').replace(/_/g,' ');
                headerTooltip = ` <span class="info-tip" title="Using fallback coordinates: ${reasonText}">ⓘ</span>`;
            }
            let html = `<div style="font-weight:600;color:var(--accent-blue);margin-bottom:6px">${locName || 'Unknown location'}${headerTooltip}</div>`;
            if (locExtra) html += `<div style="font-size:12px;color:var(--text-secondary);margin-bottom:8px">${locExtra}</div>`;

            // Show a visible, dismissible warning when the backend had to use fallback coordinates
            if (place && place.fallback) {
                const reason = place.fallbackReason || 'unknown';
                // Prefer the original query when building the banner key so dismissal
                // is associated with what the user typed, not the backend's resolved label.
                const locKeyBanner = (place.query || place.resolvedName || '').toString().trim().toLowerCase().replace(/\s+/g,'_').replace(/[^a-z0-9_-]/g,'');
                let dismissedBanner = false;
                try { dismissedBanner = !!localStorage.getItem('weatherFallbackDismissed:' + locKeyBanner); } catch (e) { dismissedBanner = false; }
                if (!dismissedBanner) {
                    html += `<div id="weather-fallback-banner-${locKeyBanner}" style="margin-top:8px;padding:10px 14px;border-radius:8px;background:linear-gradient(90deg,color-mix(in srgb,var(--color-warning) 15%,var(--bg-card)),color-mix(in srgb,var(--color-warning) 25%,var(--bg-card)));color:var(--text-primary);font-size:13px;display:flex;align-items:flex-start;gap:10px;justify-content:space-between">
                        <div style="flex:1;line-height:1.6;">
                            <div><strong>⚠️ Location not resolved</strong> — showing weather for approximate fallback coordinates.</div>
                            <div style="font-size:12px;margin-top:4px;opacity:0.9;">To fix: go to <a href="settings.html" style="color:var(--color-warning);text-decoration:underline;">Settings → Preferences</a> and set your location as <strong>City, Country</strong> — for example <em>Sydney, Australia</em> or <em>London, UK</em>.</div>
                        </div>
                        <div style="flex:0 0 auto;margin-left:12px;margin-top:2px;"><button onclick="dismissWeatherFallback('${locKeyBanner}')" style="background:transparent;border:1px solid var(--border-primary);color:var(--text-primary);padding:5px 10px;border-radius:6px;cursor:pointer;font-size:12px;">Dismiss</button></div>
                    </div>`;
                }
            }

            if (current) {
                // Determine today's weather description and rainfall if available
                const todayCode = (current.weathercode !== undefined && current.weathercode !== null) ? current.weathercode : (daily && daily.weathercode ? daily.weathercode[0] : null);
                const todayDesc = todayCode !== null ? weatherCodeToWord(todayCode) : 'Unknown';
                const rainArr = daily && (daily.precipitation_sum || daily.precipitation || daily.rain_sum) ? (daily.precipitation_sum || daily.precipitation || daily.rain_sum) : null;
                const todayRain = (rainArr && rainArr[0] !== undefined) ? Number(rainArr[0]) : null;

                // windInfo: prefer current.windspeed and current.winddirection when supplied (Open-Meteo style)
                function degToCompass(num) {
                    if (num === null || num === undefined || isNaN(Number(num))) return '';
                    const val = Math.floor((Number(num) / 22.5) + 0.5);
                    const arr = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'];
                    return arr[(val % 16)];
                }

                const windSpeed = (current.windspeed !== undefined && current.windspeed !== null) ? Number(current.windspeed) : null;
                const windDirDeg = (current.winddirection !== undefined && current.winddirection !== null) ? Number(current.winddirection) : null;
                const windDirName = windDirDeg !== null ? degToCompass(windDirDeg) : '';

                const nowTemp = (current.temperature !== undefined && current.temperature !== null && String(current.temperature).toLowerCase() !== 'undefined') ? `${current.temperature}°` : '—';
                // Extract time from current.time (ISO format: YYYY-MM-DDTHH:MM)
                let nowTimeStr = '';
                if (current.time && typeof current.time === 'string') {
                    const timePart = current.time.split('T')[1];
                    if (timePart) nowTimeStr = timePart.substring(0, 5); // HH:MM
                }
                const nowLabel = nowTimeStr ? `Now (${nowTimeStr})` : 'Now';
                html += `<div class="live-stat"><span class="value">${nowTemp}</span><span class="unit">C</span><span class="label">${nowLabel}</span></div>`;

                // Determine current shortwave radiation and cloudcover.
                let currentRad = null;
                let currentCloud = null;
                try {
                    if (current.shortwave_radiation !== undefined && current.shortwave_radiation !== null) {
                        currentRad = current.shortwave_radiation;
                    } else if (data.hourly && Array.isArray(data.hourly.time) && Array.isArray(data.hourly.shortwave_radiation)) {
                        const times = data.hourly.time;
                        const radArr = data.hourly.shortwave_radiation;
                        let idx = -1;
                        if (current.time) idx = times.indexOf(current.time);
                        if (idx === -1) {
                            const nowHour = (current.time ? current.time.substring(0,13) : new Date().toISOString().substring(0,13));
                            for (let k = 0; k < times.length; k++) {
                                if (times[k] && times[k].substring(0,13) === nowHour) { idx = k; break; }
                            }
                        }
                        if (idx !== -1) currentRad = radArr[idx];
                    }

                    if (current.cloudcover !== undefined && current.cloudcover !== null) {
                        currentCloud = current.cloudcover;
                    } else if (data.hourly && Array.isArray(data.hourly.time) && Array.isArray(data.hourly.cloudcover)) {
                        const times = data.hourly.time;
                        const cloudArr = data.hourly.cloudcover;
                        let idx = -1;
                        if (current.time) idx = times.indexOf(current.time);
                        if (idx === -1) {
                            const nowHour = (current.time ? current.time.substring(0,13) : new Date().toISOString().substring(0,13));
                            for (let k = 0; k < times.length; k++) {
                                if (times[k] && times[k].substring(0,13) === nowHour) { idx = k; break; }
                            }
                        }
                        if (idx !== -1) currentCloud = cloudArr[idx];
                    }
                } catch (e) { /* ignore */ }

                html += `<div style="margin-top:8px;font-size:13px;color:var(--text-secondary)">${todayDesc} • Rain: ${todayRain !== null ? todayRain.toFixed(1) + ' mm' : '—'}`;
                if (windSpeed !== null) html += ` • Wind: <strong style="color:var(--text-primary)">${windSpeed.toFixed(1)} km/h</strong>${windDirName ? ' ' + windDirName : ''}`;
                // Add current radiance/cloud values (use units W/m² for radiation)
                html += ` • <span title="Current shortwave radiation">☀️ ${currentRad !== null ? String(currentRad) + ' W/m²' : '—'}</span>`;
                html += ` • <span title="Current cloud cover">☁️ ${currentCloud !== null ? String(currentCloud) + '%' : '—'}</span>`;
                html += `</div>`;
            }

            if (daily && daily.time) {
                // Compute daily averages from hourly data for solar radiation and cloud cover
                const hourly = data.hourly || {};
                const hourlyTimes = hourly.time || [];
                const hourlyRadiation = hourly.shortwave_radiation || [];
                const hourlyCloudcover = hourly.cloudcover || [];
                
                // Group hourly data by day (YYYY-MM-DD)
                const dailyRadiationAvg = {};
                const dailyCloudcoverAvg = {};
                for (let hi = 0; hi < hourlyTimes.length; hi++) {
                    const dayKey = hourlyTimes[hi]?.substring(0, 10);
                    if (!dayKey) continue;
                    if (!dailyRadiationAvg[dayKey]) dailyRadiationAvg[dayKey] = { sum: 0, count: 0 };
                    if (!dailyCloudcoverAvg[dayKey]) dailyCloudcoverAvg[dayKey] = { sum: 0, count: 0 };
                    if (hourlyRadiation[hi] !== null && hourlyRadiation[hi] !== undefined) {
                        dailyRadiationAvg[dayKey].sum += hourlyRadiation[hi];
                        dailyRadiationAvg[dayKey].count++;
                    }
                    if (hourlyCloudcover[hi] !== null && hourlyCloudcover[hi] !== undefined) {
                        dailyCloudcoverAvg[dayKey].sum += hourlyCloudcover[hi];
                        dailyCloudcoverAvg[dayKey].count++;
                    }
                }
                
                html += '<div class="weather-days">';
                // Get the user's requested number of days from the input field
                const weatherDaysInput = document.getElementById('weatherDays');
                const requestedDays = weatherDaysInput ? Number(weatherDaysInput.value) : 6;
                // Show up to the requested number of days, but not more than available
                const showCount = Math.min(daily.time.length, Math.max(1, requestedDays));
                for (let i = 0; i < showCount; i++) {
                    const d = daily.time[i];
                    const dayKey = d?.substring(0, 10);
                    const tmax = (daily.temperature_2m_max && daily.temperature_2m_max[i] !== undefined && daily.temperature_2m_max[i] !== null && String(daily.temperature_2m_max[i]).toLowerCase() !== 'undefined') ? daily.temperature_2m_max[i] : '-';
                    const tmin = (daily.temperature_2m_min && daily.temperature_2m_min[i] !== undefined && daily.temperature_2m_min[i] !== null && String(daily.temperature_2m_min[i]).toLowerCase() !== 'undefined') ? daily.temperature_2m_min[i] : '-';
                    const code = (daily.weathercode && daily.weathercode[i] !== undefined) ? daily.weathercode[i] : null;
                    const desc = code !== null ? weatherCodeToWord(code) : 'Unknown';
                    // precipitation_sum can be named differently depending on API fields
                    const rainArr = daily.precipitation_sum || daily.precipitation || daily.rain_sum || null;
                    const rain = (rainArr && rainArr[i] !== undefined) ? Number(rainArr[i]) : null;
                    
                    // Daily averages for solar radiation and cloud cover
                    const radAvg = dailyRadiationAvg[dayKey]?.count > 0 ? Math.round(dailyRadiationAvg[dayKey].sum / dailyRadiationAvg[dayKey].count) : null;
                    const cloudAvg = dailyCloudcoverAvg[dayKey]?.count > 0 ? Math.round(dailyCloudcoverAvg[dayKey].sum / dailyCloudcoverAvg[dayKey].count) : null;
                    
                    // Sunrise/sunset from daily data
                    const sunrise = daily.sunrise?.[i] ? daily.sunrise[i].split('T')[1]?.substring(0, 5) : null;
                    const sunset = daily.sunset?.[i] ? daily.sunset[i].split('T')[1]?.substring(0, 5) : null;

                    // Detect "extreme" conditions for this day so we can visually highlight them.
                    // Rules (tunable): heavy rain >= 10mm, very hot high >= 35°C, very cold low <= 0°C,
                    // or descriptions that mention storm/thunder/snow/hail/sleet/blizzard/heavy
                    const extremeReasons = [];
                    try {
                        if (rain !== null && !isNaN(rain) && rain >= 10) extremeReasons.push(`Heavy rain: ${rain.toFixed(1)} mm`);
                        if (!isNaN(Number(tmax)) && Number(tmax) >= 35) extremeReasons.push(`High heat: ${Number(tmax)}°`);
                        if (!isNaN(Number(tmin)) && Number(tmin) <= 0) extremeReasons.push(`Very cold: ${Number(tmin)}°`);
                        if (desc && /thunder|storm|snow|sleet|hail|blizzard|heavy/i.test(String(desc))) extremeReasons.push(String(desc));
                    } catch (e) { /* ignore detection errors */ }
                    const isExtreme = extremeReasons.length > 0;
                    const extremeClass = isExtreme ? ' extreme' : '';
                    const extremeTitle = isExtreme ? ` title="${extremeReasons.join('; ')}"` : '';
                    
                    // Solar indicator color: green (good) > 300, yellow 100-300, red < 100
                    const radColor = radAvg === null ? 'var(--text-secondary)' : radAvg > 300 ? 'var(--color-success)' : radAvg > 100 ? 'var(--color-orange)' : 'var(--color-danger)';
                    // Cloud indicator color: green (clear) < 30, yellow 30-70, red > 70
                    const cloudColor = cloudAvg === null ? 'var(--text-secondary)' : cloudAvg < 30 ? 'var(--color-success)' : cloudAvg < 70 ? 'var(--color-orange)' : 'var(--color-danger)';

                    html += `<div class="stat-item${extremeClass}"${extremeTitle}>
                        <div style="font-size:12px;font-weight:700;color:var(--text-primary)">${formatForecastDay(d)}</div>
                        <div style="font-size:13px;color:var(--accent-blue);font-weight:600;margin-top:4px">${desc}</div>
                        <div style="font-size:12px;color:var(--text-secondary);margin-top:4px">High ${tmax}° / Low ${tmin}°</div>
                        <div style="font-size:11px;color:var(--color-success);margin-top:3px">Rain: ${rain !== null ? rain.toFixed(1) + ' mm' : '—'}</div>
                        <div style="display:flex;gap:6px;margin-top:4px;flex-wrap:wrap">
                            <span style="font-size:10px;color:${radColor}" title="Avg solar radiation (W/m²)">☀️${radAvg !== null ? radAvg : '—'}</span>
                            <span style="font-size:10px;color:${cloudColor}" title="Avg cloud cover %">☁️${cloudAvg !== null ? cloudAvg + '%' : '—'}</span>
                        </div>
                    </div>`;
                }
                html += '</div>';
            }

            // Insert a small inline map below the weather content when we have coordinates
            if (lat !== null && lon !== null) {
                html += `<div class="weather-map" id="weather-map-${locKey}"></div>`;
            }

            card.innerHTML = html;

            // Initialize or update the inline Leaflet map for this location
            try {
                if (lat !== null && lon !== null) {
                    // Retry loop to ensure container is ready and Leaflet loads
                    let attempts = 0;
                    const mapId = 'weather-map-' + locKey;
                    function tryInitMap() {
                        const mapEl = document.getElementById(mapId);
                        // Only attempt to initialize when element exists and is laid out
                        // (non-zero width/height). When forecast count is large the
                        // element may be present but not yet painted or sized.
                        if (mapEl && (mapEl.offsetWidth === 0 || mapEl.offsetHeight === 0)) {
                            // wait longer for layout to stabilise
                            if (attempts < 60) {
                                attempts++;
                                const delay = attempts < 12 ? 100 : 160; // back off a bit
                                setTimeout(tryInitMap, delay);
                                return;
                            }
                        }
                        if (!mapEl) {
                            // When many tiles are rendered the browser may take longer to
                            // parse/paint the large innerHTML blob. Retry longer to ensure
                            // the container appears before giving up.
                            if (attempts < 40) {
                                attempts++;
                                // progressive backoff: start fast then slow down
                                const delay = attempts < 8 ? 80 : 120;
                                setTimeout(tryInitMap, delay);
                            } else {
                                console.warn('Leaflet map container not found after retries:', mapId);
                                // Show error in container if the element exists later
                                if (mapEl) mapEl.innerHTML = '<div style="color:var(--color-danger);font-size:13px;padding:8px">Map container not found</div>';
                            }
                            return;
                        }
                        ensureLeafletLoaded().then(() => {
                            try {
                                if (!window.weatherMaps) window.weatherMaps = {};
                                const latNum = Number(place.latitude);
                                const lonNum = Number(place.longitude);
                                // Reuse existing map instance if present
                                if (window.weatherMaps[mapId]) {
                                    let m = window.weatherMaps[mapId];
                                    // If the stored map instance is attached to an old/removed container
                                    // (card.innerHTML was replaced), recreate the map on the new element.
                                    try {
                                        const currentContainer = m.getContainer && m.getContainer();
                                        if (!currentContainer || currentContainer !== mapEl) {
                                            try {
                                                // disconnect any attached observers/listeners before removing
                                                try { if (m._resizeObserver) m._resizeObserver.disconnect(); } catch(e){}
                                                try { if (m._resizeListener) window.removeEventListener('resize', m._resizeListener); } catch(e){}
                                                m.remove && m.remove();
                                            } catch (err) { /* ignore */ }
                                            // drop stale instance so we create a fresh one below
                                            delete window.weatherMaps[mapId];
                                            m = null;
                                        }
                                    } catch (err) {
                                        // If anything goes wrong checking container, prefer to recreate
                                        try { m.remove && m.remove(); } catch (e){}
                                        delete window.weatherMaps[mapId];
                                        m = null;
                                    }
                                    if (m) {
                                    m.setView([latNum, lonNum], 9);
                                    try { if (m._weatherMarker) m.removeLayer(m._weatherMarker); } catch(e){}
                                    const mark = L.circleMarker([latNum, lonNum], { radius:6, fillColor:'#58a6ff', color:'#fff', weight:1, fillOpacity:0.95 }).addTo(m);
                                    m._weatherMarker = mark;
                                        // In some cases reflow needs multiple ticks — call invalidate repeatedly
                                        const invalidate = () => {
                                            try { m.invalidateSize && m.invalidateSize(); if (m._weatherMarker) m._weatherMarker.setLatLng([latNum, lonNum]); } catch(e){}
                                        };
                                        requestAnimationFrame(invalidate);
                                        setTimeout(invalidate, 160);
                                        setTimeout(invalidate, 420);
                                        setTimeout(invalidate, 900);
                                        setTimeout(invalidate, 1600);
                                        // Ensure map invalidates when its container or window resizes
                                        try {
                                            if (!m._resizeObserver && 'ResizeObserver' in window) {
                                                const ro = new ResizeObserver(() => { try { m.invalidateSize && m.invalidateSize(); } catch(e){} });
                                                ro.observe(mapEl);
                                                m._resizeObserver = ro;
                                            } else if (!m._resizeListener) {
                                                const onWin = () => { try { m.invalidateSize && m.invalidateSize(); } catch(e){} };
                                                window.addEventListener('resize', onWin);
                                                m._resizeListener = onWin;
                                            }
                                        } catch(e) {}
                                    } else {
                                        // Removed stale map instance — fall through to create a new map below
                                    }
                                } else {
                                    const m = L.map(mapId, { zoomControl:false, attributionControl:false, dragging:false, scrollWheelZoom:false, doubleClickZoom:false, boxZoom:false, touchZoom:false }).setView([latNum, lonNum], 9);
                                    const tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 });
                                    // diagnostic counters & handlers
                                    let tileLoadCount = 0;
                                    // lightweight in-map diagnostics node
                                    function ensureDiagNode() {
                                        const el = document.getElementById(mapId);
                                        if (!el) return null;
                                        return null;
                                    }
                                    tileLayer.on('tileload', function (ev) {
                                        tileLoadCount++;
                                        // ensure the specific tile is visible (fallback if stylesheet didn't load)
                                        try { if (ev && ev.tile) { ev.tile.style.opacity = '1'; ev.tile.style.visibility = 'visible'; ev.tile.style.filter = 'none'; } } catch(e){}
                                        // ...existing code...
                                    });
                                    tileLayer.on('load', function () {
                                        // ...existing code...
                                    });
                                    tileLayer.on('tileerror', function (ev) {
                                        const mapEl = document.getElementById(mapId);
                                        console.warn('tileerror', mapId, ev);
                                        // ...existing code...
                                    });
                                    tileLayer.addTo(m);
                                    const mark = L.circleMarker([latNum, lonNum], { radius:6, fillColor:'#58a6ff', color:'#fff', weight:1, fillOpacity:0.95 }).addTo(m);
                                    m._weatherMarker = mark;
                                    window.weatherMaps[mapId] = m;
                                    // Attach a ResizeObserver so the map adapts to the card/panel width
                                    try {
                                        if ('ResizeObserver' in window) {
                                            const ro2 = new ResizeObserver(() => { try { m.invalidateSize && m.invalidateSize(); } catch(e){} });
                                            const mapElNow = document.getElementById(mapId);
                                            if (mapElNow) {
                                                ro2.observe(mapElNow);
                                                m._resizeObserver = ro2;
                                            }
                                        } else {
                                            const onWin2 = () => { try { m.invalidateSize && m.invalidateSize(); } catch(e){} };
                                            window.addEventListener('resize', onWin2);
                                            m._resizeListener = onWin2;
                                        }
                                    } catch(e) {}
                                    setTimeout(() => { try { m.invalidateSize && m.invalidateSize(); } catch(e){} }, 200);
                                    // Ensure map also invalidates a bit later to handle large DOM updates
                                    setTimeout(() => { try { m.invalidateSize && m.invalidateSize(); } catch(e){} }, 800);
                                    // Extra diagnostics: log map size and tile container children
                                            setTimeout(() => {
                                        try {
                                            const size = m.getSize();
                                            const tileContainer = mapEl.querySelector('.leaflet-tile-pane');
                                            const tiles = tileContainer ? tileContainer.querySelectorAll('img') : [];
                                            // If no tiles loaded after a short delay, attempt a direct tile test by requesting a single tile image
                                            if (tileLoadCount === 0) {
                                                try {
                                                    const z = 9;
                                                    // convert lat/lon to tile xy for zoom z
                                                    function long2tile(lon, z) { return Math.floor((lon + 180) / 360 * Math.pow(2, z)); }
                                                    function lat2tile(lat, z) { return Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, z)); }
                                                    const tx = long2tile(latNum ? lonNum : 151.03, z);
                                                    const ty = lat2tile(latNum ? latNum : -33.92, z);
                                                    const tileUrl = `https://a.tile.openstreetmap.org/${z}/${tx}/${ty}.png`;
                                                    const tImg = new Image();
                                                    tImg.crossOrigin = 'anonymous';
                                                    tImg.onload = function() {
                                                        // ...existing code...
                                                    };
                                                    tImg.onerror = function(err) {
                                                        console.warn('Direct tile failed to load', err);
                                                        // ...existing code...
                                                    };
                                                    tImg.src = tileUrl;
                                                } catch(e) { console.error('direct tile test failed', e); }
                                            }
                                        } catch (e) { console.error('map diag error', e); }
                                            }, 600);
                                            // extra run: collect per-tile diagnostics and display them
                                            setTimeout(() => {
                                                try {
                                                    const mapEl2 = document.getElementById(mapId);
                                                    if (!mapEl2) return;
                                                    const tilePane = mapEl2.querySelector('.leaflet-tile-pane');
                                                    const tiles = tilePane ? Array.from(tilePane.querySelectorAll('img')) : [];
                                                    const diag2 = ensureDiagNode();
                                                    if (diag2) {
                                                        if (tiles.length === 0) {
                                                            diag2.textContent = (diag2.textContent || '') + ' | tiles:0';
                                                        } else {
                                                            let info = ' | tiles:' + tiles.length + ' [';
                                                            info += tiles.slice(0,6).map(img => {
                                                                const src = img.src.split('/').slice(-3).join('/');
                                                                const cw = img.naturalWidth || img.width || 0;
                                                                const ch = img.naturalHeight || img.height || 0;
                                                                const style = window.getComputedStyle(img);
                                                                return `${src} w:${cw} h:${ch} d:${style.display} o:${style.opacity}`;
                                                            }).join(' ; ');
                                                            info += (tiles.length > 6 ? ' …' : '') + ']';
                                                            diag2.textContent = (diag2.textContent || '') + info;
                                                        }
                                                    }
                                                } catch(e) { console.error('tile diagnostics 2 error', e); }
                                            }, 900);
                                }
                            } catch (e) {
                                console.error('Map init error:', e);
                                mapEl.innerHTML = '<div style="color:var(--color-danger);font-size:13px;padding:8px">Map init error: ' + e.message + '</div>';
                            }
                        }).catch((e) => {
                            console.error('Leaflet failed to load:', e);
                            mapEl.innerHTML = '<div style="color:var(--color-danger);font-size:13px;padding:8px">Leaflet failed to load</div>';
                        });
                    }
                    setTimeout(tryInitMap, 120);
                }
            } catch (e) { /* ignore */ }

            // Populate debug raw intervals list for feed-in so we can compare exact nemTime/perKwh/spotPerKwh
            const rawDiv = document.getElementById('amberRaw');
            if (rawDiv) {
                const feedList = feedIn.slice(0, 48); // up to next 48 intervals
                if (feedList.length === 0) {
                    rawDiv.style.display = 'none';
                } else {
                    let rawHtml = '<div style="font-weight:600;margin-bottom:6px">Raw Feed-in Intervals (nemTime / spot / perKwh)</div>';
                    rawHtml += '<div style="display:flex;flex-direction:column;gap:6px">';
                    feedList.forEach(it => {
                        const nem = it.nemTime || it.startTime;
                        const spot = (typeof it.spotPerKwh === 'number') ? it.spotPerKwh.toFixed(3) : 'n/a';
                        const per = (typeof it.perKwh === 'number') ? it.perKwh.toFixed(3) : 'n/a';
                        // Format nemTime to DD/MM/YYYY HH:MM when possible
                        let nemFormatted = nem;
                        try {
                            const nd = new Date(nem);
                            if (!isNaN(nd.getTime())) nemFormatted = formatDate(nd, true);
                        } catch(e) {}
                        rawHtml += `<div style="padding:6px;background:var(--bg-input);border-radius:6px">${nemFormatted} — spot: <strong style=\"color:${(parseFloat(spot) < 0 ? 'var(--color-danger)' : 'var(--color-success)')}\">${spot}¢</strong> — per: <strong>${per}¢</strong></div>`;
                    });
                    rawHtml += '</div>';
                    rawDiv.style.display = 'block';
                    rawDiv.innerHTML = rawHtml;
                }
            }
        }

        // Amber
        let amberSites = [];
        
        async function loadAmberSites(forceRefresh = false) {
            const select = document.getElementById('amberSiteId');
            const card = document.getElementById('amberCard');
            select.innerHTML = '<option value="">Loading...</option>';
            
            try {
                let url = '/api/amber/sites';
                if (forceRefresh) {
                    url += '?forceRefresh=true';
                }
                const resp = await authenticatedFetch(url);
                const json = await resp.json();
                
                // Extract sites array from response
                let sites = [];
                if (Array.isArray(json)) {
                    sites = json;
                } else if (json && json.result) {
                    sites = Array.isArray(json.result) ? json.result : [];
                } else if (json && json.sites) {
                    sites = json.sites;
                }
                
                if (sites.length > 0) {
                    amberSites = sites;
                    select.innerHTML = sites.map(s => `<option value="${s.id}">${s.nmi} (${s.network})</option>`).join('');
                    // Select the first site by default
                    if (select.options.length > 0) {
                        select.selectedIndex = 0;
                    }
                    card.innerHTML = `<div style="color:var(--color-success)">✓ ${sites.length} site(s) found</div>`;
                    // Auto-fetch current prices
                    setTimeout(getAmberCurrent, 500);
                } else {
                    select.innerHTML = '<option value="">No sites</option>';
                    card.innerHTML = `<div style="color:var(--color-warning)">No sites found</div>`;
                }
            } catch (e) {
                console.error('[Amber] Error loading sites:', e);
                select.innerHTML = '<option value="">Error</option>';
                card.innerHTML = `<div style="color:var(--color-danger)">Error: ${e.message}</div>`;
            }
        }

        async function getAmberCurrent(force = false) {
            const siteId = document.getElementById('amberSiteId').value;
            if (!siteId) { document.getElementById('amberCard').innerHTML = '<div style="color:var(--color-warning)">Select a site</div>'; return; }
            
            // Check if cached data is still fresh (TTL from backend config)
            const cacheState = JSON.parse(localStorage.getItem('cacheState') || '{}');
            const age = Date.now() - (cacheState.amberTime || 0);
            
            // Force refresh if requested (either explicit parameter or page reload bypass)
            const shouldBypassCache = force || isPageReload;
            
            if (!shouldBypassCache && cacheState.amberTime && age < CONFIG.cache.amber) {
                // Load cached full prices array and render
                try {
                    const cachedPricesFull = JSON.parse(localStorage.getItem('cachedPricesFull') || '[]');
                    if (cachedPricesFull.length > 0) {
                        renderAmberCard(cachedPricesFull);
                        setLastUpdated('amber');
                        return;
                    }
                } catch (e) { console.error('[Cache] Error loading Amber cache:', e); }
            }
            
            const card = document.getElementById('amberCard');
            card.innerHTML = '<div style="color:var(--text-secondary)">Loading prices...</div>';
            
            try {
                const next = Number(document.getElementById('amberNext')?.value) || 12;
                let url = `/api/amber/prices/current?siteId=${siteId}&next=${next}`;
                // Add forceRefresh if force flag is set
                if (force) {
                    url += '&forceRefresh=true';
                }
                const resp = await authenticatedFetch(url);
                const data = await resp.json();
                
                // Handle both wrapped {errno, result} and unwrapped array formats
                let prices = [];
                if (Array.isArray(data)) {
                    prices = data;
                } else if (data?.errno === 0 && Array.isArray(data.result)) {
                    prices = data.result;
                } else if (data?.result && Array.isArray(data.result)) {
                    prices = data.result;
                }
                
                // Cache Amber prices - full array for dashboard, summary for test.html
                if (prices.length > 0) {
                    try {
                        // Cache FULL prices array for rendering on dashboard
                        localStorage.setItem('cachedPricesFull', JSON.stringify(prices));
                        
                        // Also cache simplified data for automation test page
                        const general = prices.find(p => p.channelType === 'general');
                        const feedIn = prices.find(p => p.channelType === 'feedIn');
                        const forecasts = prices.filter(p => p.type === 'ForecastInterval');
                        const priceCache = {
                            general: general ? { perKwh: general.perKwh } : null,
                            feedIn: feedIn ? { perKwh: -feedIn.perKwh } : null,  // Negate for display (Amber returns negative)
                            forecastHigh: forecasts.length > 0 ? Math.max(...forecasts.map(f => f.perKwh || 0)) : null
                        };
                        localStorage.setItem('cachedPrices', JSON.stringify(priceCache));
                        
                        // Update cache timestamp
                        const cacheState = JSON.parse(localStorage.getItem('cacheState') || '{}');
                        cacheState.amberTime = Date.now();
                        localStorage.setItem('cacheState', JSON.stringify(cacheState));
                    } catch (e) { /* ignore cache errors */ }
                }
                
                renderAmberCard(prices);
                // Also set last-updated for amber (history query counts as an update)
                setLastUpdated('amber');
                // mark last updated for amber prices
                setLastUpdated('amber');
                
                document.getElementById('result').textContent = JSON.stringify(data, null, 2);
                document.getElementById('status-bar').style.display = 'flex';
                document.getElementById('status-bar').querySelector('.endpoint').textContent = `Amber Prices`;
            } catch (e) {
                card.innerHTML = `<div style="color:var(--color-danger)">Error: ${e.message}</div>`;
            }
        }

        // Open the Amber history modal
        function openAmberHistoryModal() {
            const today = new Date();
            const yesterday = new Date(today.getTime() - 24*60*60*1000);
            const elStart = document.getElementById('amberHistoryStart');
            const elEnd = document.getElementById('amberHistoryEnd');
            if (elStart) elStart.value = yesterday.toISOString().slice(0,10);
            if (elEnd) elEnd.value = today.toISOString().slice(0,10);
            document.getElementById('amberHistoryModal').classList.add('show');
        }
        function closeAmberHistoryModal() { document.getElementById('amberHistoryModal').classList.remove('show'); }
        
        // Dump full Amber response to debug panel
        function dumpAmberRaw() {
            const resp = window.lastAmberResponse || [];
            const json = JSON.stringify(resp, null, 2);
            const debugEl = document.getElementById('result');
            if (debugEl) {
                debugEl.textContent = json;
                document.getElementById('status-bar').style.display = 'flex';
                document.getElementById('status-bar').querySelector('.endpoint').textContent = 'Amber Raw Response';
            } else {
                alert('Debug panel not available. Response has ' + resp.length + ' items');
            }
        }
        
        // Export Amber data as CSV or JSON
        function exportAmberData(format) {
            const resp = window.lastAmberResponse || [];
            if (!resp.length) { alert('No data to export'); return; }
            let content, filename, mime;
            if (format === 'csv') {
                const headers = ['type','date','startTime','perKwh','spotPerKwh','renewables','spikeStatus','descriptor','channelType','period'];
                const rows = resp.map(r => [
                    r.type, r.date, r.startTime, r.perKwh, r.spotPerKwh, r.renewables, r.spikeStatus, r.descriptor, r.channelType, r.tariffInformation?.period || ''
                ].map(v => typeof v === 'string' && v.includes(',') ? `"${v}"` : v).join(','));
                content = [headers.join(','), ...rows].join('\n');
                filename = 'amber_' + new Date().toISOString().slice(0,10) + '.csv';
                mime = 'text/csv';
            } else {
                content = JSON.stringify(resp, null, 2);
                filename = 'amber_' + new Date().toISOString().slice(0,19).replace(/[-T:]/g, '') + '.json';
                mime = 'application/json';
            }
            const blob = new Blob([content], {type: mime});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function getAmberRange(startDate, endDate) {
            const siteId = document.getElementById('amberSiteId').value;
            if (!siteId) return;

            const card = document.getElementById('amberCard');
            card.innerHTML = '<div style="color:var(--text-secondary)">Loading history...</div>';

            try {
                let s = startDate, e = endDate;
                if (!s || !e) {
                    const today = new Date();
                    const yesterday = new Date(today.getTime() - 24*60*60*1000);
                    s = yesterday.toISOString().slice(0,10);
                    e = today.toISOString().slice(0,10);
                }
                const resp = await authenticatedFetch(`/api/amber/prices?siteId=${siteId}&startDate=${s}&endDate=${e}`);
                const data = await resp.json();
                renderAmberCard(data);
                document.getElementById('result').textContent = JSON.stringify(data, null, 2);
            } catch (e) {
                card.innerHTML = `<div style="color:var(--color-danger)">Error: ${e.message}</div>`;
            }
        }

        function toggleAmberMore() {
            const btn = document.getElementById('amberShowMore');
            if (!btn) return;
            const isShowingAll = btn.dataset.showAll === '1';
            // Toggle state and request appropriate number of intervals
            if (isShowingAll) {
                btn.dataset.showAll = '0';
                // restore to default smaller fetch
                const nextEl = document.getElementById('amberNext');
                if (nextEl) nextEl.value = '288';
            } else {
                btn.dataset.showAll = '1';
                // request a larger window to see more intervals
                const nextEl = document.getElementById('amberNext');
                if (nextEl) nextEl.value = '500';
            }
            // Fetch fresh data so count/limits are accurate
            getAmberCurrent();
        }

        function renderAmberCard(data) {
            const card = document.getElementById('amberCard');
            // Handle both wrapped {errno, result} and unwrapped array formats
            let intervals = [];
            if (Array.isArray(data)) {
                intervals = data;
            } else if (data?.result && Array.isArray(data.result)) {
                intervals = data.result;
            }
            if (!intervals.length) { card.innerHTML = '<div style="color:var(--color-warning)">No data</div>'; return; }
            window.lastAmberResponse = intervals; // Store for raw dump and export

            const general = intervals.filter(i => i.channelType === 'general');
            const feedIn = intervals.filter(i => i.channelType === 'feedIn');
            const currentGen = general.find(i => i.type === 'CurrentInterval');
            const currentFeed = feedIn.find(i => i.type === 'CurrentInterval');
            const forecasts = general.filter(i => i.type === 'ForecastInterval');
            const feedForecasts = feedIn.filter(i => i.type === 'ForecastInterval');

            // Detect spikes in forecasts
            const spikeForecasts = forecasts.filter(i => i.spikeStatus && i.spikeStatus !== 'none');
            const hasSpikes = spikeForecasts.length > 0;
            
            // How many forecasts to show (use button dataset for show-all state)
            const showAllBtn = document.getElementById('amberShowMore');
            const showAll = showAllBtn?.dataset?.showAll === '1';
            // If show-all is enabled, display everything returned; otherwise show 12
            const forecastLimit = showAll ? forecasts.length : Math.min(forecasts.length, 12);

            // Find price extremes in DISPLAYED forecasts only (to align with tiles)
            const displayForecasts = forecasts.slice(0, forecastLimit);
            const displayFeedForecasts = feedForecasts.slice(0, forecastLimit);
            
            const maxBuyPrice = displayForecasts.length ? Math.max(...displayForecasts.map(i => i.perKwh)) : 0;
            const minBuyPrice = displayForecasts.length ? Math.min(...displayForecasts.map(i => i.perKwh)) : 0;
            // Compute feed-in display values (positive = earning money)
            const feedDisplayValues = displayFeedForecasts.length ? displayFeedForecasts.map(it => {
                try {
                    if (window.sharedUtils && typeof window.sharedUtils.feedDisplayValue === 'function') {
                        // Negate to convert Amber's negative values to positive display
                        return -Math.round(it.perKwh);
                    }
                } catch (e) {
                    // fall through to inline transform
                }
                return -Math.round(it.perKwh);  // Negate Amber's negative values
            }) : [];
            const minFeedSpot = feedDisplayValues.length ? Math.min(...feedDisplayValues) : 0;
            const maxFeedSpot = feedDisplayValues.length ? Math.max(...feedDisplayValues) : 0;

            let html = '';

            // Compact info row: forecast count and time range
            try {
                const returned = forecasts.length;
                const lastInterval = forecasts.length ? new Date(forecasts[forecasts.length-1].startTime).toLocaleString('en-AU', {hour:'2-digit',minute:'2-digit', day:'2-digit', month:'2-digit', hour12:false, timeZone: USER_TZ || 'Australia/Sydney'}) : '—';
                html += `<div style="font-size:11px;color:var(--text-secondary);margin-bottom:8px">
                    <strong>${returned}</strong> forecast intervals available — until <strong>${lastInterval}</strong>
                </div>`;
                // Update the external show-all button label
                const btn = document.getElementById('amberShowMore');
                if (btn) {
                    const isShowingAll = btn.dataset.showAll === '1';
                    btn.textContent = isShowingAll ? 'Show less' : `Show all (${returned})`;
                }
            } catch(e) { /* ignore diagnostics errors */ }

            // Helper: format a price (val in cents). Values >= 100¢ shown as $X.YY, else as XX.XX¢
            function formatPrice(val) {
                const n = Number(val) || 0;
                const neg = n < 0;
                const abs = Math.abs(n);
                if (abs >= 100) {
                    // Format as dollar amount with 2 decimal places
                    const s = `$${(abs / 100).toFixed(2)}`;
                    return neg ? `-${s}` : s;
                }
                // Format as cents - show decimal only if needed
                const s = abs >= 10 ? `${abs.toFixed(1)}¢` : `${abs.toFixed(2)}¢`;
                return neg ? `-${s}` : s;
            }

            // Spike Alert Banner (if any forecasted spikes)
            if (hasSpikes) {
                const nextSpike = spikeForecasts[0];
                const spikeTime = new Date(nextSpike.startTime).toLocaleTimeString('en-AU', {hour:'2-digit', minute:'2-digit', hour12:false, timeZone: USER_TZ || 'Australia/Sydney'});
                const spikePrice = formatPrice(nextSpike.perKwh);
                html += `<div style="background:color-mix(in srgb, var(--color-danger) 15%, transparent);border:1px solid color-mix(in srgb, var(--color-danger) 40%, transparent);border-radius:8px;padding:10px;margin-bottom:12px;display:flex;align-items:center;gap:10px">
                    <span style="font-size:24px">⚠️</span>
                    <div>
                        <div style="font-weight:600;color:var(--color-danger)">Price Spike Forecast</div>
                        <div style="font-size:12px;color:var(--text-primary)">${spikeForecasts.length} spike${spikeForecasts.length > 1 ? 's' : ''} expected — next at <strong>${spikeTime}</strong> (${spikePrice})</div>
                    </div>
                </div>`;
            }

            // Current Prices Row
            if (currentGen || currentFeed) {
                html += '<div style="display:flex;gap:16px;margin-bottom:12px;flex-wrap:wrap">';
                if (currentGen) {
                    const p = currentGen.perKwh;
                    const spot = currentGen.spotPerKwh;
                    const cls = p > 30 ? 'price-high' : p > 20 ? 'price-mid' : 'price-low';
                    const spike = currentGen.spikeStatus && currentGen.spikeStatus !== 'none';
                    // Format price using helper function for consistency
                    const priceStr = formatPrice(p);
                    html += `<div style="min-width:100px">
                        <div style="font-size:11px;color:var(--text-secondary)">Buy Now ${spike ? '<span style="color:var(--color-danger)">⚠️</span>' : ''}</div>
                        <div class="value ${cls}" style="font-size:28px;font-weight:700">${priceStr}</div>
                    </div>`;
                }
                if (currentFeed) {
                    // Display feed-in price (what you earn when exporting)
                    // Amber returns NEGATIVE values for feed-in (negative = you earn)
                    // Display as positive for user clarity: -9¢ displays as 9¢
                    const displayVal = -currentFeed.perKwh;
                    function feedClassFromVal(v) {
                        // v is display value in cents (positive = you earn at this rate)
                        if (v < -6) return 'price-high'; // red - paying money (negative feed-in)
                        if (v < 0) return 'price-mid'; // amber - slightly negative
                        if (v < 5) return 'price-neutral'; // grey - very low earnings
                        if (v < 20) return 'price-low'; // green - good rate
                        if (v >= 20) return 'price-darkgreen'; // dark green - excellent rate
                        return 'price-neutral';
                    }
                    const getCls = feedClassFromVal(displayVal);
                    // Format price using helper function for consistency
                    const feedPriceStr = formatPrice(displayVal);
                    html += `<div style="min-width:100px">
                        <div style="font-size:11px;color:var(--text-secondary)">Feed-In Price</div>
                        <div class="value ${getCls}" style="font-size:28px;font-weight:700">${feedPriceStr}</div>
                    </div>`;
                }
                if (currentGen && currentGen.renewables !== undefined) {
                    const renew = currentGen.renewables;
                    // Map renewable descriptor to emoji and color
                    const renewDesc = currentGen.descriptor || '';
                    const renewEmoji = { best: '🌱', great: '🌿', ok: '☁️', notGreat: '🏭', worst: '💨' }[renewDesc] || '';
                    const renewColor = renew > 55 ? cssVar('--color-success') : renew > 35 ? '#ffd43b' : cssVar('--color-danger');
                    html += `<div style="min-width:100px">
                        <div style="font-size:11px;color:var(--text-secondary)">Renewables ${renewEmoji}</div>
                        <div class="value" style="font-size:28px;font-weight:700;color:${renewColor}">${renew.toFixed(0)}%</div>
                    </div>`;
                }
                html += '</div>';
            }

            // Price Range Summary with consistent coloring logic
            if (forecasts.length > 1) {
                // Buy price coloring (low=cheap, high=expensive)
                const minBuyCls = minBuyPrice > 30 ? 'price-high' : minBuyPrice > 20 ? 'price-mid' : 'price-low';
                const maxBuyCls = maxBuyPrice > 30 ? 'price-high' : maxBuyPrice > 20 ? 'price-mid' : 'price-low';
                // Feed-in coloring (high=you earn money, low=you pay)
                function feedClassFromVal(v) {
                    if (v < -6) return 'price-high'; // red - paying money
                    if (v < 0) return 'price-mid'; // amber - slightly negative
                    if (v < 5) return 'price-neutral'; // grey - very low earnings
                    if (v < 20) return 'price-low'; // green - good rate
                    if (v >= 20) return 'price-darkgreen'; // dark green - excellent rate
                    return 'price-neutral';
                }
                const minFeedCls = feedClassFromVal(minFeedSpot);
                const maxFeedCls = feedClassFromVal(maxFeedSpot);
                // Note: `formatPrice` helper is defined earlier to provide consistent formatting
                html += `<div style="display:flex;gap:12px;margin-bottom:12px;padding:8px;background:var(--bg-input);border-radius:6px;font-size:11px">
                    <div><span style="color:var(--text-secondary)">Forecast range:</span> <span class="${minBuyCls}" style="font-weight:600">${formatPrice(minBuyPrice)}</span> — <span class="${maxBuyCls}" style="font-weight:600">${formatPrice(maxBuyPrice)}</span></div>
                    ${feedForecasts.length ? `<div><span style="color:var(--text-secondary)">Feed-in range:</span> <span class="${minFeedCls}" style="font-weight:600">${formatPrice(minFeedSpot)}</span> — <span class="${maxFeedCls}" style="font-weight:600">${formatPrice(maxFeedSpot)}</span></div>` : ''}
                </div>`;
            }

            // Buy price forecasts with advanced pricing and tariff info
            if (displayForecasts.length) {
                html += '<div style="font-size:11px;color:var(--text-secondary);margin-bottom:6px;margin-top:8px;font-weight:600">📈 Buy Price Forecast</div>';
                html += '<div style="display:flex;gap:4px;flex-wrap:wrap">';
                displayForecasts.forEach(it => {
                    const startDate = new Date(it.startTime);
                    const time = startDate.toLocaleTimeString('en-AU', {hour:'numeric', minute:'2-digit', hour12:false, timeZone: USER_TZ || 'Australia/Sydney'});
                    const p = it.perKwh;
                    const cls = p > 30 ? 'price-high' : p > 20 ? 'price-mid' : 'price-low';
                    const spike = it.spikeStatus && it.spikeStatus !== 'none';
                    const ap = it.advancedPrice;
                    const bandInfo = ap ? `Low: ${ap.low.toFixed(0)}¢ | Pred: ${ap.predicted.toFixed(0)}¢ | High: ${ap.high.toFixed(0)}¢` : '';
                    const tooltip = spike ? `SPIKE: ${it.spikeStatus}` : bandInfo;
                    let priceStr;
                    if (p > 99) {
                        priceStr = `$${(p/100).toFixed(2)}`;
                    } else {
                        priceStr = `${p.toFixed(0)}¢`;
                    }
                    html += `<div class="stat-item" style="min-width:52px;padding:5px;${spike ? 'border:1px solid rgba(248,81,73,0.5);background:rgba(248,81,73,0.1)' : ''}" title="${tooltip}">
                        <div style="display:flex;align-items:center;justify-content:center;gap:2px">
                            <span class="value ${cls}" style="font-size:12px;font-weight:600">${priceStr}</span>
                            ${spike ? '<span style="font-size:10px">⚠️</span>' : ''}
                        </div>
                        <div class="label" style="font-size:9px;color:var(--text-secondary)">${time}</div>
                    </div>`;
                });
                html += '</div>';
            }

            // Feed-in price forecasts - Amber app shows spotPerKwh rounded to whole cents
            if (displayFeedForecasts.length) {
                html += '<div style="font-size:11px;color:var(--text-secondary);margin-bottom:6px;margin-top:12px;font-weight:600">📉 Feed-in Spot Forecast</div>';
                html += '<div style="display:flex;gap:4px;flex-wrap:wrap">';
                displayFeedForecasts.forEach(it => {
                    // Use startTime converted to AEST - Amber shows interval START time
                    const startDate = new Date(it.startTime);
                    const time = startDate.toLocaleTimeString('en-AU', {hour:'numeric', minute:'2-digit', hour12:false, timeZone: USER_TZ || 'Australia/Sydney'});
                    // Display -Round(perKwh) to match Amber app (negative perKwh = you earn, shown positive)
                    const displayVal = -Math.round(it.perKwh);
                    function feedClassFromVal(v) {
                        // v is display value in cents (positive = you earn at this rate)
                        if (v < -6) return 'price-high'; // red - paying money
                        if (v < 0) return 'price-mid'; // amber - slightly negative
                        if (v < 5) return 'price-neutral'; // grey - very low earnings
                        if (v < 20) return 'price-low'; // green - good rate
                        if (v >= 20) return 'price-darkgreen'; // dark green - excellent rate
                        return 'price-neutral';
                    }
                    const getCls = feedClassFromVal(displayVal);
                    const isVeryNegative = displayVal < -2;
                    const feedHighlightCls = displayVal > 50 ? 'feedin-highlight' : '';
                    let feedPriceStr;
                    if (displayVal > 99) {
                        feedPriceStr = `$${(displayVal/100).toFixed(2)}`;
                    } else {
                        feedPriceStr = `${displayVal}¢`;
                    }
                    html += `<div class="stat-item ${feedHighlightCls}" style="min-width:52px;padding:6px;${isVeryNegative ? 'border:1px solid rgba(248,81,73,0.5);background:rgba(248,81,73,0.1)' : ''}">
                                <div style="display:flex;align-items:center;justify-content:center;gap:2px">
                                    <span class="value ${getCls}" style="font-size:13px;font-weight:700">${feedPriceStr}</span>
                        </div>
                        <div class="label" style="font-size:9px">${time}</div>
                    </div>`;
                });
                html += '</div>';
            }

            // Add chart canvas to HTML before rendering
            html += '<div style="margin-top:16px;position:relative;height:200px;width:100%"><canvas id="amberPriceChart" style="width:100%;height:200px"></canvas></div>';
            card.innerHTML = html;

            // Schedule chart rendering after DOM is ready
            setTimeout(() => renderAmberChart(displayForecasts, displayFeedForecasts), 100);
        }

        async function renderAmberChart(displayForecasts, displayFeedForecasts) {
            try {
                // Load Chart.js if not present
                if (typeof Chart === 'undefined') {
                    await new Promise((resolve, reject) => {
                        const s = document.createElement('script');
                        s.src = 'https://cdn.jsdelivr.net/npm/chart.js';
                        s.onload = resolve;
                        s.onerror = reject;
                        document.head.appendChild(s);
                    });
                }

                const canvas = document.getElementById('amberPriceChart');
                if (!canvas || typeof Chart === 'undefined') return;

                // Build labels from buy or feed-in forecasts
                const forecasts = displayForecasts.length ? displayForecasts : displayFeedForecasts;
                const labels = forecasts.map(it => {
                    try {
                        const d = new Date(it.startTime);
                        return d.toLocaleTimeString('en-AU', {hour:'2-digit', minute:'2-digit', hour12:false, timeZone: USER_TZ || 'Australia/Sydney'});
                    } catch(e) { return ''; }
                });

                // Build datasets
                const buySeries = displayForecasts.map(it => it ? Number(it.perKwh) : null);
                const feedSeries = displayFeedForecasts.map(it => it ? -Math.round(it.perKwh) : null);

                // Destroy old chart if exists
                if (window.amberChartInst) {
                    try { window.amberChartInst.destroy(); } catch(e) {}
                }

                const ctx = canvas.getContext('2d');
                // Prepare a constant zero series so we can draw a horizontal dotted line at 0
                const zeroSeries = labels.map(() => 0);

                window.amberChartInst = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [
                            // invisible legend entry (empty label) used to draw dotted zero line
                            {
                                label: '',
                                data: zeroSeries,
                                borderColor: 'rgba(255,255,255,0.25)',
                                borderWidth: 1,
                                pointRadius: 0,
                                tension: 0,
                                borderDash: [4, 4],
                                fill: false
                            },
                            {
                                label: 'Buy Price (¢/kWh)',
                                data: buySeries,
                                borderColor: '#ffd43b',
                                backgroundColor: 'rgba(255,212,59,0.1)',
                                borderWidth: 2,
                                tension: 0.3,
                                pointRadius: 4,
                                pointBackgroundColor: '#ffd43b',
                                pointBorderColor: cssVar('--bg-primary'),
                                pointBorderWidth: 1,
                                fill: true
                            },
                            {
                                label: 'Feed-in Spot (¢)',
                                data: feedSeries,
                                borderColor: '#7ee787',
                                backgroundColor: 'rgba(126,231,135,0.1)',
                                borderWidth: 2,
                                tension: 0.3,
                                pointRadius: 4,
                                pointBackgroundColor: '#7ee787',
                                pointBorderColor: cssVar('--bg-primary'),
                                pointBorderWidth: 1,
                                fill: true
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        plugins: {
                            legend: {
                                display: true,
                                labels: { color: cssVar('--text-primary'), usePointStyle: true, padding: 15, font: { size: 12 } }
                            },
                            tooltip: {
                                backgroundColor: cssVar('--bg-secondary'),
                                titleColor: cssVar('--text-primary'),
                                bodyColor: cssVar('--text-secondary'),
                                borderColor: cssVar('--border-primary'),
                                borderWidth: 1,
                                padding: 10,
                                cornerRadius: 6,
                                displayColors: true
                            }
                        },
                        scales: {
                            x: {
                                grid: { color: 'rgba(255,255,255,0.02)', drawBorder: false },
                                ticks: { color: cssVar('--text-secondary'), font: { size: 11 } }
                            },
                            y: {
                                beginAtZero: true,
                                grid: { color: 'rgba(255,255,255,0.05)', drawBorder: false },
                                ticks: { color: cssVar('--text-secondary'), font: { size: 11 }, callback: val => val + '¢' }
                            }
                        }
                    }
                });
            } catch (err) {
                console.error('Chart render failed:', err);
            }
        }

        // Scheduler segments
        let currentSchedulerGroups = [];
        
        async function clearAllSchedulerSegments() {
            if (!confirm('⚠️ Clear ALL 10 scheduler time periods?\n\nThis will reset all segments to disabled (00:00-00:00).')) {
                return;
            }
            
            const statusEl = document.getElementById('schedulerStatus');
            statusEl.style.display = 'block';
            statusEl.style.background = 'var(--accent-blue)';
            statusEl.textContent = '🔄 Clearing all segments...';
            
            try {
                const resp = await authenticatedFetch('/api/scheduler/v1/clear-all', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                const data = await resp.json();
                
                if (data.errno === 0) {
                    statusEl.style.background = 'var(--color-success-dark)';
                    let msg = '✅ All segments cleared successfully!';
                    // Show flag result if available
                    if (data.flagResult) {
                        msg += data.flagResult.errno === 0 ? ' (flag disabled)' : ' (flag warning)';
                    }
                    statusEl.textContent = msg;
                    // Show full response including verify info so user can see device state
                    try { document.getElementById('result').className = 'info'; document.getElementById('result').textContent = JSON.stringify(data, null, 2); } catch(e) {}
                    setTimeout(() => loadSchedulerSegments(), CONFIG.ui.schedulerReloadDelayMs);
                } else {
                    statusEl.style.background = 'var(--color-danger)';
                    statusEl.textContent = `❌ Failed: ${data.msg || 'Unknown error'}`;
                    // Show error response for debugging
                    try { document.getElementById('result').className = 'error'; document.getElementById('result').textContent = JSON.stringify(data, null, 2); } catch(e) {}
                }
            } catch (err) {
                statusEl.style.background = 'var(--color-danger)';
                statusEl.textContent = `❌ Error: ${err.message}`;
            }
            
            setTimeout(() => { statusEl.style.display = 'none'; }, CONFIG.ui.statusFadeMs);
        }
        
        async function loadSchedulerSegments() {
            const container = document.getElementById('schedulerSegments');
            container.innerHTML = '<div style="color:var(--text-secondary);font-size:12px;padding:20px;text-align:center">Loading...</div>';
            
            try {
                const resp = await authenticatedFetch('/api/scheduler/v1/get');
                const data = await resp.json();
                
                if (data.errno !== 0 || !data.result) {
                    container.innerHTML = `<div style="color:var(--color-danger);font-size:12px;padding:20px">Error: ${data.msg || 'Failed to load'}</div>`;
                    return;
                }
                
                currentSchedulerGroups = data.result.groups || [];
                const globalEnable = data.result.enable;
                
                if (currentSchedulerGroups.length === 0) {
                    container.innerHTML = '<div style="color:var(--text-secondary);font-size:12px;padding:20px;text-align:center">No segments configured</div>';
                    return;
                }
                
                const modeColors = {
                    'SelfUse': cssVar('--color-success'),
                    'ForceCharge': cssVar('--accent-blue'), 
                    'ForceDischarge': cssVar('--color-orange'),
                    'Feedin': cssVar('--color-warning'),
                    'Backup': cssVar('--color-purple')
                };
                
                let html = `<div style="grid-column:1/-1;margin-bottom:8px;padding:8px;background:${globalEnable ? cssVar('--color-success-dark') : cssVar('--border-primary')};border-radius:6px;text-align:center;font-size:12px">
                    Scheduler: <strong>${globalEnable ? '✅ ENABLED' : '❌ DISABLED'}</strong>
                </div>`;
                
                currentSchedulerGroups.forEach((seg, i) => {
                    const color = modeColors[seg.workMode] || cssVar('--text-secondary');
                    const startTime = `${String(seg.startHour).padStart(2,'0')}:${String(seg.startMinute).padStart(2,'0')}`;
                    const endTime = `${String(seg.endHour).padStart(2,'0')}:${String(seg.endMinute).padStart(2,'0')}`;
                    const isEnabled = seg.enable === 1;
                    
                    html += `<div style="background:var(--bg-card);border:1px solid ${isEnabled ? color : 'var(--border-primary)'};border-radius:8px;padding:10px;opacity:${isEnabled ? 1 : 0.6}">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                            <span style="font-weight:600;color:${color}">Segment ${i+1}</span>
                            <span style="font-size:11px;padding:2px 8px;border-radius:4px;background:${isEnabled ? color : 'var(--border-primary)'};color:var(--bg-primary)">${isEnabled ? 'ON' : 'OFF'}</span>
                        </div>
                        <div style="font-size:20px;font-weight:600;color:var(--text-primary);margin-bottom:4px">${startTime} → ${endTime}</div>
                        <div style="font-size:13px;color:${color};margin-bottom:8px">${seg.workMode}</div>
                        <div style="font-size:11px;color:var(--text-secondary);display:grid;grid-template-columns:1fr 1fr;gap:4px">
                            <span>MinSoC: ${seg.minSocOnGrid ?? seg.extraParam?.minSocOnGrid ?? '-'}%</span>
                            <span>Stop SoC: ${seg.fdSoc ?? seg.extraParam?.fdSoc ?? '-'}%</span>
                            <span>Power: ${seg.fdPwr ?? seg.extraParam?.fdPwr ?? 0}W</span>
                            <span>Max SoC: ${seg.maxSoc ?? seg.extraParam?.maxSoc ?? '-'}%</span>
                        </div>
                        <div style="display:flex;gap:6px;margin-top:8px">
                            <button class="btn" onclick="editSegment(${i})" style="flex:1;font-size:11px;padding:4px">✏️ Edit</button>
                            <button class="btn" onclick="deleteSegment(${i})" style="flex:1;font-size:11px;padding:4px;background:var(--color-danger)">🗑️ Clear</button>
                        </div>
                    </div>`;
                });
                
                container.innerHTML = html;
                
                // Check automation status and show warning if enabled
                checkAutomationStatusForScheduler();
                
                // Update solar tile curtailment indicator after rendering
                updateSolarTileCurtailmentIndicator();
                
                // Also show in result panel
                document.getElementById('result').className = 'success';
                document.getElementById('result').textContent = JSON.stringify(data, null, 2);
            } catch (error) {
                container.innerHTML = `<div style="color:var(--color-danger);font-size:12px;padding:20px">Error: ${error.message}</div>`;
            }
        }
        
        async function checkAutomationStatusForScheduler() {
            const warningDiv = document.getElementById('schedulerAutomationWarning');
            if (!warningDiv) return;
            
            try {
                const resp = await authenticatedFetch('/api/automation/status');
                const data = await resp.json();
                
                if (data.errno === 0 && data.result?.enabled === true) {
                    warningDiv.style.display = 'block';
                } else {
                    warningDiv.style.display = 'none';
                }
            } catch (error) {
                console.warn('[Scheduler] Failed to check automation status:', error);
                warningDiv.style.display = 'none';
            }
        }
        
        // ============================================================
        // Quick Controls
        // ============================================================
        
        let quickControlState = {
            type: 'charge', // 'charge' or 'discharge'
            power: 5000,
            duration: 30,
            countdownInterval: null
        };
        
        function selectQuickControlType(type) {
            quickControlState.type = type;
            const chargeBtn = document.getElementById('btnChargeType');
            const dischargeBtn = document.getElementById('btnDischargeType');
            
            if (type === 'charge') {
                chargeBtn.style.background = 'var(--accent-blue)';
                chargeBtn.style.borderColor = 'var(--accent-blue)';
                dischargeBtn.style.background = '';
                dischargeBtn.style.borderColor = '';
            } else {
                dischargeBtn.style.background = 'var(--color-danger)';
                dischargeBtn.style.borderColor = 'var(--color-danger)';
                chargeBtn.style.background = '';
                chargeBtn.style.borderColor = '';
            }
        }
        
        function updateQuickControlPowerDisplay(value) {
            quickControlState.power = parseInt(value);
            document.getElementById('quickControlPowerDisplay').textContent = (quickControlState.power / 1000).toFixed(1);
        }
        
        function setQuickControlPower(watts) {
            document.getElementById('quickControlPower').value = watts;
            updateQuickControlPowerDisplay(watts);
        }

        // Applies the user's inverter capacity to the quick-control slider and preset button.
        // Called after user config loads from /api/config.
        function applyInverterCapacityToUI(capacityW) {
            const slider = document.getElementById('quickControlPower');
            if (slider) {
                slider.max = capacityW;
                if (parseInt(slider.value) > capacityW) {
                    slider.value = capacityW;
                    updateQuickControlPowerDisplay(capacityW);
                }
            }
            const maxLabel = document.getElementById('quickControlMaxLabel');
            if (maxLabel) maxLabel.textContent = `${(capacityW / 1000).toFixed(1)} kW`;
            const maxBtn = document.getElementById('quickControlMaxBtn');
            if (maxBtn) {
                maxBtn.onclick = () => setQuickControlPower(capacityW);
                maxBtn.textContent = `${(capacityW / 1000).toFixed(1)} kW`;
            }
        }
        
        function updateQuickControlDurationDisplay(value) {
            quickControlState.duration = parseInt(value);
            document.getElementById('quickControlDurationDisplay').textContent = quickControlState.duration;
        }
        
        function setQuickControlDuration(minutes) {
            const duration = parseInt(minutes);
            if (duration >= 2 && duration <= 360) {
                document.getElementById('quickControlDuration').value = Math.min(300, duration);
                quickControlState.duration = duration;
                document.getElementById('quickControlDurationDisplay').textContent = duration;
                const customInput = document.getElementById('quickControlDurationCustom');
                if (duration > 300) {
                    customInput.value = duration;
                    customInput.style.display = 'block';
                } else {
                    customInput.style.display = 'none';
                }
            }
        }
        
        function toggleQuickControlCustomDuration() {
            const customInput = document.getElementById('quickControlDurationCustom');
            if (customInput.style.display === 'none') {
                customInput.style.display = 'block';
                customInput.focus();
            } else {
                customInput.style.display = 'none';
            }
        }
        
        // Initialize Quick Control status on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Load initial status
            refreshQuickControlStatus();
        });
        
        async function refreshQuickControlStatus(showFeedback = false) {
            if (showFeedback) {
                const messageEl = document.getElementById('quickControlMessage');
                if (messageEl) {
                    messageEl.style.display = 'block';
                    messageEl.style.background = 'var(--accent-blue)';
                    messageEl.textContent = '🔄 Refreshing...';
                }
            }
            
            try {
                const resp = await authenticatedFetch('/api/quickcontrol/status');
                const data = await resp.json();
                
                if (data.errno === 0 && data.result) {
                    updateQuickControlUI(data.result);
                    
                    // Check automation status for warning
                    checkQuickControlAutomationWarning();
                }
                
                if (showFeedback) {
                    const messageEl = document.getElementById('quickControlMessage');
                    if (messageEl) {
                        messageEl.style.display = 'none';
                    }
                }
            } catch (error) {
                console.warn('[QuickControl] Failed to fetch status:', error);
                
                if (showFeedback) {
                    const messageEl = document.getElementById('quickControlMessage');
                    if (messageEl) {
                        messageEl.style.background = 'var(--color-danger)';
                        messageEl.textContent = '❌ Refresh failed';
                        setTimeout(() => { messageEl.style.display = 'none'; }, 3000);
                    }
                }
            }
        }
        
        async function checkQuickControlAutomationWarning() {
            const warningDiv = document.getElementById('quickControlAutomationWarning');
            if (!warningDiv) return;
            
            try {
                const resp = await authenticatedFetch('/api/automation/status');
                const data = await resp.json();
                
                if (data.errno === 0 && data.result?.enabled === true) {
                    warningDiv.style.display = 'block';
                } else {
                    warningDiv.style.display = 'none';
                }
            } catch (error) {
                console.warn('[QuickControl] Failed to check automation status:', error);
                warningDiv.style.display = 'none';
            }
        }
        
        function updateQuickControlUI(status) {
            const statusDiv = document.getElementById('quickControlStatus');
            const formDiv = document.getElementById('quickControlForm');
            const startBtn = document.getElementById('btnStartQuickControl');
            
            if (!status || !status.active) {
                // No active quick control - check if just expired (server auto-cleaned)
                if (status && status.justExpired && status.completedControl) {
                    const cc = status.completedControl;
                    const typeIcon = cc.type === 'charge' ? '🔋' : '⚡';
                    const typeText = cc.type === 'charge' ? 'Charging' : 'Discharging';
                    const powerKW = (cc.power / 1000).toFixed(1);
                    
                    statusDiv.style.display = 'block';
                    formDiv.style.display = 'none';
                    statusDiv.style.background = 'rgba(46,160,67,0.15)';
                    statusDiv.style.borderColor = 'rgba(46,160,67,0.4)';
                    statusDiv.style.color = 'var(--color-success)';
                    statusDiv.innerHTML = `
                        <div style="font-weight:600;margin-bottom:8px">✅ Quick Control Completed</div>
                        <div style="font-size:12px;">
                            ${typeIcon} ${typeText} at ${powerKW} kW for ${cc.durationMinutes} minutes has finished. Segments cleared automatically.
                        </div>
                    `;
                    
                    // Auto-dismiss after 5 seconds and show the form again
                    setTimeout(() => {
                        statusDiv.style.display = 'none';
                        formDiv.style.display = 'block';
                    }, 5000);
                } else {
                    statusDiv.style.display = 'none';
                    formDiv.style.display = 'block';
                }
                
                // Clear any countdown
                if (quickControlState.countdownInterval) {
                    clearInterval(quickControlState.countdownInterval);
                    quickControlState.countdownInterval = null;
                }
                return;
            }
            
            // Active quick control
            statusDiv.style.display = 'block';
            formDiv.style.display = 'none';
            
            const typeIcon = status.type === 'charge' ? '🔋' : '⚡';
            const typeText = status.type === 'charge' ? 'Charging' : 'Discharging';
            const powerKW = (status.power / 1000).toFixed(1);
            
            // Calculate remaining time
            const now = Date.now();
            const remainingMs = Math.max(0, status.expiresAt - now);
            const remainingMinutes = Math.ceil(remainingMs / 60000);
            
            if (remainingMinutes <= 0) {
                // Timer expired - trigger a status refresh which will auto-clean on server
                statusDiv.style.background = 'rgba(139,148,158,0.15)';
                statusDiv.style.borderColor = 'rgba(139,148,158,0.4)';
                statusDiv.style.color = 'var(--text-secondary)';
                statusDiv.innerHTML = `
                    <div style="display:flex;align-items:center;gap:12px;justify-content:center;padding:10px;">
                        <div class="spinner"></div>
                        <span>Quick control finished. Clearing segments...</span>
                    </div>
                `;
                // Server-side auto-cleanup will happen when we refresh status
                setTimeout(() => refreshQuickControlStatus(), 2000);
            } else {
                statusDiv.style.background = 'rgba(46,160,67,0.15)';
                statusDiv.style.borderColor = 'rgba(46,160,67,0.4)';
                statusDiv.style.color = 'var(--color-success)';
                statusDiv.innerHTML = `
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                        <div style="font-weight:600;">${typeIcon} ${typeText} at ${powerKW} kW</div>
                        <div id="quickControlCountdown" style="font-family:monospace;font-size:16px;font-weight:700;">${formatCountdown(remainingMs)}</div>
                    </div>
                    <div style="font-size:12px;color:var(--text-secondary);margin-bottom:12px">
                        Started: ${new Date(status.startedAt).toLocaleTimeString()} • 
                        Ends: ${new Date(status.expiresAt).toLocaleTimeString()}
                    </div>
                    <div style="display:flex;gap:8px;">
                        <button class="btn" onclick="stopQuickControl()" style="background:var(--color-danger);border-color:var(--color-danger);flex:1;font-size:12px;padding:8px;font-weight:600;">
                            ⏹️ Stop Now
                        </button>
                        <button class="btn" onclick="refreshQuickControlStatus(true)" style="font-size:12px;padding:8px;">
                            🔄 Refresh
                        </button>
                    </div>
                `;
                
                // Start countdown timer
                startCountdownTimer(status.expiresAt);
            }
        }
        
        function formatCountdown(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            if (hours > 0) {
                return `${hours}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            } else {
                return `${minutes}:${String(seconds).padStart(2, '0')}`;
            }
        }
        
        function startCountdownTimer(expiresAt) {
            // Clear existing timer
            if (quickControlState.countdownInterval) {
                clearInterval(quickControlState.countdownInterval);
            }
            
            quickControlState.countdownInterval = setInterval(() => {
                const now = Date.now();
                const remainingMs = Math.max(0, expiresAt - now);
                const countdownEl = document.getElementById('quickControlCountdown');
                
                if (countdownEl) {
                    countdownEl.textContent = formatCountdown(remainingMs);
                }
                
                if (remainingMs <= 0) {
                    clearInterval(quickControlState.countdownInterval);
                    quickControlState.countdownInterval = null;
                    // Refresh to show completion
                    setTimeout(() => refreshQuickControlStatus(), 1000);
                }
            }, 1000);
        }
        
        async function startQuickControl() {
            const startBtn = document.getElementById('btnStartQuickControl');
            const durationSlider = document.getElementById('quickControlDuration');
            const customInput = document.getElementById('quickControlDurationCustom');
            
            // Get duration from custom input if visible, otherwise from slider
            let durationMinutes;
            if (customInput.style.display !== 'none' && customInput.value) {
                durationMinutes = parseInt(customInput.value);
                if (isNaN(durationMinutes) || durationMinutes < 2 || durationMinutes > 360) {
                    alert('❌ Please enter a valid duration (2-360 minutes)');
                    return;
                }
            } else {
                durationMinutes = parseInt(durationSlider.value);
            }
            
            // Validate power
            if (quickControlState.power < 0 || quickControlState.power > _inverterCapacityW) {
                alert(`❌ Power must be between 0 and ${(_inverterCapacityW / 1000).toFixed(1)} kW (your inverter capacity)`);
                return;
            }
            
            // Disable button and show loading
            startBtn.disabled = true;
            startBtn.innerHTML = '<span style="opacity:0.6">⏳ Starting...</span>';
            
            const messageEl = document.getElementById('quickControlMessage');
            messageEl.style.display = 'block';
            messageEl.style.background = 'var(--accent-blue)';
            messageEl.textContent = '🔄 Starting quick control...';
            
            try {
                console.log('[QuickControl] Starting:', { type: quickControlState.type, power: quickControlState.power, durationMinutes });
                
                // Add timeout to prevent hanging
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
                
                const resp = await authenticatedFetch('/api/quickcontrol/start', {
                    method: 'POST',
                    body: JSON.stringify({
                        type: quickControlState.type,
                        power: quickControlState.power,
                        durationMinutes: durationMinutes
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                console.log('[QuickControl] Response status:', resp.status);
                const data = await resp.json();
                console.log('[QuickControl] Response data:', data);
                
                if (data.errno === 0) {
                    messageEl.style.background = 'var(--color-success-dark)';
                    messageEl.textContent = `✅ Quick ${quickControlState.type} started successfully!`;
                    setTimeout(() => { messageEl.style.display = 'none'; }, 3000);
                    
                    // Reset button first (in case updateQuickControlUI doesn't hide form immediately)
                    startBtn.disabled = false;
                    startBtn.innerHTML = '▶️ Start Quick Control';
                    
                    // Update UI to show active status (this will hide the form)
                    updateQuickControlUI(data.state);
                } else {
                    console.error('[QuickControl] API returned error:', data);
                    messageEl.style.background = 'var(--color-danger)';
                    messageEl.textContent = `❌ Failed: ${data.error || data.msg || 'Unknown error'}`;
                    setTimeout(() => { messageEl.style.display = 'none'; }, 5000);
                    startBtn.disabled = false;
                    startBtn.innerHTML = '▶️ Start Quick Control';
                }
            } catch (error) {
                console.error('[QuickControl] Start error:', error);
                messageEl.style.background = 'var(--color-danger)';
                
                if (error.name === 'AbortError') {
                    messageEl.textContent = '❌ Request timed out. Please try again.';
                } else {
                    messageEl.textContent = `❌ Error: ${error.message}`;
                }
                
                setTimeout(() => { messageEl.style.display = 'none'; }, 5000);
                startBtn.disabled = false;
                startBtn.innerHTML = '▶️ Start Quick Control';
            }
        }
        
        async function stopQuickControl() {
            if (!confirm('Stop quick control now? The scheduler segment will be cleared.')) {
                return;
            }
            
            const messageEl = document.getElementById('quickControlMessage');
            messageEl.style.display = 'block';
            messageEl.style.background = 'var(--accent-blue)';
            messageEl.textContent = '🔄 Stopping quick control...';
            
            try {
                const resp = await authenticatedFetch('/api/quickcontrol/end', {
                    method: 'POST'
                });
                
                const data = await resp.json();
                
                if (data.errno === 0) {
                    messageEl.style.background = 'var(--color-success-dark)';
                    messageEl.textContent = '✅ Quick control stopped successfully';
                    setTimeout(() => { messageEl.style.display = 'none'; }, 3000);
                    await refreshQuickControlStatus();
                } else {
                    messageEl.style.background = 'var(--color-danger)';
                    messageEl.textContent = `❌ Failed: ${data.error || data.msg || 'Unknown error'}`;
                    setTimeout(() => { messageEl.style.display = 'none'; }, 5000);
                }
            } catch (error) {
                console.error('[QuickControl] Stop error:', error);
                messageEl.style.background = 'var(--color-danger)';
                messageEl.textContent = `❌ Error: ${error.message}`;
                setTimeout(() => { messageEl.style.display = 'none'; }, 5000);
            }
        }
        
        async function acknowledgeQuickControlComplete() {
            const statusDiv = document.getElementById('quickControlStatus');
            
            // Show loading state
            statusDiv.innerHTML = `
                <div style="display:flex;align-items:center;gap:12px;justify-content:center;padding:20px;">
                    <div class="spinner"></div>
                    <span style="color:var(--accent-blue);font-weight:500;">Clearing quick control...</span>
                </div>
            `;
            
            // Clear the expired state by calling end endpoint
            try {
                await authenticatedFetch('/api/quickcontrol/end', {
                    method: 'POST'
                });
            } catch (error) {
                console.warn('[QuickControl] Failed to clear completed state:', error);
            }
            // Refresh UI regardless
            await refreshQuickControlStatus();
        }
        
        function editSegment(index) {
            const seg = currentSchedulerGroups[index];
            if (!seg) return;
            
            const form = document.getElementById('form-scheduler-segment');
            form.segmentIndex.value = index;
            form.enable.value = seg.enable;
            form.workMode.value = seg.workMode;
            form.startTime.value = `${String(seg.startHour).padStart(2,'0')}:${String(seg.startMinute).padStart(2,'0')}`;
            form.endTime.value = `${String(seg.endHour).padStart(2,'0')}:${String(seg.endMinute).padStart(2,'0')}`;
            form.minSocOnGrid.value = seg.minSocOnGrid ?? seg.extraParam?.minSocOnGrid ?? 10;
            form.fdSoc.value = seg.fdSoc ?? seg.extraParam?.fdSoc ?? 10;
            form.fdPwr.value = seg.fdPwr ?? seg.extraParam?.fdPwr ?? 0;
            form.maxSoc.value = seg.maxSoc ?? seg.extraParam?.maxSoc ?? 100;
            
            // Scroll to form
            form.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        async function deleteSegment(index) {
            if (!confirm(`Clear segment ${index + 1}? This will disable it and reset times to 00:00.`)) return;
            
            const statusDiv = document.getElementById('schedulerStatus');
            statusDiv.style.display = 'block';
            statusDiv.style.background = 'var(--bg-card)';
            statusDiv.style.color = 'var(--accent-blue)';
            statusDiv.innerHTML = '<div style="display:flex;align-items:center;gap:8px"><div class="spinner"></div><span>Clearing segment...</span></div>';
            
            // First load current segments if not loaded
            if (currentSchedulerGroups.length === 0) {
                try {
                    const resp = await authenticatedFetch('/api/scheduler/v1/get');
                    const data = await resp.json();
                    if (data.errno === 0 && data.result?.groups) {
                        currentSchedulerGroups = data.result.groups;
                    }
                } catch (e) {
                    statusDiv.style.background = 'var(--color-danger)';
                    statusDiv.style.color = '#fff';
                    statusDiv.textContent = '❌ Failed to load current segments';
                    return;
                }
            }
            
            // Reset the segment to disabled with 00:00 times (V1 flat structure)
            currentSchedulerGroups[index] = {
                enable: 0,
                workMode: 'SelfUse',
                startHour: 0,
                startMinute: 0,
                endHour: 0,
                endMinute: 0,
                minSocOnGrid: 10,
                fdSoc: 10,
                fdPwr: 0,
                maxSoc: 100
            };
            
            // Send all segments to API
            const sn = document.getElementById('deviceSn').value || '';
            const body = { groups: currentSchedulerGroups };
            if (sn) body.sn = sn;
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
                
                const resp = await authenticatedFetch('/api/scheduler/v1/set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                const data = await resp.json();
                
                if (data.errno === 0) {
                    statusDiv.style.background = 'var(--color-success-dark)';
                    statusDiv.style.color = '#fff';
                    let msg = `✅ Segment ${index + 1} cleared successfully`;
                    if (data.flagResult) {
                        msg += data.flagResult.errno === 0 ? ' (flag updated)' : '';
                    }
                    statusDiv.textContent = msg;
                    // Show full response including verify info so user can see device state
                    try { document.getElementById('result').className = 'info'; document.getElementById('result').textContent = JSON.stringify(data, null, 2); } catch(e) {}
                    // Reload segments to reflect changes
                    setTimeout(() => loadSchedulerSegments(), CONFIG.ui.schedulerReloadDelayMs);
                } else {
                    statusDiv.style.background = 'var(--color-danger)';
                    statusDiv.style.color = '#fff';
                    statusDiv.textContent = `❌ Failed to clear segment: ${data.msg || 'Unknown error'}`;
                }
            } catch (error) {
                statusDiv.style.background = 'var(--color-danger)';
                statusDiv.style.color = '#fff';
                if (error.name === 'AbortError') {
                    statusDiv.innerHTML = '<div style="display:flex;align-items:center;gap:8px"><div class="spinner"></div><span>⚠️ Request taking longer than expected, still processing...</span></div>';
                    // Check for success after timeout by reloading
                    setTimeout(() => {
                        loadSchedulerSegments();
                        statusDiv.style.background = 'var(--color-orange)';
                        statusDiv.style.color = 'var(--bg-primary)';
                        statusDiv.textContent = '⚠️ Operation may have succeeded - segments reloaded';
                        setTimeout(() => { statusDiv.style.display = 'none'; }, CONFIG.ui.statusFadeMs);
                    }, CONFIG.ui.clearAllDelayMs);
                    return;
                }
                statusDiv.textContent = `❌ Error: ${error.message}`;
            }
            
            // Hide status after configured delay
            setTimeout(() => { statusDiv.style.display = 'none'; }, CONFIG.ui.statusFadeMs);
        }
        
        async function submitSchedulerSegment(evt) {
            evt.preventDefault();
            const form = evt.target;
            
            const statusDiv = document.getElementById('schedulerStatus');
            statusDiv.style.display = 'block';
            statusDiv.style.background = 'var(--bg-card)';
            statusDiv.style.color = 'var(--accent-blue)';
            statusDiv.innerHTML = '<div style="display:flex;align-items:center;gap:8px"><div class="spinner"></div><span>Saving segment...</span></div>';
            
            // First load current segments if not loaded
            if (currentSchedulerGroups.length === 0) {
                try {
                    const resp = await authenticatedFetch('/api/scheduler/v1/get');
                    const data = await resp.json();
                    if (data.errno === 0 && data.result?.groups) {
                        currentSchedulerGroups = data.result.groups;
                    }
                } catch (e) {
                    statusDiv.style.background = 'var(--color-danger)';
                    statusDiv.style.color = '#fff';
                    statusDiv.textContent = '❌ Failed to load current segments';
                    setTimeout(() => { statusDiv.style.display = 'none'; }, CONFIG.ui.statusFadeMs);
                    return;
                }
            }
            
            const index = parseInt(form.segmentIndex.value);
            const [startHour, startMinute] = form.startTime.value.split(':').map(Number);
            const [endHour, endMinute] = form.endTime.value.split(':').map(Number);
            
            // Validate: fdSoc must be >= minSocOnGrid
            const minSocOnGrid = parseInt(form.minSocOnGrid.value) || 10;
            let fdSoc = parseInt(form.fdSoc.value) || 10;
            if (fdSoc < minSocOnGrid) {
                fdSoc = minSocOnGrid;
                form.fdSoc.value = fdSoc;
                statusDiv.style.background = 'var(--color-orange)';
                statusDiv.style.color = 'var(--bg-primary)';
                statusDiv.textContent = `⚠️ Stop SoC must be >= Min SoC (Grid) (${minSocOnGrid}%). Auto-corrected to ${fdSoc}%.`;
                await new Promise(resolve => setTimeout(resolve, 2000));
                statusDiv.style.background = 'var(--bg-card)';
                statusDiv.style.color = 'var(--accent-blue)';
                statusDiv.innerHTML = '<div style="display:flex;align-items:center;gap:8px"><div class="spinner"></div><span>Saving segment...</span></div>';
            }
            
            // Update the segment
            if (!currentSchedulerGroups[index]) {
                currentSchedulerGroups[index] = {};
            }
            
            // V1 uses flat structure (no extraParam nesting)
            currentSchedulerGroups[index] = {
                enable: parseInt(form.enable.value),
                workMode: form.workMode.value,
                startHour,
                startMinute,
                endHour,
                endMinute,
                minSocOnGrid,
                fdSoc,
                fdPwr: parseInt(form.fdPwr.value) || 0,
                maxSoc: parseInt(form.maxSoc.value) || 100
            };
            
            // Send all segments to API (V1 endpoint)
            const sn = document.getElementById('deviceSn').value || '';
            const body = { groups: currentSchedulerGroups };
            if (sn) body.sn = sn;
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), CONFIG.timeout.schedulerMs);
                
                const resp = await authenticatedFetch('/api/scheduler/v1/set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                const data = await resp.json();
                
                if (data.errno === 0) {
                    statusDiv.style.background = 'var(--color-success-dark)';
                    statusDiv.style.color = '#fff';
                    let msg = `✅ Segment ${index + 1} saved successfully`;
                    // Show flag status
                    if (data.flagResult) {
                        msg += data.flagResult.errno === 0 ? ' (flag set)' : ' (flag warning)';
                    }
                    statusDiv.textContent = msg;
                    // Show full response including verify info so user can see device state
                    try { document.getElementById('result').className = 'info'; document.getElementById('result').textContent = JSON.stringify(data, null, 2); } catch(e) {}
                    // Reload segments to reflect changes (this now reads from device, not Firestore)
                    setTimeout(() => loadSchedulerSegments(), CONFIG.ui.schedulerReloadDelayMs);
                } else {
                    statusDiv.style.background = 'var(--color-danger)';
                    statusDiv.style.color = '#fff';
                    statusDiv.textContent = `❌ Failed to save segment: ${data.msg || 'Unknown error'}`;
                    // Show error response for debugging
                    try { document.getElementById('result').className = 'error'; document.getElementById('result').textContent = JSON.stringify(data, null, 2); } catch(e) {}
                }
            } catch (error) {
                statusDiv.style.background = 'var(--color-danger)';
                statusDiv.style.color = '#fff';
                if (error.name === 'AbortError') {
                    statusDiv.innerHTML = '<div style="display:flex;align-items:center;gap:8px"><div class="spinner"></div><span>⚠️ Request taking longer than expected, still processing...</span></div>';
                    // Check for success after timeout by reloading
                    setTimeout(() => {
                        loadSchedulerSegments();
                        statusDiv.style.background = 'var(--color-orange)';
                        statusDiv.style.color = 'var(--bg-primary)';
                        statusDiv.textContent = '⚠️ Operation may have succeeded - segments reloaded';
                        setTimeout(() => { statusDiv.style.display = 'none'; }, CONFIG.ui.statusFadeMs);
                    }, CONFIG.ui.clearAllDelayMs);
                    return;
                }
                statusDiv.textContent = `❌ Error: ${error.message}`;
            }
            
            // Hide status after configured delay
            setTimeout(() => { statusDiv.style.display = 'none'; }, CONFIG.ui.statusFadeMs);
        }

        // Forms
        async function submitSetForm(evt, endpoint) {
            evt.preventDefault();
            const form = evt.target;
            const body = buildBodyFromForm(form);
            const sn = document.getElementById('deviceSn').value;
            if (sn && !body.sn) body.sn = sn;

            if (body.raw) {
                try { Object.assign(body, JSON.parse(body.raw)); } catch(e) {}
                delete body.raw;
            }
            if (body.readerInfo && typeof body.readerInfo === 'string') {
                try { body.readerInfo = JSON.parse(body.readerInfo); } catch(e) {}
            }

            callAPIPost(endpoint, form.querySelector('.form-title')?.textContent || endpoint, body);
        }

        function buildBodyFromForm(form) {
            const obj = {};
            Array.from(form.elements).filter(el => el.name && !el.disabled).forEach(el => {
                if (el.type === 'submit' || el.type === 'button') return;
                let val = el.type === 'checkbox' ? el.checked : el.value;
                if (val === '') return;
                if (el.type === 'number') { const n = Number(val); if (!isNaN(n)) val = n; }
                
                if (el.name.includes('.')) {
                    const parts = el.name.split('.');
                    let cur = obj;
                    parts.forEach((p, i) => {
                        if (i === parts.length - 1) cur[p] = val;
                        else { cur[p] = cur[p] || {}; cur = cur[p]; }
                    });
                } else {
                    obj[el.name] = val;
                }
            });
            return obj;
        }

        function fillExample(formId) {
            const form = document.getElementById(formId);
            if (!form) return;
            if (formId === 'form-soc') {
                form.querySelector('[name=minSoc]').value = 20;
                form.querySelector('[name=minSocOnGrid]').value = 10;
            } else if (formId === 'form-forceCharge') {
                form.querySelector('[name=enable1]').checked = true;
                form.querySelector('[name="startTime1.hour"]').value = 6;
                form.querySelector('[name="startTime1.minute"]').value = 0;
                form.querySelector('[name="endTime1.hour"]').value = 8;
                form.querySelector('[name="endTime1.minute"]').value = 30;
            } else if (formId === 'form-peakShaving') {
                form.querySelector('[name=importLimit]').value = 5;
                form.querySelector('[name=soc]').value = 10;
            } else if (formId === 'form-time') {
                syncLocalTime(formId);
            }
        }

        function syncLocalTime(formId) {
            const form = document.getElementById(formId);
            if (!form) return;
            const d = new Date();
            form.querySelector('[name=year]').value = d.getFullYear();
            form.querySelector('[name=month]').value = d.getMonth() + 1;
            form.querySelector('[name=day]').value = d.getDate();
            form.querySelector('[name=hour]').value = d.getHours();
            form.querySelector('[name=minute]').value = d.getMinutes();
        }
        
        function clearResult() {
            document.getElementById('result').textContent = 'Click any button to see the API response here...';
            document.getElementById('result').className = '';
            document.getElementById('status-bar').style.display = 'none';
        }
        
        function copyResult() {
            navigator.clipboard.writeText(document.getElementById('result').textContent).then(() => {
                const btn = document.querySelector('.copy-btn');
                btn.textContent = '✓ Copied!';
                setTimeout(() => btn.textContent = '📋 Copy', 2000);
            });
        }
        
        // Resize handle
        const resizeHandle = document.getElementById('resizeHandle');
        const rightPanel = document.getElementById('rightPanel');
        let isResizing = false;
        
        resizeHandle.addEventListener('mousedown', () => {
            isResizing = true;
            document.body.style.cursor = 'ew-resize';
            document.body.style.userSelect = 'none';
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const newWidth = window.innerWidth - e.clientX;
            if (newWidth >= 300 && newWidth <= 800) {
                rightPanel.style.width = newWidth + 'px';
            }
        });
        
        document.addEventListener('mouseup', () => {
            isResizing = false;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        });

        // Clean up timers before unload (helps when navigating away during development)
        window.addEventListener('beforeunload', () => {
            try { if (amberRefreshTimer) clearInterval(amberRefreshTimer); } catch(e){}
            try { if (inverterRefreshTimer) clearInterval(inverterRefreshTimer); } catch(e){}
            try { if (weatherRefreshTimer) clearInterval(weatherRefreshTimer); } catch(e){}
            try { if (lastUpdateTicker) clearInterval(lastUpdateTicker); } catch(e){}
        });

        // EARLY DECLARATION: Make toggleAutomationPanel available to onclick handlers in HTML
        window.toggleAutomationPanel = function(forceState) {
            console.warn('[Early] toggleAutomationPanel called before full initialization');
        };

        // ==================== CONFIGURATION ====================
        // Centralized configuration for all timing and thresholds
        const CONFIG = {
            // Data refresh intervals (should match backend cache TTLs)
            refresh: {
                amberPricesMs: 60 * 1000,      // 60 seconds - Amber prices
                inverterMs: 5 * 60 * 1000,     // 5 minutes - Inverter data
                weatherMs: 30 * 60 * 1000      // 30 minutes - Weather data
            },
            
            // Cache TTL values (updated from backend config)
            cache: {
                amber: 60 * 1000,              // 60 seconds - Amber prices cache TTL
                inverter: 5 * 60 * 1000,       // 5 minutes - Inverter data cache TTL
                weather: 30 * 60 * 1000        // 30 minutes - Weather data cache TTL
            },
            
            // Automation timing
            automation: {
                intervalMs: 60 * 1000,         // How often automation cycles run (must match backend)
                countdownUpdateMs: 1000        // How often to update countdown display
            },
            
            // UI timing
            ui: {
                statusFadeMs: 5000,            // How long to show status messages
                schedulerReloadDelayMs: 800,   // Delay before reloading scheduler after changes
                amberRetryDelayMs: 500,        // Delay before retrying Amber API call
                toggleAnimationDelayMs: 100,   // Delay for toggle button position update
                automationLoadDelayMs: 300,    // Delay before loading automation status
                tickerIntervalMs: 1000,        // Update interval for 'time since' labels
                copyButtonResetMs: 2000,       // Time to show 'copied' state on copy button
                clearAllDelayMs: 2000          // Delay in clear all segments
            },
            
            // API timeouts
            timeout: {
                schedulerMs: 30000,            // Timeout for scheduler API calls
                testAutomationMs: 15000        // Timeout for test automation calls
            },
            
            // Display limits
            display: {
                forecastLimit: 48,             // Max forecast intervals to show
                defaultAmberNext: 12           // Default number of Amber forecast intervals
            },
            
            // User preferences loaded from backend
            preferences: {
                forecastDays: 6                // User's preferred forecast days (loaded from backend)
            }
        };
        
        // Legacy alias for backwards compatibility
        const REFRESH = CONFIG.refresh;

        const DASHBOARD_CARD_VISIBILITY_DEFAULTS = {
            inverter: true,
            prices: true,
            weather: true,
            quickControls: true,
            scheduler: true
        };
        let dashboardCardVisibilityState = { ...DASHBOARD_CARD_VISIBILITY_DEFAULTS };

        function getDashboardCardVisibilityStorageKey() {
            try {
                const uid = window.AppShell && typeof window.AppShell.getUser === 'function'
                    ? window.AppShell.getUser()?.uid
                    : null;
                return `dashboardCardVisibility:${uid || 'guest'}`;
            } catch (e) {
                return 'dashboardCardVisibility:guest';
            }
        }

        function loadDashboardCardVisibilityPreferences() {
            dashboardCardVisibilityState = { ...DASHBOARD_CARD_VISIBILITY_DEFAULTS };
            try {
                const storageKey = getDashboardCardVisibilityStorageKey();
                let raw = localStorage.getItem(storageKey);
                if (!raw && storageKey !== 'dashboardCardVisibility:guest') {
                    const guestRaw = localStorage.getItem('dashboardCardVisibility:guest');
                    if (guestRaw) {
                        raw = guestRaw;
                        try { localStorage.setItem(storageKey, guestRaw); } catch (copyErr) {}
                    }
                }
                if (!raw) return;
                const parsed = JSON.parse(raw);
                if (!parsed || typeof parsed !== 'object') return;
                Object.keys(DASHBOARD_CARD_VISIBILITY_DEFAULTS).forEach((key) => {
                    if (typeof parsed[key] === 'boolean') {
                        dashboardCardVisibilityState[key] = parsed[key];
                    }
                });
            } catch (e) {
                console.warn('[Dashboard] Failed to load card visibility preferences', e);
            }
        }

        function saveDashboardCardVisibilityPreferences() {
            try {
                const payload = JSON.stringify(dashboardCardVisibilityState);
                const storageKey = getDashboardCardVisibilityStorageKey();
                localStorage.setItem(
                    storageKey,
                    payload
                );
                if (storageKey !== 'dashboardCardVisibility:guest') {
                    localStorage.setItem('dashboardCardVisibility:guest', payload);
                }
            } catch (e) {
                console.warn('[Dashboard] Failed to save card visibility preferences', e);
            }
        }

        function syncDashboardCardVisibilityToggles() {
            const toggles = document.querySelectorAll('[data-dashboard-toggle]');
            toggles.forEach((toggle) => {
                const key = toggle.getAttribute('data-dashboard-toggle');
                if (!key || !(key in DASHBOARD_CARD_VISIBILITY_DEFAULTS)) return;
                toggle.checked = dashboardCardVisibilityState[key] !== false;
            });
        }

        function applyDashboardCardVisibility() {
            const cards = document.querySelectorAll('[data-dashboard-card]');
            cards.forEach((card) => {
                const key = card.getAttribute('data-dashboard-card');
                if (!key || !(key in DASHBOARD_CARD_VISIBILITY_DEFAULTS)) return;
                const isVisible = dashboardCardVisibilityState[key] !== false;
                card.classList.toggle('is-hidden-preference', !isVisible);
            });

            const priorityRow = document.getElementById('priorityRow');
            if (priorityRow) {
                const hasVisibleCards = !!priorityRow.querySelector('[data-dashboard-card]:not(.is-hidden-preference)');
                priorityRow.classList.toggle('is-hidden-preference', !hasVisibleCards);
            }

            syncDashboardCardVisibilityToggles();
        }

        function initDashboardCardVisibilityPreferences() {
            loadDashboardCardVisibilityPreferences();
            applyDashboardCardVisibility();
        }

        function initDashboardVisibilityCollapse() {
            const card = document.querySelector('.dashboard-visibility-card');
            const button = document.getElementById('dashboardVisibilityToggleBtn');
            if (!card || !button) return;

            const mobileQuery = window.matchMedia('(max-width: 900px)');

            const syncState = () => {
                if (mobileQuery.matches) {
                    const expanded = card.classList.contains('mobile-expanded');
                    button.setAttribute('aria-expanded', expanded ? 'true' : 'false');
                    button.textContent = expanded ? 'Hide' : 'Show';
                } else {
                    card.classList.remove('mobile-expanded');
                    button.setAttribute('aria-expanded', 'true');
                    button.textContent = 'Hide';
                }
            };

            card.classList.remove('mobile-expanded');
            syncState();

            button.addEventListener('click', () => {
                if (!mobileQuery.matches) return;
                card.classList.toggle('mobile-expanded');
                syncState();
            });

            if (typeof mobileQuery.addEventListener === 'function') {
                mobileQuery.addEventListener('change', syncState);
            } else if (typeof mobileQuery.addListener === 'function') {
                mobileQuery.addListener(syncState);
            }
        }

        function refreshDashboardCardVisibilityPreferencesForCurrentUser() {
            initDashboardCardVisibilityPreferences();
        }

        function toggleDashboardCardVisibility(cardKey, toggleEl) {
            if (!(cardKey in DASHBOARD_CARD_VISIBILITY_DEFAULTS)) return;
            dashboardCardVisibilityState[cardKey] = !!(toggleEl && toggleEl.checked);
            saveDashboardCardVisibilityPreferences();
            applyDashboardCardVisibility();
        }

        window.toggleDashboardCardVisibility = toggleDashboardCardVisibility;

        // Timer handles for auto-refresh (kept so we can cancel/replace during dev)
        let amberRefreshTimer = null;
        let inverterRefreshTimer = null;
        let weatherRefreshTimer = null;

        // Auto-refresh control: pause when tab hidden or after idle timeout
        const IDLE_TIMEOUT_MS = 10 * 60 * 1000; // 10 minutes of no interaction
        let lastUserActivity = Date.now();
        let isPageVisible = !document.hidden;
        let idleCheckTimer = null;
        let autoRefreshActive = false;  // Start as false so timers will actually start

        // Map of last update timestamps (ms since epoch)
        const lastUpdated = {
            inverter: null,           // client local ms when we last successfully fetched from API
            inverterCloud: null,      // cloud-recorded timestamp (ms) as returned by API
            amber: null,
            weather: null
        };

        // UI ticker for 'time since' labels
        let lastUpdateTicker = null;

        // Helper to format milliseconds to human-readable string
        function formatMsToReadable(ms) {
            if (!ms || ms <= 0) return '—';
            const sec = Math.floor(ms / 1000);
            if (sec < 60) return sec + 's';
            const min = Math.floor(sec / 60);
            if (min < 60) return min + 'm';
            const hours = Math.floor(min / 60);
            if (hours < 24) return hours + 'h';
            const days = Math.floor(hours / 24);
            return days + 'd';
        }

        /**
         * Stop all auto-refresh timers (when page hidden or idle)
         */
        function stopAutoRefreshTimers() {
            if (!autoRefreshActive) return; // Already stopped
            
            if (amberRefreshTimer) {
                clearInterval(amberRefreshTimer);
                amberRefreshTimer = null;
            }
            if (inverterRefreshTimer) {
                clearInterval(inverterRefreshTimer);
                inverterRefreshTimer = null;
            }
            if (weatherRefreshTimer) {
                clearInterval(weatherRefreshTimer);
                weatherRefreshTimer = null;
            }
            if (window.metricsRefreshTimer) {
                clearInterval(window.metricsRefreshTimer);
                window.metricsRefreshTimer = null;
            }
            if (window.automationStatusRefreshInterval) {
                clearInterval(window.automationStatusRefreshInterval);
                window.automationStatusRefreshInterval = null;
            }
            
            autoRefreshActive = false;
        }

        /**
         * Start all auto-refresh timers (when page visible and active)
         */
        function startAutoRefreshTimers() {
            if (autoRefreshActive) {
                return; // Already running
            }
            
            // Amber prices: every 60s (with cache bypass)
            if (!amberRefreshTimer) {
                amberRefreshTimer = setInterval(() => {
                    const siteId = document.getElementById('amberSiteId')?.value;
                    if (siteId) {
                        getAmberCurrent(true);
                    }
                }, REFRESH.amberPricesMs);
            }

            // Inverter real-time data: every 5 minutes (with cache bypass)
            if (!inverterRefreshTimer) {
                inverterRefreshTimer = setInterval(() => {
                    callAPI('/api/inverter/real-time', 'Real-time Data', false, true);
                }, REFRESH.inverterMs);
            }

            // Weather: every 30 minutes (with cache bypass)
            if (!weatherRefreshTimer) {
                weatherRefreshTimer = setInterval(() => {
                    getWeather(true);
                }, REFRESH.weatherMs);
            }

            // API call metrics: every 30 seconds
            if (!window.metricsRefreshTimer) {
                window.metricsRefreshTimer = setInterval(() => {
                    loadApiMetrics(1);
                }, 30000);
            }

            // Automation status: every 30 seconds
            if (!window.automationStatusRefreshInterval) {
                window.automationStatusRefreshInterval = setInterval(() => {
                    try {
                        loadBackendAutomationStatus();
                    } catch (e) {
                        console.warn('[Automation] Failed to refresh status:', e);
                    }
                }, 30000);
            }
            
            autoRefreshActive = true;
        }

        /**
         * Check if user has been idle too long, stop timers if so
         * NOTE: Disabled for dashboards - we want continuous refresh even when passive monitoring
         */
        function checkIdleTimeout() {
            // Idle timeout disabled - dashboard should refresh continuously
            return;
            
            /*
            const idleTime = Date.now() - lastUserActivity;
            if (idleTime > IDLE_TIMEOUT_MS && autoRefreshActive) {
                console.log(`[AutoRefresh] User idle for ${Math.floor(idleTime/1000/60)} minutes, stopping auto-refresh`);
                stopAutoRefreshTimers();
            }
            */
        }

        /**
         * Track user activity to prevent idle timeout
         */
        function recordUserActivity() {
            const wasIdle = !autoRefreshActive;
            lastUserActivity = Date.now();
            
            // If we were idle and page is visible, restart timers
            if (wasIdle && isPageVisible) {
                startAutoRefreshTimers();
            }
        }

        // Set up Page Visibility API to pause/resume on tab switch
        // DISABLED: Visibility changes are being triggered inappropriately, breaking refresh
        // Just use interval timers instead - they're more reliable
        /*

        // Track user activity events
        ['mousedown', 'keydown', 'touchstart', 'scroll', 'click'].forEach(event => {
            document.addEventListener(event, recordUserActivity, { passive: true });
        });

        // Check for idle timeout every minute
        idleCheckTimer = setInterval(checkIdleTimeout, 60000);
        */

        // Helper to format milliseconds to human-readable string
        function formatMsToReadable(ms) {
            if (!ms || ms <= 0) return '—';
            const sec = Math.floor(ms / 1000);
            if (sec < 60) return sec + 's';
            const min = Math.floor(sec / 60);
            if (min < 60) return min + ' min';
            const hours = Math.floor(min / 60);
            return hours + 'h ' + (min % 60) + 'm';
        }

        // Update FAQ display values from CONFIG
        function updateFaqValues() {
            try {
                // Automation interval
                const faqInterval = document.getElementById('faqAutomationInterval');
                if (faqInterval) faqInterval.textContent = formatMsToReadable(CONFIG.automation.intervalMs);
                
                // Cache intervals
                const faqAmber = document.getElementById('faqAmberCache');
                if (faqAmber) faqAmber.textContent = formatMsToReadable(CONFIG.refresh.amberPricesMs);
                
                const faqInverter = document.getElementById('faqInverterCache');
                if (faqInverter) faqInverter.textContent = formatMsToReadable(CONFIG.refresh.inverterMs);
                
                const faqWeather = document.getElementById('faqWeatherCache');
                if (faqWeather) faqWeather.textContent = formatMsToReadable(CONFIG.refresh.weatherMs);
                
                // Cooldown
                const faqCooldown = document.getElementById('faqCooldown');
                if (faqCooldown) faqCooldown.textContent = (CONFIG.defaults?.cooldownMinutes || 5) + ' minutes';
                
                // Cancel interval (same as automation interval)
                const faqCancel = document.getElementById('faqCancelInterval');
                if (faqCancel) faqCancel.textContent = formatMsToReadable(CONFIG.automation.intervalMs);
            } catch (e) {
                console.warn('Failed to update FAQ values:', e);
            }
        }

        function formatSince(ts) {
            if (!ts) return '—';
            const delta = Math.floor((Date.now() - ts) / 1000);
            if (delta <= 2) return 'just now';
            if (delta < 60) return `${delta}s ago`;
            const mins = Math.floor(delta / 60);
            if (mins < 60) return `${mins}m ${delta % 60}s ago`;
            const hours = Math.floor(mins / 60);
            return `${hours}h ${mins % 60}m ago`;
        }

        // Format a date/timestamp to DD/MM/YYYY optionally with time
        function formatDate(ts, withTime = false, withSeconds = false, timeZone = null) {
            if (!ts) return '—';
            
            // Handle date-only strings (YYYY-MM-DD) from weather API
            // These should be treated as LOCAL dates, not UTC
            if (typeof ts === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(ts)) {
                const [yyyy, mm, dd] = ts.split('-');
                if (!withTime) return `${dd}/${mm}/${yyyy}`;
                return `${dd}/${mm}/${yyyy} --:--`;
            }
            
            // Handle Firestore Timestamp objects
            let timestamp = ts;
            if (typeof ts === 'object' && ts !== null) {
                // Firestore Timestamp: {_seconds, _nanoseconds} or {seconds, nanos}
                const sec = ts._seconds ?? ts.seconds;
                if (typeof sec === 'number') {
                    timestamp = sec * 1000;
                } else if (ts.toMillis) {
                    // Firestore client SDK Timestamp
                    timestamp = ts.toMillis();
                } else if (ts.toDate) {
                    timestamp = ts.toDate().getTime();
                }
            }
            
            const d = (timestamp instanceof Date) ? timestamp : new Date(Number(timestamp) || timestamp);
            if (isNaN(d.getTime())) return '—';
            
            let dd, mm, yyyy, hh, min, sec;
            
            // If specific timezone requested, use toLocaleString to get time in that timezone
            if (timeZone && withTime) {
                try {
                    // Use Intl.DateTimeFormat to convert to user's timezone
                    const formatter = new Intl.DateTimeFormat('en-GB', {
                        timeZone,
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                    const parts = formatter.formatToParts(d);
                    const values = {};
                    parts.forEach(p => values[p.type] = p.value);
                    dd = values.day;
                    mm = values.month;
                    yyyy = values.year;
                    hh = values.hour;
                    min = values.minute;
                    sec = values.second;
                } catch (e) {
                    // Fall back to browser timezone if timezone is invalid
                    return formatDate(ts, withTime, withSeconds, null);
                }
            } else {
                // Use browser's local timezone
                dd = String(d.getDate()).padStart(2, '0');
                mm = String(d.getMonth() + 1).padStart(2, '0');
                yyyy = d.getFullYear();
                hh = String(d.getHours()).padStart(2, '0');
                min = String(d.getMinutes()).padStart(2, '0');
                sec = String(d.getSeconds()).padStart(2, '0');
            }
            
            if (!withTime) return `${dd}/${mm}/${yyyy}`;
            if (withSeconds) {
                return `${dd}/${mm}/${yyyy} ${hh}:${min}:${sec}`;
            }
            return `${dd}/${mm}/${yyyy} ${hh}:${min}`;
        }

        /**
         * Format a forecast day (YYYY-MM-DD) with day of week and date (e.g., "Wednesday - 7/1/2026")
         * @param {string} dateStr - YYYY-MM-DD date string
         * @returns {string} e.g. "Wednesday - 07/12/2025" or "Thursday - 08/12/2025"
         */
        function formatForecastDay(dateStr) {
            if (!dateStr || !/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                return formatDate(dateStr, false);
            }
            
            const [yyyy, mm, dd] = dateStr.split('-').map(Number);
            const forecastDate = new Date(yyyy, mm - 1, dd);
            
            const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const dayOfWeek = daysOfWeek[forecastDate.getDay()];
            
            return `${dayOfWeek} - ${dd}/${mm}/${yyyy}`;
        }
        
        // Format automation cycle result for debug display
        function formatCycleResult(result) {
            if (!result) return '<span style="color:var(--text-muted);font-size:11px">No data</span>';
            
            let html = '';
            
            if (result.skipped) {
                html += `<span style="color:var(--color-orange);font-size:11px">⏭️ Skipped: ${result.reason || 'Unknown'}</span>`;
                return html;
            }
            
            // Main result section - triggered or not
            if (result.triggered && result.rule) {
                // Support both old format (no status) and new format (with status field)
                const statusIndicator = result.status === 'continuing' ? '⏱️ Continuing'
                                      : result.status === 'new_trigger' ? '✅ New Trigger'
                                      : '?';
                const statusColor = result.status === 'continuing' ? 'var(--accent-blue-hover)'
                                  : result.status === 'new_trigger' ? 'var(--color-success)'
                                  : 'var(--text-secondary)';
                
                html += `<span style="color:${statusColor};font-weight:600;font-size:11px">${statusIndicator} <strong>${result.rule.name || 'Unknown'}</strong>`;
                
                if (result.rule.actionResult) {
                    const ar = result.rule.actionResult;
                    if (ar.errno === 0) {
                        html += ` <span style="color:var(--color-success)">✓ API Continuing</span>`;
                    } else {
                        // API FAILED - show prominent error
                        html += `</span><div style="margin-top:6px;padding:8px;background:rgba(248,81,73,0.15);border:1px solid var(--color-danger);border-radius:4px">`;
                        html += `<span style="color:var(--color-danger);font-weight:600">❌ API FAILED</span>`;
                        html += `<span style="color:var(--color-danger);font-size:10px"> • errno=${ar.errno}</span>`;
                        if (ar.msg) html += `<br><span style="color:var(--color-danger);font-size:10px">${ar.msg}</span>`;
                        html += `</div><span>`;
                    }
                }
                html += `</span>`;
            } else {
                html += `<span style="color:var(--text-secondary);font-size:11px">ℹ️ No rules triggered</span>`;
            }
            
            // Show evaluation summary with condition details - inline
            if (result.evaluationResults && result.evaluationResults.length > 0) {
                html += `<div style="margin-top:6px;display:flex;flex-wrap:wrap;gap:6px;align-items:flex-start">`;
                
                result.evaluationResults.forEach(er => {
                    const icon = er.result === 'triggered' ? '✅' : er.result === 'continuing' ? '⏱️' : er.result === 'cooldown' ? '⏳' : '❌';
                    const bgColor = er.result === 'triggered' ? 'rgba(126,231,135,0.1)' 
                                  : er.result === 'continuing' ? 'rgba(121,192,255,0.1)'
                                  : er.result === 'cooldown' ? 'rgba(240,136,62,0.1)' 
                                  : 'rgba(248,81,73,0.1)';
                    const borderColor = er.result === 'triggered' ? 'var(--color-success)'
                                      : er.result === 'continuing' ? 'var(--accent-blue-hover)'
                                      : er.result === 'cooldown' ? 'var(--color-orange)'
                                      : 'var(--color-danger)';
                    const textColor = er.result === 'triggered' ? 'var(--color-success)'
                                    : er.result === 'continuing' ? 'var(--accent-blue-hover)'
                                    : er.result === 'cooldown' ? 'var(--color-orange)'
                                    : 'var(--color-danger)';
                    
                    html += `<div style="background:${bgColor};border:1px solid ${borderColor};border-radius:3px;padding:4px 6px;display:inline-flex;align-items:center;gap:3px;font-size:10px">`;
                    html += `<span style="color:${textColor};font-weight:600">${icon} ${er.rule}</span>`;
                    
                    // Show cooldown info for continuing rules
                    if (er.result === 'continuing' && er.cooldownRemaining != null) {
                        html += `<span style="color:var(--accent-blue-hover);font-size:9px"> • ${Math.ceil(er.cooldownRemaining)}s cooldown</span>`;
                    }
                    
                    // Show individual condition details inline if available
                    if (er.details?.results && er.details.results.length > 0) {
                        const condSummary = er.details.results.map(cond => {
                            const condIcon = cond.met ? '✓' : '✗';
                            const condColor = cond.met ? 'var(--color-success)' : 'var(--color-danger)';
                            let short = '';
                            if (cond.condition === 'soc') {
                                short = `SoC: ${cond.actual != null ? cond.actual + '%' : '—'}${cond.reason ? ' (N/A)' : ''}`;
                            } else if (cond.condition === 'feedInPrice') {
                                short = `FI: ${cond.actual?.toFixed(1)}¢`;
                            } else if (cond.condition === 'buyPrice') {
                                short = `Buy: ${cond.actual?.toFixed(1)}¢`;
                            } else if (cond.condition === 'temperature') {
                                short = `${cond.type || 'T'}: ${cond.actual}°C`;
                            } else if (cond.condition === 'time') {
                                short = `Time: ${cond.actual}`;
                            } else if (cond.condition === 'solarRadiation') {
                                short = `☀️ ${cond.actual || '—'}W/m²`;
                            } else if (cond.condition === 'cloudCover') {
                                short = `☁️ ${cond.actual || '—'}%`;
                            } else {
                                short = `${cond.condition}: ${cond.actual}`;
                            }
                            return `<span style="color:${condColor}">${condIcon} ${short}</span>`;
                        }).join(' • ');
                        html += `<span style="color:var(--text-muted);font-size:9px"> | ${condSummary}</span>`;
                    }
                    html += `</div>`;
                });
                html += `</div>`;
            }
            
            // Footer summary inline
            html += `<div style="margin-top:6px;color:var(--text-muted);font-size:10px">📊 ${result.rulesEvaluated || 0}/${result.totalRules || 0} rules</div>`;
            
            return html;
        }

        // Update solar tile curtailment indicator
        function updateSolarTileCurtailmentIndicator() {
            const solarTile = document.getElementById('solar-tile');
            if (!solarTile) return;
            
            const isCurtailed = window.curtailmentState && window.curtailmentState.active;
            const label = solarTile.querySelector('.label');
            
            if (isCurtailed) {
                solarTile.classList.add('curtailed');
                if (label) {
                    label.textContent = 'Solar Production (Curtailed)';
                }
            } else {
                solarTile.classList.remove('curtailed');
                if (label) {
                    label.textContent = 'Solar Production';
                }
            }
        }

        // Parse FoxESS cloud time strings like "2025-11-29 19:01:57 AEDT+1100" into epoch ms.
        function parseFoxESSCloudTime(s) {
            if (!s || typeof s !== 'string') return null;
            // Try to find an ISO-like datetime + offset (e.g., "2025-11-29 19:01:57 AEDT+1100")
            // We'll extract the date/time and the trailing +HHMM or -HHMM offset if present.
            const m = s.match(/(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})(?:.*?([+-]\d{4}))?$/);
            if (!m) return null;
            const base = m[1];
            const offset = m[2];
            // Convert to ISO by replacing space between date and time with 'T'
            let iso = base.replace(' ', 'T');
            if (offset) {
                // convert +1100 -> +11:00
                const off = offset.replace(/([+-]\d{2})(\d{2})/, '$1:$2');
                iso = iso + off;
            } else {
                // No explicit offset; treat as local time
            }
            const d = Date.parse(iso);
            if (isNaN(d)) return null;
            return d;
        }

        function updateLastUpdateDisplays() {
            try {
                const inv = document.getElementById('inverterLastUpdate');
                const amb = document.getElementById('amberLastUpdate');
                const we = document.getElementById('weatherLastUpdate');
                if (inv) {
                    // Show "time since cloud sync" if available, otherwise fallback to fetch time
                    if (lastUpdated.inverterCloud) {
                        const text = formatSince(lastUpdated.inverterCloud) + ' (cloud)';
                        inv.textContent = text;
                    } else if (lastUpdated.inverter) {
                        const text = formatSince(lastUpdated.inverter);
                        inv.textContent = text;
                    } else {
                        inv.textContent = '—';
                    }
                }
                if (amb) {
                    const text = lastUpdated.amber ? formatSince(lastUpdated.amber) : '—';
                    amb.textContent = text;
                }
                if (we) {
                    const text = lastUpdated.weather ? formatSince(lastUpdated.weather) : '—';
                    we.textContent = text;
                }

                // Also update the detailed inverter cloud/fetch labels
                try {
                    const cloudEl = document.getElementById('inverterCloudTime');
                    const fetchAgoEl = document.getElementById('inverterFetchAgo');
                    if (cloudEl) {
                        const text = lastUpdated.inverterCloud ? `cloud: ${formatDate(lastUpdated.inverterCloud, true)}` : '—';
                        cloudEl.textContent = text;
                    }
                    if (fetchAgoEl) {
                        const text = lastUpdated.inverter ? formatSince(lastUpdated.inverter) : '—';
                        fetchAgoEl.textContent = text;
                    }
                } catch (e) { console.error('Error updating inverter display details:', e); }
            } catch (e) { console.error('Error in updateLastUpdateDisplays:', e); }
        }

        function setLastUpdated(key) {
            if (!['inverter','amber','weather'].includes(key)) return;
            lastUpdated[key] = Date.now();
            updateLastUpdateDisplays();
        }

        // -------------------------
        // Automation panel resizer
        // -------------------------
        // Toggle automation panel - standalone function
        window.toggleAutomationPanel = function(forceState) {
            try {
                const panel = document.querySelector('.automation-panel');
                const resizer = document.getElementById('automationResizer');
                const btn = document.getElementById('automationToggleBtn');
                if (!panel) return;
                
                const isCollapsed = panel.classList.contains('collapsed');
                let targetCollapsed = typeof forceState === 'boolean' ? forceState : !isCollapsed;

                    if (targetCollapsed) {
                    panel.classList.add('collapsed');
                    if (resizer) resizer.style.display = 'none';
                    if (btn) {
                        btn.innerHTML = '<span class="automation-toggle-icon">' +
                        '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">' +
                        '<defs><linearGradient id="robotBody" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:#667eea;stop-opacity:1" /><stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" /></linearGradient></defs>' +
                        '<rect x="5" y="8" width="14" height="10" rx="3" fill="url(#robotBody)" stroke="#5567d8" stroke-width="0.5" />' +
                        '<rect x="7" y="4" width="10" height="4" rx="2" fill="#667eea" stroke="#5567d8" stroke-width="0.5" />' +
                        '<circle cx="9.5" cy="11" r="1.3" fill="#fff" />' +
                        '<circle cx="14.5" cy="11" r="1.3" fill="#fff" />' +
                        '<circle cx="9.5" cy="11" r="0.7" fill="#667eea" />' +
                        '<circle cx="14.5" cy="11" r="0.7" fill="#667eea" />' +
                        '<rect x="10" y="15" width="4" height="1.5" rx="0.7" fill="#764ba2" />' +
                        '<circle cx="6" cy="4" r="0.8" fill="#ffd700" />' +
                        '</svg></span><span class="automation-toggle-arrow">◀</span>';
                        // When collapsed, allow the toggle to receive pointer events (so it can be clicked)
                        try { btn.style.pointerEvents = 'auto'; } catch(e) {}
                    }
                } else {
                    panel.classList.remove('collapsed');
                    if (resizer) resizer.style.display = 'flex';
                    if (btn) {
                        btn.innerHTML = '<span class="automation-toggle-icon">' +
                        '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">' +
                        '<defs><linearGradient id="robotBody" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:#667eea;stop-opacity:1" /><stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" /></linearGradient></defs>' +
                        '<rect x="5" y="8" width="14" height="10" rx="3" fill="url(#robotBody)" stroke="#5567d8" stroke-width="0.5" />' +
                        '<rect x="7" y="4" width="10" height="4" rx="2" fill="#667eea" stroke="#5567d8" stroke-width="0.5" />' +
                        '<circle cx="9.5" cy="11" r="1.3" fill="#fff" />' +
                        '<circle cx="14.5" cy="11" r="1.3" fill="#fff" />' +
                        '<circle cx="9.5" cy="11" r="0.7" fill="#667eea" />' +
                        '<circle cx="14.5" cy="11" r="0.7" fill="#667eea" />' +
                        '<rect x="10" y="15" width="4" height="1.5" rx="0.7" fill="#764ba2" />' +
                        '<circle cx="6" cy="4" r="0.8" fill="#ffd700" />' +
                        '</svg></span><span class="automation-toggle-arrow">▶</span>';
                        // Keep the toggle clickable even when expanded
                        try { btn.style.pointerEvents = 'auto'; } catch(e) {}
                    }
                }
                try { localStorage.setItem('automationPanelCollapsed', targetCollapsed ? 'true' : 'false'); } catch(e) {}
            } catch (e) { console.warn('toggleAutomationPanel error', e); }
        };

        function initAutomationResizer() {
            const leftPanel = document.querySelector('.left-panel');
            const resizer = document.getElementById('automationResizer');
            const panel = document.querySelector('.automation-panel');
            if (!leftPanel || !resizer || !panel) return;

            // restore saved width + collapsed state
            try {
                const saved = localStorage.getItem('automationPanelWidth');
                if (saved) panel.style.width = saved;
                const collapsedSaved = localStorage.getItem('automationPanelCollapsed');
                // default to collapsed unless explicitly set to 'false'
                if (collapsedSaved !== 'false') {
                    panel.classList.add('collapsed');
                    // hide resizer if collapsed
                    try { resizer.style.display = 'none'; } catch(e) {}
                    try {
                        const tbtn = document.getElementById('automationToggleBtn');
                        if (tbtn) {
                            tbtn.innerHTML = '<span class="automation-toggle-icon">' +
                        '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">' +
                        '<defs><linearGradient id="robotBody" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:#667eea;stop-opacity:1" /><stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" /></linearGradient></defs>' +
                        '<rect x="5" y="8" width="14" height="10" rx="3" fill="url(#robotBody)" stroke="#5567d8" stroke-width="0.5" />' +
                        '<rect x="7" y="4" width="10" height="4" rx="2" fill="#667eea" stroke="#5567d8" stroke-width="0.5" />' +
                        '<circle cx="9.5" cy="11" r="1.3" fill="#fff" />' +
                        '<circle cx="14.5" cy="11" r="1.3" fill="#fff" />' +
                        '<circle cx="9.5" cy="11" r="0.7" fill="#667eea" />' +
                        '<circle cx="14.5" cy="11" r="0.7" fill="#667eea" />' +
                        '<rect x="10" y="15" width="4" height="1.5" rx="0.7" fill="#764ba2" />' +
                        '<circle cx="6" cy="4" r="0.8" fill="#ffd700" />' +
                        '</svg></span><span class="automation-toggle-arrow">◀</span>';
                            try { tbtn.style.pointerEvents = 'auto'; } catch(e) {}
                        }
                    } catch(e) {}
                }
            } catch (e) {}

            let dragging = false;
            let pointerId = null;
            const minW = 220;
            const maxW = Math.min(900, leftPanel.clientWidth - 160);
            // Pointer Events (preferred): covers mouse, touch, stylus
            // We'll attach a full-window transparent overlay while dragging so other panels
            // (like the API response right-panel) can't steal pointer events.
            let dragOverlay = null;
            function createOverlay() {
                if (dragOverlay) return dragOverlay;
                dragOverlay = document.createElement('div');
                dragOverlay.id = 'resizerDragOverlay';
                Object.assign(dragOverlay.style, {
                    position: 'fixed', top: '0', left: '0', right: '0', bottom: '0',
                    background: 'transparent', zIndex: 9990, cursor: 'col-resize'
                });
                return dragOverlay;
            }

            resizer.addEventListener('pointerdown', (ev) => {
                try { ev.preventDefault(); } catch(e){}
                dragging = true;
                pointerId = ev.pointerId;
                try { resizer.setPointerCapture(pointerId); } catch(e) {}
                // add overlay to ensure we keep receiving pointer events even when cursor
                // moves over other interactive panels
                try {
                    const o = createOverlay();
                    document.body.appendChild(o);
                } catch (e) { /* ignore overlay failures */ }
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            document.addEventListener('pointermove', (ev) => {
                if (!dragging) return;
                // if pointerId is set, only respond to that pointer
                if (pointerId !== null && ev.pointerId !== pointerId) return;
                // Anchor width calculation to the window's right edge minus the right panel width
                // (mirrors the working right-panel resizer logic). This prevents event
                // interception when the cursor moves over the right panel.
                let newW = Math.round((window.innerWidth - (rightPanel?.offsetWidth || 0)) - ev.clientX);
                const maxForNow = Math.min(maxW, (window.innerWidth - (rightPanel?.offsetWidth || 0)) - (leftPanel.getBoundingClientRect().left + 120));
                if (newW < minW) newW = minW;
                if (newW > maxForNow) newW = maxForNow;
                panel.style.width = newW + 'px';
            });

            document.addEventListener('pointerup', (ev) => {
                if (!dragging) return;
                if (pointerId !== null && ev.pointerId !== pointerId) return;
                dragging = false;
                try { resizer.releasePointerCapture(ev.pointerId); } catch (e) {}
                pointerId = null;
                // remove overlay
                try { const o = document.getElementById('resizerDragOverlay'); if (o && o.parentNode) o.parentNode.removeChild(o); } catch(e) {}
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                try { localStorage.setItem('automationPanelWidth', panel.style.width); } catch(e) {}
            });

            // Fallback for older browsers: also listen for mouse/touch
            resizer.addEventListener('mousedown', (ev) => {
                try { ev.preventDefault(); } catch(e){}
                dragging = true;
                try { const o = createOverlay(); document.body.appendChild(o); } catch(e){}
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            document.addEventListener('mousemove', (ev) => { if (!dragging) return; let newW = Math.round((window.innerWidth - (rightPanel?.offsetWidth || 0)) - ev.clientX); const maxForNow = Math.min(maxW, (window.innerWidth - (rightPanel?.offsetWidth || 0)) - (leftPanel.getBoundingClientRect().left + 120)); if (newW < minW) newW = minW; if (newW > maxForNow) newW = maxForNow; panel.style.width = newW + 'px'; });
            document.addEventListener('mouseup', () => { if (dragging) { dragging = false; try { const o = document.getElementById('resizerDragOverlay'); if (o && o.parentNode) o.parentNode.removeChild(o); } catch(e){} document.body.style.cursor = ''; document.body.style.userSelect = ''; try { localStorage.setItem('automationPanelWidth', panel.style.width); } catch(e) {} } });

            resizer.addEventListener('touchstart', (ev) => { try { ev.preventDefault(); } catch(e){} dragging = true; try { const o = createOverlay(); document.body.appendChild(o); } catch(e){} document.body.style.cursor = 'col-resize'; document.body.style.userSelect = 'none'; }, {passive:false});
            document.addEventListener('touchmove', (ev) => { if (!dragging) return; const touch = ev.touches[0]; if (!touch) return; let newW = Math.round((window.innerWidth - (rightPanel?.offsetWidth || 0)) - touch.clientX); const maxForNow = Math.min(maxW, (window.innerWidth - (rightPanel?.offsetWidth || 0)) - (leftPanel.getBoundingClientRect().left + 120)); if (newW < minW) newW = minW; if (newW > maxForNow) newW = maxForNow; panel.style.width = newW + 'px'; }, {passive:true});
            document.addEventListener('touchend', () => { dragging = false; try { const o = document.getElementById('resizerDragOverlay'); if (o && o.parentNode) o.parentNode.removeChild(o); } catch(e){} document.body.style.cursor = ''; document.body.style.userSelect = ''; try { localStorage.setItem('automationPanelWidth', panel.style.width); } catch(e) {} }, {passive:true});
        }

        // Init - set up UI state on page load (NO authenticated API calls here!)
        document.addEventListener('DOMContentLoaded', () => {
            // Suppress auto-opening of the right-panel while the page initializes
            window.suppressPanelAutoOpen = true;

            initDashboardCardVisibilityPreferences();
            initDashboardVisibilityCollapse();

            // Ensure right-panel collapsed by default unless user explicitly expanded it before
            try {
                let saved = localStorage.getItem('rightPanelCollapsed');
                // If the user has no saved preference, default to collapsed and persist that choice
                if (saved === null) {
                    try { localStorage.setItem('rightPanelCollapsed', 'true'); } catch(e) {}
                    saved = 'true';
                }
                const panel = document.getElementById('rightPanel');
                const toggleBtn = document.getElementById('toggleBtn');
                // localStorage stores 'true' when collapsed, 'false' when expanded
                // Default to collapsed (panelCollapsed=true) unless explicitly set to 'false'
                if (saved === 'false') {
                    // User previously expanded the panel - keep it expanded
                    if (panel) panel.classList.remove('collapsed');
                    if (toggleBtn) {
                        toggleBtn.textContent = 'R ▶';
                    }
                    panelCollapsed = false;
                    setTimeout(updateToggleBtnPosition, 100);
                } else {
                    // Default or 'true' - keep collapsed
                    if (panel) panel.classList.add('collapsed');
                    if (toggleBtn) {
                        toggleBtn.textContent = 'R ◀';
                        toggleBtn.style.right = '0px';
                    }
                    panelCollapsed = true;
                }
            } catch (e) { /* ignore */ }
            // NOTE: All authenticated API calls are deferred to initializePageData()
            // which is called only after firebaseAuth confirms user is authenticated
        });
        
        // =====================================================
        // PAGE RELOAD DETECTION & CACHE BYPASS
        // =====================================================
        // Detect page reload to force cache bypass on initial load
        let isPageReload = false;
        try {
            // Use Navigation Timing API to detect reload (standard way across all browsers)
            // navigation.type: 0 = normal navigation, 1 = reload (F5/Ctrl+R), 2 = back/forward, 255 = unknown
            if (window.performance && window.performance.navigation) {
                isPageReload = (window.performance.navigation.type === 1);
            }
            
            // Fallback for newer browsers using PerformanceNavigationTiming
            if (!isPageReload && window.performance?.getEntriesByType) {
                const navEntries = window.performance.getEntriesByType('navigation');
                if (navEntries.length > 0) {
                    // If this navigation entry exists, check if it's a reload
                    isPageReload = navEntries[0]?.type === 'reload';
                }
            }
        } catch (e) {
            console.warn('[PageInit] Could not detect page reload:', e);
            isPageReload = false;
        }

        // =====================================================
        // AUTHENTICATED PAGE DATA INITIALIZATION
        // =====================================================
        // This function is called ONLY after user is authenticated
        // It loads all data that requires Firebase auth tokens
        async function initializePageData() {
            
            // Declare cfg at function scope so it's accessible to all steps
            let cfg = null;
            
            // 0) Load shared config from backend (e.g. default weather location)
            try {
                const cfgResp = await authenticatedFetch('/api/config');
                cfg = await cfgResp.json();
                if (cfg.errno === 0 && cfg.result) {
                    // Update USER_TZ from backend-provided config (user-specific or server default)
                    try {
                        USER_TZ = cfg.result.timezone || (cfg.result.config && cfg.result.config.automation && cfg.result.config.automation.timeZone) || USER_TZ;
                    } catch (e) { /* ignore and use default */ }
                    const wInput = document.getElementById('weatherPlace');
                    // Backend now keeps location and preferences.weatherPlace in sync - check location first (primary source)
                    const preferredWeather = cfg.result.location || (cfg.result.preferences && cfg.result.preferences.weatherPlace) || cfg.result.weatherPlace;
                    // On page load, ALWAYS update from server config (it's the source of truth)
                    // Only exception: if user manually typed during this active session
                    if (wInput && preferredWeather && String(preferredWeather).trim() !== '' && preferredWeather !== 'undefined') {
                        const userActivelyTyping = window.sessionStorage.getItem('weatherInputActive') === 'true';
                        
                        if (!userActivelyTyping) {
                            wInput.value = preferredWeather;
                        }
                    }
                    // Keep the visible location display in sync
                    const wDisplay = document.getElementById('weatherPlaceDisplay');
                    if (wDisplay && preferredWeather && preferredWeather !== 'undefined') {
                        wDisplay.textContent = preferredWeather;
                        wDisplay.title = `Fetching weather for: ${preferredWeather}\nThis also sets the timezone for automation rules.\nChange in Settings → Preferences.`;
                    }
                    // Bust weather cache if the configured location changed since the last fetch
                    // (handles navigating back from settings without a full page reload)
                    try {
                        const cachedFull = JSON.parse(localStorage.getItem('cachedWeatherFull') || '{}');
                        const cachedLoc = (cachedFull?.place?.query || cachedFull?.place?.resolvedName || '').trim().toLowerCase();
                        const newLoc = (preferredWeather || '').trim().toLowerCase();
                        if (cachedLoc && newLoc && cachedLoc !== newLoc) {
                            const cs = JSON.parse(localStorage.getItem('cacheState') || '{}');
                            cs.weatherTime = 0;
                            localStorage.setItem('cacheState', JSON.stringify(cs));
                            localStorage.removeItem('cachedWeatherFull');
                            console.log('[Weather] Location changed from', cachedLoc, 'to', newLoc, '— cache cleared');
                        }
                    } catch (e) { /* non-fatal */ }
                    const snInput = document.getElementById('deviceSn');
                    if (snInput && !snInput.value && cfg.result.deviceSn) {
                        snInput.value = cfg.result.deviceSn;
                    }

                    // Apply backend-configured refresh intervals so the UI honors settings
                    try {
                        // Use the new config field from API response which includes user-specific settings
                        
                        if (cfg.result.config) {
                            if (typeof cfg.result.config.cache.amber === 'number') {
                                CONFIG.refresh.amberPricesMs = Number(cfg.result.config.cache.amber);
                                CONFIG.cache.amber = Number(cfg.result.config.cache.amber);
                            }
                            if (typeof cfg.result.config.cache.inverter === 'number') {
                                CONFIG.refresh.inverterMs = Number(cfg.result.config.cache.inverter);
                                CONFIG.cache.inverter = Number(cfg.result.config.cache.inverter);
                            }
                            if (typeof cfg.result.config.cache.weather === 'number') {
                                CONFIG.refresh.weatherMs = Number(cfg.result.config.cache.weather);
                                CONFIG.cache.weather = Number(cfg.result.config.cache.weather);
                            }
                            if (typeof cfg.result.config.automation.intervalMs === 'number') {
                                CONFIG.automation.intervalMs = Number(cfg.result.config.automation.intervalMs);
                            }
                            if (cfg.result.config.defaults) {
                                CONFIG.defaults = cfg.result.config.defaults;
                            }
                        } else {
                            // Fallback to old field names for backward compatibility
                            if (cfg.result.cache && typeof cfg.result.cache.amber === 'number') {
                                CONFIG.refresh.amberPricesMs = Number(cfg.result.cache.amber);
                            }
                            if (cfg.result.cache && typeof cfg.result.cache.inverter === 'number') {
                                CONFIG.refresh.inverterMs = Number(cfg.result.cache.inverter);
                            }
                            if (cfg.result.cache && typeof cfg.result.cache.weather === 'number') {
                                CONFIG.refresh.weatherMs = Number(cfg.result.cache.weather);
                            }
                            if (cfg.result.automation && typeof cfg.result.automation.intervalMs === 'number') {
                                CONFIG.automation.intervalMs = Number(cfg.result.automation.intervalMs);
                            }
                            if (cfg.result.defaults && typeof cfg.result.defaults.cooldownMinutes === 'number') {
                                CONFIG.defaults = cfg.result.defaults;
                            }
                        }
                        // Update FAQ display with actual config values (deferred until page fully loads)
                        setTimeout(() => { if (typeof updateFaqValues === 'function') updateFaqValues(); }, 100);
                    } catch (e) {
                        console.warn('Failed to apply backend refresh config', e);
                    }
                    // Hardware config: read per-user inverter and battery capacity
                    if (typeof cfg.result.inverterCapacityW === 'number' && cfg.result.inverterCapacityW > 0) {
                        _inverterCapacityW = cfg.result.inverterCapacityW;
                    }
                    if (typeof cfg.result.batteryCapacityKWh === 'number' && cfg.result.batteryCapacityKWh > 0) {
                        _batteryCapacityKwh = cfg.result.batteryCapacityKWh;
                    }
                    applyInverterCapacityToUI(_inverterCapacityW);
                }
            } catch (e) { console.warn('Failed to load backend config', e); }
            
            // 1) Load Amber sites / prices (bypass cache if page reload)
            try { loadAmberSites(isPageReload); } catch(e) { console.warn('Failed to load Amber sites:', e); }
            
            // 2) Fetch inverter real-time data immediately (bypass cache if page reload)
            try { callAPI('/api/inverter/real-time', 'Real-time Data', false, isPageReload); } catch(e) { console.warn('Failed to load inverter data:', e); }
            
            // 3) Set up weather request (bypass cache if page reload)
            try {
                // Determine default forecast days from backend preferences or top-level config
                try {
                    const daysEl = document.getElementById('weatherDays');
                    let defaultDays = 6;
                    if (cfg.result) {
                        if (cfg.result.preferences && typeof cfg.result.preferences.forecastDays === 'number') {
                            defaultDays = Number(cfg.result.preferences.forecastDays);
                        } else if (typeof cfg.result.forecastDays === 'number') {
                            defaultDays = Number(cfg.result.forecastDays);
                        }
                    }
                    // Clamp to allowed range
                    defaultDays = Math.max(1, Math.min(16, defaultDays || 6));
                    // Store in CONFIG so getWeather() can access it
                    CONFIG.preferences.forecastDays = defaultDays;
                    if (daysEl) daysEl.value = defaultDays;
                    // If preference changed from what was cached, invalidate cache so fresh data is fetched
                    const cacheState = JSON.parse(localStorage.getItem('cacheState') || '{}');
                    if (cacheState.weatherDays && cacheState.weatherDays !== defaultDays) {
                        cacheState.weatherDays = defaultDays;
                        localStorage.setItem('cacheState', JSON.stringify(cacheState));
                    }
                } catch (e) {
                    console.error('[Weather Init] Exception in setup:', e);
                    try { document.getElementById('weatherDays').value = 6; } catch (ee) {}
                    try { CONFIG.preferences.forecastDays = 6; } catch (eee) {}
                }
                updateWeatherRequestedLabel();
                document.getElementById('weatherDays').addEventListener('input', updateWeatherRequestedLabel);
                getWeather(isPageReload);  // Bypass cache on page reload
            } catch(e) { console.warn('Failed to initialize weather:', e); }
            
            // 4) Load automation rules from localStorage
            try { loadAutomationRules(); } catch (e) { console.error('Error loading automation rules:', e); }
            
            // 5) Load backend automation status
            try { 
                // Initialize curtailment state variable
                window.curtailmentState = { active: false, enabled: false, triggered: false };
                setTimeout(() => { loadBackendAutomationStatus(); }, 300); 
            } catch(e) { console.warn('Failed to load automation status:', e); }
            
            // 6) Load API call metrics
            try { loadApiMetrics(1); } catch(e) { console.warn('Failed to load API metrics:', e); }
            
            // Now allow user-triggered API calls to open the panel
            window.suppressPanelAutoOpen = false;
            
            // ---- Start auto-refresh timers (managed by visibility/idle detection) ----
            try {
                startAutoRefreshTimers();
            } catch (e) { console.warn('Failed to start auto-refresh timers:', e); }
            
            // Start the 'since' ticker
            try {
                updateLastUpdateDisplays();
                if (!lastUpdateTicker) {
                    lastUpdateTicker = setInterval(updateLastUpdateDisplays, 1000);
                }
            } catch(e) { console.error('Update displays failed:', e); }
            
            // Init resizer for automation panel
            try { initAutomationResizer(); } catch(e) { console.error('initAutomationResizer failed:', e); }

            // Reconcile floating toggle visibility after all init paths complete.
            try { syncAutomationToggleVisibility(); } catch (e) {}

            // Allow automated API calls to open the panel
            setTimeout(() => { try { window.suppressPanelAutoOpen = false; } catch(e) {} }, 1200);
        }

        // =====================================================
        // AUTOMATION RULES SYSTEM
        // =====================================================
        
        let automationRules = [];
        let automationEnabled = false;

        function loadAutomationRules() {
            try {
                const saved = localStorage.getItem('automationRules');
                if (saved) {
                    automationRules = JSON.parse(saved);
                }
                const enabledState = localStorage.getItem('automationEnabled');
                automationEnabled = enabledState === 'true';
            } catch (e) {
                console.error('Failed to load automation rules:', e);
                automationRules = [];
            }
            renderRules();
            updateAutomationToggle();
        }

        // Load backend automation status and sync UI
        async function loadBackendAutomationStatus() {
            try {
                const container = document.getElementById('backendAutomationStatus');
                if (!container) {
                    console.error('[Automation] Container backendAutomationStatus not found');
                    return;
                }
                
                // Don't show "Loading..." during refresh - it causes flicker
                // Only show it if the container is completely empty
                if (!container.innerHTML.trim() || container.innerHTML.includes('Failed') || container.innerHTML.includes('Error')) {
                    container.innerHTML = '<div style="color:var(--text-secondary);font-size:12px">Loading automation status...</div>';
                }
                
                const resp = await authenticatedFetch('/api/automation/status');
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const data = await resp.json();
                if (data.errno === 0 && data.result) {
                    updateBackendAutomationUI(data.result);
                } else {
                    container.innerHTML = '<div style="color:var(--color-danger);font-size:12px">⚠️ Failed to load (errno: ' + data.errno + ')</div>';
                }
            } catch (e) {
                console.error('[Automation] Load failed:', e);
                const container = document.getElementById('backendAutomationStatus');
                if (container) {
                    container.innerHTML = `<div style="color:var(--color-danger);font-size:12px">⚠️ Error: ${e.message}</div>`;
                }
            }
        }

        // Update the backend automation section UI
        function updateBackendAutomationUI(status) {
            try {
                const container = document.getElementById('backendAutomationStatus');
                if (!container) {
                    console.error('[Automation] Container not found in updateBackendAutomationUI');
                    return;
                }
                
                const masterEnabled = status.enabled;
                const inBlackout = status.inBlackout || false;
                const blackoutWindow = status.currentBlackoutWindow;
                // Normalize lastCheck (handle Firestore Timestamp shapes and seconds/ms ambiguity)
                let lastCheckRaw = status.lastCheck;
                let lastCheck = Date.now();
                if (lastCheckRaw !== null && lastCheckRaw !== undefined) {
                    if (typeof lastCheckRaw === 'number') {
                        lastCheck = lastCheckRaw > 1e12 ? lastCheckRaw : lastCheckRaw * 1000;
                    } else if (typeof lastCheckRaw === 'object') {
                        const sec = lastCheckRaw._seconds ?? lastCheckRaw.seconds;
                        const nsec = lastCheckRaw._nanoseconds ?? lastCheckRaw.nanos ?? 0;
                        if (typeof sec === 'number') {
                            lastCheck = (sec * 1000) + Math.floor((nsec || 0) / 1e6);
                        } else {
                            const parsed = Number(lastCheckRaw);
                            lastCheck = !isNaN(parsed) ? (parsed > 1e12 ? parsed : parsed * 1000) : Date.now();
                        }
                    } else {
                        const parsed = Number(lastCheckRaw);
                        lastCheck = !isNaN(parsed) ? (parsed > 1e12 ? parsed : parsed * 1000) : Date.now();
                    }
                }
                const automationIntervalSec = CONFIG.automation.intervalMs / 1000;
                const nextCheckIn = Math.max(0, automationIntervalSec - Math.floor((Date.now() - lastCheck) / 1000));
                
                // Determine effective state: blackout overrides master enabled
                const effectivelyPaused = !masterEnabled || inBlackout;
                const statusText = inBlackout ? 'BLACKOUT' : (masterEnabled ? 'ACTIVE' : 'PAUSED');
                const statusColor = inBlackout ? 'var(--color-orange)' : (masterEnabled ? 'var(--color-success)' : 'var(--color-danger)');
                const countdownText = inBlackout ? 'BLACKOUT' : (masterEnabled ? nextCheckIn + 's' : 'PAUSED');
                const subtitleText = inBlackout 
                    ? `⏸️ Blackout window: ${blackoutWindow?.start || '??'} - ${blackoutWindow?.end || '??'}`
                    : (masterEnabled ? `Auto-refreshes every ${automationIntervalSec} seconds` : 'Enable master switch to activate');
                const gradientColors = inBlackout ? '#f0883e 0%, #da3633 100%' : (masterEnabled ? '#1f6feb 0%, #238636 100%' : '#6e7681 0%, #8b949e 100%');
            
            let html = `
                <!-- Unified Countdown Timer + Master Switch -->
                <div style="background:linear-gradient(135deg, ${gradientColors});border-radius:12px;padding:14px 16px;margin-bottom:12px;box-shadow:0 6px 20px rgba(0,0,0,0.4)">
                    <div style="display:flex;align-items:center;justify-content:center;gap:16px">
                        <div style="flex:0 0 auto;text-align:center">
                            <div style="font-size:10px;color:rgba(255,255,255,0.9);font-weight:600;letter-spacing:1px;text-transform:uppercase">${inBlackout ? '🚫 BLACKOUT' : '⏱️ NEXT CYCLE'}</div>
                            <div id="automationCountdown" style="font-size:32px;font-weight:800;color:#fff;font-family:'Courier New',monospace;letter-spacing:3px;text-shadow:0 3px 10px rgba(0,0,0,0.4);margin-top:4px">${countdownText}</div>
                        </div>
                        <div style="width:2px;height:50px;background:rgba(255,255,255,0.25);border-radius:1px"></div>
                        <div style="display:flex;flex-direction:column;align-items:center;gap:6px;min-width:90px">
                            <div style="font-size:12px;color:rgba(255,255,255,0.9);font-weight:600;letter-spacing:0.5px">🤖 Master</div>
                            <div class="automation-toggle ${masterEnabled ? 'active' : ''}" onclick="toggleBackendAutomation()" style="width:48px;height:28px;cursor:pointer;transition:all 0.3s ease"></div>
                            <span style="font-size:11px;font-weight:700;letter-spacing:0.5px;color:#fff;text-transform:uppercase;text-shadow:0 1px 3px rgba(0,0,0,0.3)">${statusText}</span>
                        </div>
                    </div>
                    <div style="font-size:10px;color:rgba(255,255,255,0.75);text-align:center;margin-top:8px;font-weight:500">${subtitleText}</div>
                </div>
                </div>
                <!-- Compact Add Rule button placed under master section for quick access -->
                <div style="display:flex;justify-content:flex-start;gap:8px;margin-bottom:12px">
                    <button class="btn btn-primary btn-sm" onclick="showAddRuleModal()" style="padding:6px 10px;font-size:12px">➕ Add Rule</button>
                </div>
            `;
            
            // Render all automation rules (sorted by priority)
            const allRules = Object.entries(status.rules || {}).sort((a,b) => (a[1].priority || 99) - (b[1].priority || 99));
            if (allRules.length > 0) {
                html += `<div style=\"font-size:12px;font-weight:600;color:var(--accent-blue);margin-bottom:8px\">📋 Automation Rules (${allRules.length})</div>`;
                html += `<div style="font-size:10px;color:var(--text-secondary);margin-bottom:8px;padding:6px 8px;background:var(--accent-blue-bg);border-radius:4px;border-left:2px solid var(--accent-blue)">Sorted by priority • Lower number = Higher priority • First match wins</div>`;
                allRules.forEach(([ruleName, rule]) => {
                    const ruleAction = rule.action || {};
                    const conditions = rule.conditions || {};
                    
                    // Build conditions badges
                    let condBadges = '';
                    if (conditions.feedInPrice?.enabled) condBadges += `<span style="background:#238636;color:#fff;padding:2px 6px;border-radius:3px;font-size:10px;margin-right:4px">Feed-in ${conditions.feedInPrice.operator} ${conditions.feedInPrice.value}¢</span>`;
                    if (conditions.buyPrice?.enabled) condBadges += `<span style="background:#1f6feb;color:#fff;padding:2px 6px;border-radius:3px;font-size:10px;margin-right:4px">Buy ${conditions.buyPrice.operator} ${conditions.buyPrice.value}¢</span>`;
                    if (conditions.soc?.enabled) condBadges += `<span style="background:#8957e5;color:#fff;padding:2px 6px;border-radius:3px;font-size:10px;margin-right:4px">SoC ${conditions.soc.operator} ${conditions.soc.value}%</span>`;
                    const tempCond = conditions.temperature || conditions.temp;
                    if (tempCond?.enabled) condBadges += `<span style="background:#f0883e;color:#000;padding:2px 6px;border-radius:3px;font-size:10px;margin-right:4px">${tempCond.type || 'Bat'} Temp ${tempCond.operator} ${tempCond.value}°C</span>`;
                    // Solar Radiation condition
                    if (conditions.solarRadiation?.enabled) {
                        const unit = conditions.solarRadiation.lookAheadUnit || 'hours';
                        const unitLabel = unit === 'hours' ? 'h' : 'd';
                        condBadges += `<span style="background:#f9d71c;color:#000;padding:2px 6px;border-radius:3px;font-size:10px;margin-right:4px">☀️ ${conditions.solarRadiation.checkType || 'avg'} ${conditions.solarRadiation.operator} ${conditions.solarRadiation.value}W/m² (${conditions.solarRadiation.lookAhead}${unitLabel})</span>`;
                    }
                    // Cloud Cover condition
                    if (conditions.cloudCover?.enabled) {
                        const unit = conditions.cloudCover.lookAheadUnit || 'hours';
                        const unitLabel = unit === 'hours' ? 'h' : 'd';
                        condBadges += `<span style="background:#79c0ff;color:#000;padding:2px 6px;border-radius:3px;font-size:10px;margin-right:4px">☁️ ${conditions.cloudCover.checkType || 'avg'} ${conditions.cloudCover.operator} ${conditions.cloudCover.value}% (${conditions.cloudCover.lookAhead}${unitLabel})</span>`;
                    }
                    // Legacy weather condition (for backward compatibility)
                    if (conditions.weather?.enabled) {
                        const wType = conditions.weather.type || conditions.weather.condition || 'sunny';
                        condBadges += `<span style="background:#79c0ff;color:#000;padding:2px 6px;border-radius:3px;font-size:10px;margin-right:4px">🌤️ ${wType}</span>`;
                    }
                    if (conditions.forecastPrice?.enabled) {
                        const unit = conditions.forecastPrice.lookAheadUnit || 'minutes';
                        const unitLabel = unit === 'minutes' ? 'm' : unit === 'hours' ? 'h' : 'd';
                        condBadges += `<span style="background:#f778ba;color:#000;padding:2px 6px;border-radius:3px;font-size:10px;margin-right:4px">📈 ${conditions.forecastPrice.type === 'feedIn' ? 'FI' : 'Buy'} ${conditions.forecastPrice.checkType || 'avg'} ${conditions.forecastPrice.operator} ${conditions.forecastPrice.value}¢ (${conditions.forecastPrice.lookAhead || 30}${unitLabel})</span>`;
                    }
                    if (conditions.time?.enabled || conditions.timeWindow?.enabled) {
                        const tw = conditions.time || conditions.timeWindow;
                        condBadges += `<span style="background:#6e7681;color:#fff;padding:2px 6px;border-radius:3px;font-size:10px;margin-right:4px">${tw.start || tw.startTime}-${tw.end || tw.endTime}</span>`;
                    }
                    if (!condBadges) condBadges = '<span style="color:var(--text-secondary);font-size:10px">No conditions set</span>';
                    
                    const priorityClass = rule.priority >= 1 && rule.priority <= 10 ? `p${rule.priority}` : 'p-low';
                    const isActive = status.activeRule === ruleName;
                    const segmentStatus = isActive && status.activeSegmentEnabled ? '✓' : (isActive && !status.activeSegmentEnabled ? '⚠️' : '');
                    const segmentStatusTitle = isActive && !status.activeSegmentEnabled ? 'Segment pending or failed to send to inverter' : '';
                    html += `
                    <div style="background:${isActive ? (status.activeSegmentEnabled ? 'rgba(126,231,135,0.1)' : 'rgba(240,136,62,0.1)') : 'var(--bg-card)'};border:1px solid ${isActive ? (status.activeSegmentEnabled ? 'var(--color-success)' : 'var(--color-orange)') : (rule.enabled && masterEnabled ? 'var(--accent-blue)' : 'var(--border-primary)')};border-radius:8px;padding:12px;margin-bottom:8px;opacity:${masterEnabled ? 1 : 0.6};border-left:${isActive ? (status.activeSegmentEnabled ? '3px solid var(--color-success)' : '3px solid var(--color-orange)') : '1px solid ' + (rule.enabled && masterEnabled ? 'var(--accent-blue)' : 'var(--border-primary)')}">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                            <div style="display:flex;align-items:center;gap:8px">
                                <span class="priority-badge ${priorityClass}" title="Priority ${rule.priority || '?'} - Lower number = Higher priority">P${rule.priority || '?'}</span>
                                <span style="font-weight:600;color:${isActive ? (status.activeSegmentEnabled ? 'var(--color-success)' : 'var(--color-orange)') : 'var(--accent-blue)'};font-size:14px">${rule.name || ruleName}</span>
                                ${isActive ? `<span style="background:${status.activeSegmentEnabled ? 'var(--color-success)' : 'var(--color-orange)'};color:#000;padding:2px 6px;border-radius:4px;font-size:10px;font-weight:700;title='${segmentStatusTitle}'">${status.activeSegmentEnabled ? '✅ ACTIVE' : '⚠️ PENDING'}</span>` : ''}
                            </div>
                            <div style="display:flex;align-items:center;gap:6px">
                                <label style="display:flex;align-items:center;gap:4px;cursor:pointer">
                                    <input type="checkbox" ${rule.enabled ? 'checked' : ''} onchange="updateBackendRule('${ruleName}', 'enabled', this.checked)" style="accent-color:var(--accent-blue);width:14px;height:14px">
                                    <span style="font-size:11px;font-weight:600;color:${rule.enabled ? 'var(--accent-blue)' : 'var(--text-secondary)'}">${rule.enabled ? 'ON' : 'OFF'}</span>
                                </label>
                                <button onclick="editBackendRule('${ruleName}')" style="background:color-mix(in srgb, var(--accent-blue) 15%, transparent);border:1px solid var(--accent-blue);color:var(--accent-blue);padding:3px 6px;border-radius:4px;cursor:pointer;font-size:10px" title="Edit">✏️</button>
                                <button onclick="deleteBackendRule('${ruleName}')" style="background:color-mix(in srgb, var(--color-danger) 15%, transparent);border:1px solid var(--color-danger);color:var(--color-danger);padding:3px 6px;border-radius:4px;cursor:pointer;font-size:10px" title="Delete">🗑️</button>
                            </div>
                        </div>
                        <div style="margin-bottom:8px">${condBadges}</div>
                        <div style="display:flex;gap:8px;font-size:11px;flex-wrap:wrap">
                            <div style="background:var(--bg-secondary);padding:4px 8px;border-radius:4px">
                                <span style="color:var(--text-secondary)">→</span> <span style="color:var(--color-success)">${ruleAction.workMode || 'N/A'}</span>
                            </div>
                            <div style="background:var(--bg-secondary);padding:4px 8px;border-radius:4px">
                                <span style="color:var(--text-secondary)">⏱</span> <span style="color:var(--text-primary)">${ruleAction.durationMinutes || 0}min</span>
                            </div>
                            <div style="background:var(--bg-secondary);padding:4px 8px;border-radius:4px">
                                <span style="color:var(--text-secondary)">⚡</span> <span style="color:var(--text-primary)">${ruleAction.fdPwr || 0}W</span>
                            </div>
                            <div style="background:var(--bg-secondary);padding:4px 8px;border-radius:4px">
                                <span style="color:var(--text-secondary)">🔄</span> <span style="color:var(--text-primary)">${rule.cooldownMinutes || 5}min CD</span>
                            </div>
                        </div>
                        ${rule.lastTriggered ? `<div style="margin-top:8px;font-size:10px;color:var(--color-orange)">⏱️ Last: ${formatDate(rule.lastTriggered, true)}</div>` : ''}
                    </div>
                    `;
                });
            } else {
                // No rules yet - show empty state
                html += `
                    <div style="padding:20px;background:var(--bg-secondary);border-radius:8px;text-align:center;margin-bottom:8px">
                        <div style="font-size:32px;margin-bottom:12px">📭</div>
                        <div style="font-size:14px;color:var(--text-secondary);margin-bottom:8px">No automation rules yet</div>
                        <div style="font-size:12px;color:var(--text-muted)">Click the button below to create your first rule</div>
                    </div>
                `;
            }
            
            // Small placeholder to keep layout/anchors stable (hidden)
            html += `<div class="add-rule-card" style="display:none"></div>`;
            
            // Test Link
            html += `
                <div style="margin-top:16px;text-align:center">
                    <a href="/test.html" target="_blank" style="color:var(--accent-blue);font-size:12px;text-decoration:none">🧪 Open Automation Test UI →</a>
                </div>
            `;
            
            // Last triggered info
            if (status.lastTriggered) {
                html += `
                    <div style="margin-top:12px;padding:8px;background:var(--bg-secondary);border-radius:6px;font-size:11px;color:var(--text-secondary);text-align:center">
                        Last automation: ${formatDate(status.lastTriggered, true)} (${status.activeRuleName || status.activeRule || 'unknown'})
                    </div>
                `;
            }
            
            // Curtailment status indicator (if active)
            if (window.curtailmentState && window.curtailmentState.active) {
                html += `
                    <div style="margin-top:12px;padding:10px;background:linear-gradient(135deg,#f0883e 0%,#da3633 100%);border-radius:6px;border-left:3px solid #ff6b35">
                        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px">
                            <div style="display:flex;align-items:center;gap:6px;flex:1">
                                <span style="font-size:14px">☀️</span>
                                <div style="flex:1">
                                    <div style="font-weight:600;color:#fff;font-size:11px">Solar Curtailment Active</div>
                                    <div style="font-size:10px;color:rgba(255,255,255,0.85);margin-top:2px">${window.curtailmentState.currentPrice ? (window.curtailmentState.currentPrice.toFixed(2) + '¢ < ' + window.curtailmentState.priceThreshold + '¢') : 'Price below threshold'}</div>
                                </div>
                            </div>
                            <div style="font-size:11px;color:#fff;font-weight:700;background:rgba(0,0,0,0.3);padding:4px 8px;border-radius:3px;white-space:nowrap">Export: 0W</div>
                        </div>
                    </div>
                `;
            }
            
            // Debug Info Box - shows last cycle outcome
            const debugTimestamp = status.lastCheck ? formatDate(status.lastCheck, true, false, status.userTimezone) : 'N/A';
            const tzLabel = status.userTimezone ? ` (${status.userTimezone})` : '';
            html += `
                <div id="automationDebugBox" style="margin-top:12px;padding:8px 10px;background:var(--bg-input);border:1px solid var(--border-primary);border-radius:6px;box-shadow:0 1px 4px rgba(0,0,0,0.1)">
                    <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap">
                        <span style="color:var(--accent-blue);font-weight:600;font-size:11px;white-space:nowrap">📊 Last Cycle</span>
                        <div id="debugContent" style="color:var(--text-primary);font-size:11px;flex:1;min-width:250px;display:flex;justify-content:space-between;align-items:flex-start;gap:8px">
                            <div style="flex:1">${window.lastCycleResult ? formatCycleResult(window.lastCycleResult) : '<span style="color:var(--text-muted);font-size:10px">⏳ Waiting...</span>'}</div>
                            <div id="debugTimestamp" style="color:var(--text-muted);font-size:11px;white-space:nowrap;background:var(--bg-primary);padding:2px 6px;border-radius:3px;margin-left:6px" title="User timezone: ${status.userTimezone || 'unknown'}">${debugTimestamp}${tzLabel}</div>
                        </div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
            
            // Update solar tile curtailment indicator with current state
            updateSolarTileCurtailmentIndicator();
            
            // Store lastCheck, enabled state, and blackout info for countdown timer
            // Normalize lastCheck: Firestore may return a Timestamp object or seconds-only value.
            (function(){
                const raw = status.lastCheck;
                let lastMs = Date.now();
                if (raw !== null && raw !== undefined) {
                    if (typeof raw === 'number') {
                        // If small number, treat as seconds, otherwise milliseconds
                        lastMs = raw > 1e12 ? raw : raw * 1000;
                    } else if (typeof raw === 'object') {
                        // Firestore Timestamp shape: {_seconds, _nanoseconds} or {seconds, nanos}
                        const sec = raw._seconds ?? raw.seconds;
                        const nsec = raw._nanoseconds ?? raw.nanos ?? 0;
                        if (typeof sec === 'number') {
                            lastMs = (sec * 1000) + Math.floor((nsec || 0) / 1e6);
                        } else {
                            const parsed = Number(raw);
                            lastMs = !isNaN(parsed) ? (parsed > 1e12 ? parsed : parsed * 1000) : Date.now();
                        }
                    } else {
                        const parsed = Number(raw);
                        lastMs = !isNaN(parsed) ? (parsed > 1e12 ? parsed : parsed * 1000) : Date.now();
                    }
                }
                window.automationLastCheck = lastMs;
            })();
            window.automationEnabled = !!status.enabled;
            window.automationInBlackout = !!status.inBlackout;
            
            // Start countdown timer if not already running (or restart if state changed)
            const shouldRun = window.automationEnabled && !window.automationInBlackout;
            const wasRunning = !!window.automationCountdownInterval;
            const stateChanged = (shouldRun !== wasRunning) || !window.automationCountdownStarted;
            
            if (stateChanged) {
                if (window.automationCountdownInterval) {
                    clearInterval(window.automationCountdownInterval);
                    window.automationCountdownInterval = null;
                }
                
                if (shouldRun) {
                    // Initialize lastCheck if not set
                    if (!window.automationLastCheck) {
                        window.automationLastCheck = Date.now();
                    }
                    window.automationCountdownStarted = true;
                    
                    window.automationCountdownInterval = setInterval(() => {
                        const countdownEl = document.getElementById('automationCountdown');
                        if (!countdownEl) {
                            clearInterval(window.automationCountdownInterval);
                            window.automationCountdownInterval = null;
                            return;
                        }
                        // If we're now in blackout, stop countdown immediately
                        if (window.automationInBlackout) {
                            countdownEl.textContent = 'BLACKOUT';
                            // Stop the automation cycle from being triggered
                            return;
                        }
                        const elapsed = Math.floor((Date.now() - window.automationLastCheck) / 1000);
                        const intervalSec = CONFIG.automation.intervalMs / 1000;
                        const remaining = Math.max(0, intervalSec - elapsed);
                        countdownEl.textContent = remaining + 's';
                        // Only trigger cycle if: automation is enabled, not in blackout, and timer reached 0
                        if (remaining === 0 && window.automationEnabled && !window.automationInBlackout && !window.automationCycleRunning) {
                            // Run the actual automation cycle on the backend
                            runAutomationCycle();
                        }
                    }, CONFIG.automation.countdownUpdateMs);
                } else {
                    window.automationCountdownStarted = false;
                    // Keep PAUSED or BLACKOUT visible
                    const countdownEl = document.getElementById('automationCountdown');
                    if (countdownEl) countdownEl.textContent = window.automationInBlackout ? 'BLACKOUT' : 'PAUSED';
                }
            }
            } catch (e) {
                console.error('[Automation] updateBackendAutomationUI failed:', e);
                const container = document.getElementById('backendAutomationStatus');
                if (container) {
                    container.innerHTML = '<div style="color:var(--color-danger);font-size:12px">⚠️ UI Error: ' + e.message + '</div>';
                }
            }
        }
        
        // Run the automation cycle - called by the countdown timer when it hits 0
        async function runAutomationCycle() {
            // Prevent multiple simultaneous calls
            if (window.automationCycleRunning) {
                console.log('[Automation] Cycle already running, skipping');
                return;
            }
            window.automationCycleRunning = true;
            
            // Immediately update lastCheck to reset the countdown
            window.automationLastCheck = Date.now();
            
            const countdownEl = document.getElementById('automationCountdown');
            if (countdownEl) countdownEl.textContent = '⏳';
            
            try {
                const resp = await authenticatedFetch('/api/automation/cycle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                const data = await resp.json();
                
                if (data.errno === 0) {
                    
                    // Store cycle result for debug display
                    window.lastCycleResult = data.result;
                    
                    // Handle curtailment feedback
                    if (data.result?.curtailment) {
                        const curtailment = data.result.curtailment;
                        // Store curtailment state for display in info box
                        window.curtailmentState = {
                            active: curtailment.enabled && curtailment.triggered,
                            enabled: curtailment.enabled,
                            triggered: curtailment.triggered,
                            currentPrice: curtailment.currentPrice,
                            priceThreshold: curtailment.priceThreshold
                        };
                        // Update solar tile curtailment indicator
                        updateSolarTileCurtailmentIndicator();
                        if (curtailment.error) {
                            showMessage('warning', `☀️ Curtailment error: ${curtailment.error}`, 5000);
                        } else if (curtailment.stateChanged) {
                            if (curtailment.action === 'activated') {
                                showMessage('info', `☀️ Solar curtailment activated (price ${curtailment.currentPrice.toFixed(2)}¢ < ${curtailment.priceThreshold}¢)`, 5000);
                            } else if (curtailment.action === 'deactivated') {
                                showMessage('success', `☀️ Solar curtailment deactivated (price ${curtailment.currentPrice.toFixed(2)}¢ >= ${curtailment.priceThreshold}¢)`, 5000);
                            }
                        }
                    }
                    
                    // Immediately update debug box if visible
                    const debugContent = document.getElementById('debugContent');
                    const debugTimestamp = document.getElementById('debugTimestamp');
                    if (debugContent) {
                        debugContent.innerHTML = formatCycleResult(data.result);
                    }
                    if (debugTimestamp) {
                        debugTimestamp.textContent = formatDate(Date.now(), true, true);
                    }
                    
                    // If a rule was triggered, show a notification
                    if (data.result?.triggered && data.result?.rule) {
                        const ruleName = data.result.rule.name || 'Unknown';
                        if (data.result.status === 'new_trigger') {
                            showMessage('success', `🤖 Automation triggered: ${ruleName}`, 5000);
                        } else if (data.result.status === 'continuing') {
                            // Check if there are cooldown rules in evaluationResults
                            const cooldownRules = (data.result.evaluationResults || []).filter(er => er.result === 'cooldown');
                            if (cooldownRules.length > 0) {
                                const cooldownNames = cooldownRules.map(cr => cr.rule).join(', ');
                                showMessage('info', `⏱️ ${ruleName} continuing (${cooldownNames} in cooldown)`, 4000);
                            } else {
                                showMessage('info', `✓ ${ruleName} continuing`, 3000);
                            }
                        }
                    } else if (data.result?.skipped) {
                    } else {
                    }
                    
                    // ALWAYS refresh automation status after cycle to show current state (active rule, etc.)
                    let triggeredRuleName = null;
                    try {
                        const statusResp = await authenticatedFetch('/api/automation/status');
                        const statusData = await statusResp.json();
                        if (statusData.errno === 0) {
                            window.automationStatus = statusData.result;
                            // If a rule was triggered, ensure its lastTriggered is set to now
                            if (data.result?.triggered && data.result?.rule) {
                                triggeredRuleName = data.result.rule.name || 'Unknown';
                                for (const [name, rule] of Object.entries(statusData.result.rules || {})) {
                                    if (name === triggeredRuleName) {
                                        rule.lastTriggered = Date.now();
                                        break;
                                    }
                                }
                            }
                            updateBackendAutomationUI(statusData.result);
                        }
                    } catch (statusErr) {
                        console.warn('[Automation] Failed to refresh status:', statusErr);
                    }
                    
                    // Update lastCheck from server response (ensures sync)
                    if (data.result?.lastCheck) {
                        window.automationLastCheck = data.result.lastCheck;
                    }
                } else {
                    console.warn('[Automation] Cycle error:', data.error);
                    showMessage('warning', `Automation cycle error: ${data.error}`, 5000);
                }
            } catch (e) {
                console.error('[Automation] Cycle failed:', e);
                showMessage('error', `Automation cycle failed: ${e.message}`, 5000);
            } finally {
                window.automationCycleRunning = false;
                // Reset countdown display
                if (countdownEl) {
                    const intervalSec = CONFIG.automation.intervalMs / 1000;
                    countdownEl.textContent = intervalSec + 's';
                }
            }
        }
        
        // Show modal to add a new automation rule
        function showAddRuleModal() {
            const modalHtml = `
                <div id="addRuleModal" style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:12000">
                    <div style="background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:12px;padding:24px;width:95%;max-width:840px;max-height:90vh;overflow-y:auto">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px">
                            <h3 style="margin:0;font-size:18px;color:var(--text-primary)">➕ Create New Automation Rule</h3>
                            <button onclick="closeAddRuleModal()" style="background:none;border:none;color:var(--text-secondary);font-size:20px;cursor:pointer">✕</button>
                        </div>
                        
                        <!-- Basic Info -->
                        <input type="hidden" id="newRuleId" value="">
                        <input type="hidden" id="editingRuleId" value="">
                        <div style="display:grid;grid-template-columns:2fr 1fr;gap:12px;margin-bottom:16px;align-items:end">
                            <div>
                                <label style="display:block;font-size:12px;color:var(--text-secondary);margin-bottom:4px">Rule Name</label>
                                <input type="text" id="newRuleName" placeholder="e.g., Low Buy Cost Charge" style="width:100%;padding:8px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:6px;color:var(--text-primary);font-size:13px">
                            </div>
                            <div>
                                <label style="display:block;font-size:12px;color:var(--text-secondary);margin-bottom:4px">Priority (1=highest)</label>
                                <input type="number" id="newRulePriority" value="5" min="1" max="99" style="width:100%;padding:8px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:6px;color:var(--text-primary);font-size:13px">
                            </div>
                        </div>
                        
                        <!-- Rule Status Toggle -->
                        <div style="display:flex;align-items:center;gap:8px;padding:10px;background:var(--bg-secondary);border-radius:6px;margin-bottom:16px">
                            <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin:0">
                                <input type="checkbox" id="newRuleEnabled" checked style="width:16px;height:16px">
                                <span style="color:var(--text-primary);font-size:13px;font-weight:500">🟢 Rule Enabled</span>
                            </label>
                            <span style="color:var(--text-secondary);font-size:11px;margin-left:auto">Disable to pause this rule temporarily</span>
                        </div>
                        
                        <!-- CONDITIONS SECTION -->
                        <div style="background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:8px;padding:16px;margin-bottom:16px">
                            <h4 style="margin:0 0 12px 0;font-size:14px;color:var(--accent-blue)">📋 Conditions (ALL must be true)</h4>
                            
                            <!-- Feed-in Price -->
                            <div style="display:flex;align-items:center;gap:12px;padding:10px;background:var(--bg-secondary);border-radius:6px;margin-bottom:8px">
                                <label style="display:flex;align-items:center;gap:6px;min-width:160px;cursor:pointer">
                                    <input type="checkbox" id="condFeedInEnabled" style="width:16px;height:16px">
                                    <span style="color:var(--text-primary);font-size:13px">💰 Feed-in Price</span>
                                </label>
                                <select id="condFeedInOp" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                    <option value=">">&gt;</option>
                                    <option value=">=">&gt;=</option>
                                    <option value="<">&lt;</option>
                                    <option value="<=">&lt;=</option>
                                    <option value="between">between</option>
                                </select>
                                <input type="number" id="condFeedInVal" placeholder="¢/kWh" value="20" min="-100" max="500" step="0.1" style="width:80px;padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                <span id="condFeedInVal2Wrap" style="display:none;color:var(--text-secondary);font-size:12px">and <input type="number" id="condFeedInVal2" value="50" min="-100" max="500" step="0.1" style="width:60px;padding:4px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px"></span>
                                <span style="color:var(--text-secondary);font-size:11px">¢/kWh</span>
                            </div>
                            
                            <!-- Buy Price -->
                            <div style="display:flex;align-items:center;gap:12px;padding:10px;background:var(--bg-secondary);border-radius:6px;margin-bottom:8px">
                                <label style="display:flex;align-items:center;gap:6px;min-width:160px;cursor:pointer">
                                    <input type="checkbox" id="condBuyEnabled" style="width:16px;height:16px">
                                    <span style="color:var(--text-primary);font-size:13px">🛒 Buy Price</span>
                                </label>
                                <select id="condBuyOp" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                    <option value="<">&lt;</option>
                                    <option value="<=">&lt;=</option>
                                    <option value=">">&gt;</option>
                                    <option value=">=">&gt;=</option>
                                    <option value="between">between</option>
                                </select>
                                <input type="number" id="condBuyVal" placeholder="¢/kWh" value="10" min="-100" max="500" step="0.1" style="width:80px;padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                <span id="condBuyVal2Wrap" style="display:none;color:var(--text-secondary);font-size:12px">and <input type="number" id="condBuyVal2" value="20" min="-100" max="500" step="0.1" style="width:60px;padding:4px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px"></span>
                                <span style="color:var(--text-secondary);font-size:11px">¢/kWh</span>
                            </div>
                            
                            <!-- Battery SoC -->
                            <div style="display:flex;align-items:center;gap:12px;padding:10px;background:var(--bg-secondary);border-radius:6px;margin-bottom:8px">
                                <label style="display:flex;align-items:center;gap:6px;min-width:160px;cursor:pointer">
                                    <input type="checkbox" id="condSocEnabled" style="width:16px;height:16px">
                                    <span style="color:var(--text-primary);font-size:13px">🔋 Battery SoC</span>
                                </label>
                                <select id="condSocOp" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                    <option value=">">&gt;</option>
                                    <option value=">=">&gt;=</option>
                                    <option value="<">&lt;</option>
                                    <option value="<=">&lt;=</option>
                                    <option value="between">between</option>
                                </select>
                                <input type="number" id="condSocVal" placeholder="%" value="80" min="0" max="100" style="width:80px;padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                <span id="condSocVal2Wrap" style="display:none;color:var(--text-secondary);font-size:12px">and <input type="number" id="condSocVal2" value="100" min="0" max="100" style="width:60px;padding:4px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px"></span>
                                <span style="color:var(--text-secondary);font-size:11px">%</span>
                            </div>
                            
                            <!-- Temperature -->
                            <div style="display:flex;align-items:center;gap:12px;padding:10px;background:var(--bg-secondary);border-radius:6px;margin-bottom:8px">
                                <label style="display:flex;align-items:center;gap:6px;min-width:160px;cursor:pointer">
                                    <input type="checkbox" id="condTempEnabled" style="width:16px;height:16px">
                                    <span style="color:var(--text-primary);font-size:13px">🌡️ Temperature</span>
                                </label>
                                <select id="condTempType" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                    <option value="battery">Battery</option>
                                    <option value="ambient">Ambient</option>
                                    <option value="inverter">Inverter</option>
                                </select>
                                <select id="condTempOp" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                    <option value="<">&lt;</option>
                                    <option value="<=">&lt;=</option>
                                    <option value=">">&gt;</option>
                                    <option value=">=">&gt;=</option>
                                </select>
                                <input type="number" id="condTempVal" placeholder="°C" value="40" min="-40" max="80" step="1" style="width:70px;padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                <span style="color:var(--text-secondary);font-size:11px">°C</span>
                            </div>
                            
                            <!-- Solar Radiation Forecast -->
                            <div style="display:flex;align-items:center;gap:12px;padding:10px;background:var(--bg-secondary);border-radius:6px;margin-bottom:8px;flex-wrap:wrap">
                                <label style="display:flex;align-items:center;gap:6px;min-width:160px;cursor:pointer">
                                    <input type="checkbox" id="condSolarEnabled" style="width:16px;height:16px">
                                    <span style="color:var(--text-primary);font-size:13px">☀️ Solar Radiation</span>
                                </label>
                                <select id="condSolarCheck" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                    <option value="average">Avg</option>
                                    <option value="min">Min</option>
                                    <option value="max">Max</option>
                                </select>
                                <select id="condSolarOp" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                    <option value=">">&gt;</option>
                                    <option value=">=">&gt;=</option>
                                    <option value="<">&lt;</option>
                                    <option value="<=">&lt;=</option>
                                </select>
                                <input type="number" id="condSolarVal" placeholder="W/m²" value="300" min="0" max="1500" step="10" style="width:70px;padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                <span style="color:var(--text-secondary);font-size:11px">W/m² in next</span>
                                <input type="number" id="condSolarLookAhead" value="6" min="1" max="168" style="width:50px;padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                <select id="condSolarLookAheadUnit" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                    <option value="hours" selected>hrs</option>
                                    <option value="days">days</option>
                                </select>
                            </div>
                            
                            <!-- Cloud Cover Forecast -->
                            <div style="display:flex;align-items:center;gap:12px;padding:10px;background:var(--bg-secondary);border-radius:6px;margin-bottom:8px;flex-wrap:wrap">
                                <label style="display:flex;align-items:center;gap:6px;min-width:160px;cursor:pointer">
                                    <input type="checkbox" id="condCloudEnabled" style="width:16px;height:16px">
                                    <span style="color:var(--text-primary);font-size:13px">☁️ Cloud Cover</span>
                                </label>
                                <select id="condCloudCheck" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                    <option value="average">Avg</option>
                                    <option value="min">Min</option>
                                    <option value="max">Max</option>
                                </select>
                                <select id="condCloudOp" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                    <option value="<">&lt;</option>
                                    <option value="<=">&lt;=</option>
                                    <option value=">">&gt;</option>
                                    <option value=">=">&gt;=</option>
                                </select>
                                <input type="number" id="condCloudVal" placeholder="%" value="50" min="0" max="100" style="width:60px;padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                <span style="color:var(--text-secondary);font-size:11px">% in next</span>
                                <input type="number" id="condCloudLookAhead" value="6" min="1" max="168" style="width:50px;padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                <select id="condCloudLookAheadUnit" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                    <option value="hours" selected>hrs</option>
                                    <option value="days">days</option>
                                </select>
                            </div>
                            
                            <!-- Forecast Price -->
                            <div style="display:flex;align-items:center;gap:12px;padding:10px;background:var(--bg-secondary);border-radius:6px;margin-bottom:8px;flex-wrap:wrap">
                                <label style="display:flex;align-items:center;gap:6px;min-width:160px;cursor:pointer">
                                    <input type="checkbox" id="condForecastEnabled" style="width:16px;height:16px">
                                    <span style="color:var(--text-primary);font-size:13px">📈 Forecast Price</span>
                                </label>
                                <select id="condForecastType" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                    <option value="feedIn">Feed-in</option>
                                    <option value="general">Buy</option>
                                </select>
                                <select id="condForecastCheck" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                    <option value="average">Avg</option>
                                    <option value="min">Min</option>
                                    <option value="max">Max</option>
                                    <option value="any">Any</option>
                                </select>
                                <select id="condForecastOp" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                    <option value=">">&gt;</option>
                                    <option value=">=">&gt;=</option>
                                    <option value="<">&lt;</option>
                                    <option value="<=">&lt;=</option>
                                </select>
                                <input type="number" id="condForecastVal" placeholder="¢" value="30" min="-100" max="500" step="0.1" style="width:60px;padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                <span style="color:var(--text-secondary);font-size:11px">¢ in next</span>
                                <input type="number" id="condForecastLookAhead" value="1" min="1" max="24" style="width:50px;padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                <select id="condForecastLookAheadUnit" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px" onchange="updateForecastLookAheadRange()">
                                    <option value="hours" selected>hrs</option>
                                    <option value="days">days</option>
                                </select>
                            </div>
                            
                            <!-- Time Window -->
                            <div style="display:flex;align-items:center;gap:12px;padding:10px;background:var(--bg-secondary);border-radius:6px">
                                <label style="display:flex;align-items:center;gap:6px;min-width:160px;cursor:pointer">
                                    <input type="checkbox" id="condTimeEnabled" style="width:16px;height:16px">
                                    <span style="color:var(--text-primary);font-size:13px">🕐 Time Window</span>
                                </label>
                                <input type="time" id="condTimeStart" value="06:00" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                                <span style="color:var(--text-secondary);font-size:12px">to</span>
                                <input type="time" id="condTimeEnd" value="18:00" style="padding:6px;background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:4px;color:var(--text-primary);font-size:12px">
                            </div>
                        </div>
                        
                        <!-- ACTION SECTION -->
                        <div style="background:var(--bg-primary);border:1px solid var(--border-primary);border-radius:8px;padding:16px;margin-bottom:16px">
                            <h4 style="margin:0 0 12px 0;font-size:14px;color:var(--color-success-dark)">⚡ Action (when conditions met)</h4>
                            
                            <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-bottom:12px">
                                <div>
                                    <div class="field-label-with-tooltip">
                                        <label style="display:block;font-size:11px;color:var(--text-secondary)">Work Mode</label>
                                        <span class="tooltip-icon" data-tooltip="Action type: Discharge, Charge, SelfUse, etc.">?</span>
                                    </div>
                                    <select id="newRuleWorkMode" style="width:100%;padding:8px;background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;color:var(--text-primary);font-size:13px;margin-top:4px">
                                        <option value="ForceDischarge">Force Discharge</option>
                                        <option value="ForceCharge">Force Charge</option>
                                        <option value="SelfUse">Self Use</option>
                                        <option value="Feedin">Feed In</option>
                                        <option value="Backup">Backup</option>
                                    </select>
                                </div>
                                <div>
                                    <div class="field-label-with-tooltip">
                                        <label style="display:block;font-size:11px;color:var(--text-secondary)">Duration (min)</label>
                                        <span class="tooltip-icon" data-tooltip="How long the segment runs">?</span>
                                    </div>
                                    <input type="number" id="newRuleDuration" value="30" min="5" max="120" style="width:100%;padding:8px;background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;color:var(--text-primary);font-size:13px;margin-top:4px">
                                </div>
                                <div>
                                    <div class="field-label-with-tooltip">
                                        <label style="display:block;font-size:11px;color:var(--text-secondary)">Cooldown (min)</label>
                                        <span class="tooltip-icon" data-tooltip="Min wait before rule can trigger again">?</span>
                                    </div>
                                    <input type="number" id="newRuleCooldown" value="5" min="1" max="60" style="width:100%;padding:8px;background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;color:var(--text-primary);font-size:13px;margin-top:4px">
                                </div>
                            </div>
                            
                            <div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:12px">
                                <div>
                                    <div class="field-label-with-tooltip">
                                        <label style="display:block;font-size:11px;color:var(--text-secondary)">Power (W)</label>
                                        <span class="tooltip-icon" data-tooltip="Charge/discharge rate in watts">?</span>
                                    </div>
                                    <input type="number" id="newRuleFdPwr" value="5000" min="0" max="10500" step="100" style="width:100%;padding:8px;background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;color:var(--text-primary);font-size:13px;margin-top:4px">
                                </div>
                                <div>
                                    <div class="field-label-with-tooltip">
                                        <label style="display:block;font-size:11px;color:var(--text-secondary)">Stop SoC (%)</label>
                                        <span class="tooltip-icon" data-tooltip="SoC where this action stops">?</span>
                                    </div>
                                    <input type="number" id="newRuleFdSoc" value="35" min="10" max="100" style="width:100%;padding:8px;background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;color:var(--text-primary);font-size:13px;margin-top:4px">
                                </div>
                                <div>
                                    <div class="field-label-with-tooltip">
                                        <label style="display:block;font-size:11px;color:var(--text-secondary)">Min SoC (Grid)</label>
                                        <span class="tooltip-icon" data-tooltip="Don't draw from grid below this SoC">?</span>
                                    </div>
                                    <input type="number" id="newRuleMinSoc" value="20" min="10" max="100" style="width:100%;padding:8px;background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;color:var(--text-primary);font-size:13px;margin-top:4px">
                                </div>
                                <div>
                                    <div class="field-label-with-tooltip">
                                        <label style="display:block;font-size:11px;color:var(--text-secondary)">Max SoC (%)</label>
                                        <span class="tooltip-icon" data-tooltip="Hard cap - never exceed during segment">?</span>
                                    </div>
                                    <input type="number" id="newRuleMaxSoc" value="90" min="10" max="100" style="width:100%;padding:8px;background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:6px;color:var(--text-primary);font-size:13px;margin-top:4px">
                                </div>
                            </div>
                        </div>
                        
                        <div style="display:flex;gap:12px">
                            <button onclick="closeAddRuleModal()" style="flex:1;padding:12px;background:var(--bg-card);border:1px solid var(--border-primary);border-radius:6px;color:var(--text-primary);cursor:pointer;font-size:14px">Cancel</button>
                            <button onclick="testNewRule()" style="flex:1;padding:12px;background:var(--accent-blue);border:none;border-radius:6px;color:#fff;cursor:pointer;font-size:14px">🧪 Test Rule</button>
                            <button onclick="createBackendRule()" style="flex:1;padding:12px;background:var(--color-success-dark);border:none;border-radius:6px;color:#fff;cursor:pointer;font-size:14px;font-weight:600">Create Rule</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            const modal = document.getElementById('addRuleModal');
            if (modal && window.innerWidth <= 900) {
                modal.style.padding = '10px';
                modal.style.alignItems = 'flex-start';
                modal.style.overflowY = 'auto';
                const card = modal.firstElementChild;
                if (card) {
                    card.style.width = '100%';
                    card.style.maxWidth = '100%';
                    card.style.maxHeight = 'none';
                    card.style.margin = '8px 0 16px';
                    card.style.padding = '14px';
                    card.style.overflow = 'auto';
                    card.querySelectorAll('div[style*="grid-template-columns"]').forEach((el) => {
                        el.style.gridTemplateColumns = '1fr';
                    });
                    card.querySelectorAll('div[style*="display:flex"][style*="gap:12px"]').forEach((el) => {
                        el.style.flexWrap = 'wrap';
                    });
                }
            }
            syncAutomationToggleVisibility();
            
            // Add event listeners for "between" operator toggle
            ['FeedIn', 'Buy', 'Soc'].forEach(type => {
                const opSelect = document.getElementById('cond' + type + 'Op');
                const val2Wrap = document.getElementById('cond' + type + 'Val2Wrap');
                if (opSelect && val2Wrap) {
                    opSelect.addEventListener('change', () => {
                        val2Wrap.style.display = opSelect.value === 'between' ? 'inline' : 'none';
                    });
                }
            });
        }
        
        function closeAddRuleModal() {
            const modal = document.getElementById('addRuleModal');
            if (modal) modal.remove();
            syncAutomationToggleVisibility();
        }
        
        // Update forecast lookAhead range based on unit
        function updateForecastLookAheadRange() {
            const unit = document.getElementById('condForecastLookAheadUnit')?.value || 'hours';
            const input = document.getElementById('condForecastLookAhead');
            if (!input) return;
            
            // Forecast price: max 24 hours or 1 day
            switch (unit) {
                case 'hours':
                    input.max = 24;
                    if (parseInt(input.value) > 24) input.value = 24;
                    break;
                case 'days':
                    input.max = 1;
                    if (parseInt(input.value) > 1) input.value = 1;
                    break;
            }
        }
        
        // Comprehensive rule validation function
        function validateRuleForm() {
            const errors = [];
            const modal = document.getElementById('addRuleModal');
            if (!modal) return { valid: false, errors: ['Modal not found'] };
            
            // Helper to show field error (adds red border and stores error)
            const setFieldError = (elementId, message) => {
                const el = modal.querySelector('#' + elementId) || document.getElementById(elementId);
                if (el) {
                    el.style.borderColor = 'var(--color-danger)';
                    el.style.boxShadow = '0 0 0 2px rgba(248,81,73,0.3)';
                }
                errors.push(message);
            };
            
            // Helper to clear field error styling
            const clearFieldError = (elementId) => {
                const el = modal.querySelector('#' + elementId) || document.getElementById(elementId);
                if (el) {
                    el.style.borderColor = 'var(--border-primary)';
                    el.style.boxShadow = 'none';
                }
            };
            
            // Clear all previous error styles first
            ['newRuleName', 'newRulePriority', 'newRuleDuration', 'newRuleCooldown', 'newRuleFdPwr', 
             'newRuleFdSoc', 'newRuleMinSoc', 'newRuleMaxSoc', 'condFeedInVal', 'condFeedInVal2',
             'condBuyVal', 'condBuyVal2', 'condSocVal', 'condSocVal2', 'condTempVal', 'condSolarVal',
             'condSolarLookAhead', 'condCloudVal', 'condCloudLookAhead', 'condForecastVal', 
             'condForecastLookAhead', 'condTimeStart', 'condTimeEnd'].forEach(clearFieldError);
            
            // === BASIC INFO VALIDATION ===
            const name = document.getElementById('newRuleName')?.value?.trim();
            if (!name) {
                setFieldError('newRuleName', '📝 Rule name is required');
            } else if (name.length < 3) {
                setFieldError('newRuleName', '📝 Rule name must be at least 3 characters');
            } else if (name.length > 100) {
                setFieldError('newRuleName', '📝 Rule name must be under 100 characters');
            }
            
            const priority = parseInt(document.getElementById('newRulePriority')?.value);
            if (isNaN(priority) || priority < 1 || priority > 99) {
                setFieldError('newRulePriority', '🎯 Priority must be between 1 (highest) and 99 (lowest)');
            }
            
            // === CONDITION VALIDATION ===
            const condFeedInEnabled = modal.querySelector('#condFeedInEnabled')?.checked;
            const condBuyEnabled = modal.querySelector('#condBuyEnabled')?.checked;
            const condSocEnabled = modal.querySelector('#condSocEnabled')?.checked;
            const condTempEnabled = modal.querySelector('#condTempEnabled')?.checked;
            const condSolarEnabled = modal.querySelector('#condSolarEnabled')?.checked;
            const condCloudEnabled = modal.querySelector('#condCloudEnabled')?.checked;
            const condForecastEnabled = modal.querySelector('#condForecastEnabled')?.checked;
            const condTimeEnabled = modal.querySelector('#condTimeEnabled')?.checked;
            
            const hasAnyCondition = condFeedInEnabled || condBuyEnabled || condSocEnabled || 
                                    condTempEnabled || condSolarEnabled || condCloudEnabled ||
                                    condForecastEnabled || condTimeEnabled;
            
            if (!hasAnyCondition) {
                errors.push('📋 At least one condition must be enabled for the rule to trigger');
            }
            
            // Feed-in Price validation (prices can be -100 to 500 ¢/kWh in Australia)
            if (condFeedInEnabled) {
                const val = parseFloat(modal.querySelector('#condFeedInVal')?.value);
                const op = modal.querySelector('#condFeedInOp')?.value;
                if (isNaN(val) || val < -100 || val > 500) {
                    setFieldError('condFeedInVal', '💰 Feed-in price must be between -100 and 500 ¢/kWh');
                }
                if (op === 'between') {
                    const val2 = parseFloat(modal.querySelector('#condFeedInVal2')?.value);
                    if (isNaN(val2) || val2 < -100 || val2 > 500) {
                        setFieldError('condFeedInVal2', '💰 Feed-in price range end must be between -100 and 500 ¢/kWh');
                    } else if (val >= val2) {
                        setFieldError('condFeedInVal2', '💰 Feed-in "between" range: first value must be less than second');
                    }
                }
            }
            
            // Buy Price validation
            if (condBuyEnabled) {
                const val = parseFloat(modal.querySelector('#condBuyVal')?.value);
                const op = modal.querySelector('#condBuyOp')?.value;
                if (isNaN(val) || val < -100 || val > 500) {
                    setFieldError('condBuyVal', '🛒 Buy price must be between -100 and 500 ¢/kWh');
                }
                if (op === 'between') {
                    const val2 = parseFloat(modal.querySelector('#condBuyVal2')?.value);
                    if (isNaN(val2) || val2 < -100 || val2 > 500) {
                        setFieldError('condBuyVal2', '🛒 Buy price range end must be between -100 and 500 ¢/kWh');
                    } else if (val >= val2) {
                        setFieldError('condBuyVal2', '🛒 Buy "between" range: first value must be less than second');
                    }
                }
            }
            
            // Battery SoC validation (0-100%)
            if (condSocEnabled) {
                const val = parseFloat(modal.querySelector('#condSocVal')?.value);
                const op = modal.querySelector('#condSocOp')?.value;
                if (isNaN(val) || val < 0 || val > 100) {
                    setFieldError('condSocVal', '🔋 Battery SoC must be between 0% and 100%');
                }
                if (op === 'between') {
                    const val2 = parseFloat(modal.querySelector('#condSocVal2')?.value);
                    if (isNaN(val2) || val2 < 0 || val2 > 100) {
                        setFieldError('condSocVal2', '🔋 SoC range end must be between 0% and 100%');
                    } else if (val >= val2) {
                        setFieldError('condSocVal2', '🔋 SoC "between" range: first value must be less than second');
                    }
                }
            }
            
            // Temperature validation (-40°C to 80°C reasonable range for batteries/environment)
            if (condTempEnabled) {
                const val = parseFloat(modal.querySelector('#condTempVal')?.value);
                if (isNaN(val) || val < -40 || val > 80) {
                    setFieldError('condTempVal', '🌡️ Temperature must be between -40°C and 80°C');
                }
            }
            
            // Solar Radiation validation (0-1500 W/m², lookAhead 1-168 hours or 1-7 days)
            if (condSolarEnabled) {
                const val = parseFloat(modal.querySelector('#condSolarVal')?.value);
                if (isNaN(val) || val < 0 || val > 1500) {
                    setFieldError('condSolarVal', '☀️ Solar radiation must be between 0 and 1500 W/m²');
                }
                const lookAhead = parseInt(modal.querySelector('#condSolarLookAhead')?.value);
                const unit = modal.querySelector('#condSolarLookAheadUnit')?.value;
                if (unit === 'hours' && (isNaN(lookAhead) || lookAhead < 1 || lookAhead > 168)) {
                    setFieldError('condSolarLookAhead', '☀️ Look-ahead must be 1-168 hours');
                } else if (unit === 'days' && (isNaN(lookAhead) || lookAhead < 1 || lookAhead > 7)) {
                    setFieldError('condSolarLookAhead', '☀️ Look-ahead must be 1-7 days');
                }
            }
            
            // Cloud Cover validation (0-100%, lookAhead 1-168 hours or 1-7 days)
            if (condCloudEnabled) {
                const val = parseFloat(modal.querySelector('#condCloudVal')?.value);
                if (isNaN(val) || val < 0 || val > 100) {
                    setFieldError('condCloudVal', '☁️ Cloud cover must be between 0% and 100%');
                }
                const lookAhead = parseInt(modal.querySelector('#condCloudLookAhead')?.value);
                const unit = modal.querySelector('#condCloudLookAheadUnit')?.value;
                if (unit === 'hours' && (isNaN(lookAhead) || lookAhead < 1 || lookAhead > 168)) {
                    setFieldError('condCloudLookAhead', '☁️ Look-ahead must be 1-168 hours');
                } else if (unit === 'days' && (isNaN(lookAhead) || lookAhead < 1 || lookAhead > 7)) {
                    setFieldError('condCloudLookAhead', '☁️ Look-ahead must be 1-7 days');
                }
            }
            
            // Forecast Price validation (hours only, max 24h or 1 day)
            if (condForecastEnabled) {
                const val = parseFloat(modal.querySelector('#condForecastVal')?.value);
                if (isNaN(val) || val < -100 || val > 500) {
                    setFieldError('condForecastVal', '📈 Forecast price must be between -100 and 500 ¢/kWh');
                }
                const lookAhead = parseInt(modal.querySelector('#condForecastLookAhead')?.value);
                const unit = modal.querySelector('#condForecastLookAheadUnit')?.value;
                if (unit === 'hours' && (isNaN(lookAhead) || lookAhead < 1 || lookAhead > 24)) {
                    setFieldError('condForecastLookAhead', '📈 Look-ahead must be 1-24 hours');
                } else if (unit === 'days' && (isNaN(lookAhead) || lookAhead < 1 || lookAhead > 1)) {
                    setFieldError('condForecastLookAhead', '📈 Look-ahead must be exactly 1 day');
                }
            }
            
            // Time Window validation
            if (condTimeEnabled) {
                const start = modal.querySelector('#condTimeStart')?.value;
                const end = modal.querySelector('#condTimeEnd')?.value;
                if (!start) {
                    setFieldError('condTimeStart', '🕐 Start time is required');
                }
                if (!end) {
                    setFieldError('condTimeEnd', '🕐 End time is required');
                }
                // Note: Don't validate start < end since overnight windows like 22:00-06:00 are valid
            }
            
            // === ACTION VALIDATION ===
            const duration = parseInt(document.getElementById('newRuleDuration')?.value);
            if (isNaN(duration) || duration < 5 || duration > 1440) {
                setFieldError('newRuleDuration', '⏱️ Duration must be 5-1440 minutes (max 24 hours)');
            }
            
            const cooldown = parseInt(document.getElementById('newRuleCooldown')?.value);
            if (isNaN(cooldown) || cooldown < 1 || cooldown > 60) {
                setFieldError('newRuleCooldown', '🔄 Cooldown must be 1-60 minutes');
            }
            
            const fdPwr = parseInt(document.getElementById('newRuleFdPwr')?.value);
            if (isNaN(fdPwr) || fdPwr < 0 || fdPwr > 10500) {
                setFieldError('newRuleFdPwr', '⚡ Power must be 0-10500W (inverter max output)');
            }
            
            const fdSoc = parseInt(document.getElementById('newRuleFdSoc')?.value);
            if (isNaN(fdSoc) || fdSoc < 5 || fdSoc > 100) {
                setFieldError('newRuleFdSoc', '🔋 Stop SoC must be 5-100% (cutoff threshold)');
            }
            
            const minSoc = parseInt(document.getElementById('newRuleMinSoc')?.value);
            if (isNaN(minSoc) || minSoc < 5 || minSoc > 100) {
                setFieldError('newRuleMinSoc', '🔋 Min SoC (Grid) must be 5-100%');
            }
            
            const maxSoc = parseInt(document.getElementById('newRuleMaxSoc')?.value);
            if (isNaN(maxSoc) || maxSoc < 10 || maxSoc > 100) {
                setFieldError('newRuleMaxSoc', '🔋 Max SoC must be 10-100%');
            }
            
            // Cross-field validations for SoC
            if (!isNaN(minSoc) && !isNaN(maxSoc) && minSoc >= maxSoc) {
                setFieldError('newRuleMinSoc', '🔋 Min SoC (Grid) must be less than Max SoC');
                setFieldError('newRuleMaxSoc', '🔋 Max SoC must be greater than Min SoC (Grid)');
            }
            
            if (!isNaN(fdSoc) && !isNaN(minSoc) && fdSoc > minSoc + 50) {
                // Warning but not error - Stop SoC much higher than Min might be intentional
            }
            
            return { valid: errors.length === 0, errors };
        }
        
        // Show validation errors in a user-friendly modal
        function showValidationErrors(errors) {
            const errorHtml = `
                <div id="validationErrorModal" style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:12001">
                    <div style="background:var(--bg-secondary);border:2px solid var(--color-danger);border-radius:12px;padding:20px;width:90%;max-width:450px;max-height:80vh;overflow-y:auto">
                        <div style="display:flex;align-items:center;gap:10px;margin-bottom:16px">
                            <span style="font-size:28px">⚠️</span>
                            <h3 style="margin:0;color:var(--color-danger);font-size:16px">Please fix the following issues:</h3>
                        </div>
                        <ul style="margin:0;padding:0 0 0 20px;color:var(--text-primary);font-size:13px;line-height:1.8">
                            ${errors.map(e => `<li style="margin-bottom:6px">${e}</li>`).join('')}
                        </ul>
                        <button onclick="document.getElementById('validationErrorModal').remove()" 
                                style="width:100%;margin-top:16px;padding:12px;background:var(--bg-card);border:1px solid var(--border-primary);border-radius:6px;color:var(--text-primary);cursor:pointer;font-size:14px">
                            Got it, let me fix
                        </button>
                    </div>
                </div>
            `;
            // Remove any existing error modal
            const existing = document.getElementById('validationErrorModal');
            if (existing) existing.remove();
            document.body.insertAdjacentHTML('beforeend', errorHtml);
        }
        
        async function createBackendRule() {
            // Run comprehensive validation first
            const validation = validateRuleForm();
            if (!validation.valid) {
                showValidationErrors(validation.errors);
                return;
            }
            
            const editingId = document.getElementById('editingRuleId')?.value;
            const name = document.getElementById('newRuleName').value.trim();
            // Auto-generate rule ID from name if not editing
            const ruleName = editingId || name.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, '') || ('rule_' + Date.now());
            const priority = parseInt(document.getElementById('newRulePriority').value) || 5;
            const cooldownMinutes = parseInt(document.getElementById('newRuleCooldown').value) || 5;
            const workMode = document.getElementById('newRuleWorkMode').value;
            const durationMinutes = parseInt(document.getElementById('newRuleDuration').value) || 30;
            const fdPwr = parseInt(document.getElementById('newRuleFdPwr').value) || 0;
            const fdSoc = parseInt(document.getElementById('newRuleFdSoc').value) || 10;
            const minSocOnGrid = parseInt(document.getElementById('newRuleMinSoc').value) || 10;
            const maxSoc = parseInt(document.getElementById('newRuleMaxSoc').value) || 100;
            
            // Collect conditions - use modal scoping to avoid duplicate ID conflicts with old modal
            const modal = document.getElementById('addRuleModal');
            const conditions = {
                feedInPrice: {
                    enabled: modal?.querySelector('#condFeedInEnabled')?.checked || false,
                    operator: modal?.querySelector('#condFeedInOp')?.value || '>',
                    value: parseFloat(modal?.querySelector('#condFeedInVal')?.value) || 0,
                    value2: parseFloat(modal?.querySelector('#condFeedInVal2')?.value) || 0
                },
                buyPrice: {
                    enabled: modal?.querySelector('#condBuyEnabled')?.checked || false,
                    operator: modal?.querySelector('#condBuyOp')?.value || '>',
                    value: parseFloat(modal?.querySelector('#condBuyVal')?.value) || 0,
                    value2: parseFloat(modal?.querySelector('#condBuyVal2')?.value) || 0
                },
                soc: {
                    enabled: modal?.querySelector('#condSocEnabled')?.checked || false,
                    operator: modal?.querySelector('#condSocOp')?.value || '<',
                    value: parseFloat(modal?.querySelector('#condSocVal')?.value) || 50,
                    value2: parseFloat(modal?.querySelector('#condSocVal2')?.value) || 100
                },
                temperature: {
                    enabled: modal?.querySelector('#condTempEnabled')?.checked || false,
                    type: modal?.querySelector('#condTempType')?.value || 'current',
                    operator: modal?.querySelector('#condTempOp')?.value || '>',
                    value: parseFloat(modal?.querySelector('#condTempVal')?.value) || 40
                },
                solarRadiation: {
                    enabled: modal?.querySelector('#condSolarEnabled')?.checked || false,
                    checkType: modal?.querySelector('#condSolarCheck')?.value || 'average',
                    operator: modal?.querySelector('#condSolarOp')?.value || '>',
                    value: parseFloat(modal?.querySelector('#condSolarVal')?.value) || 300,
                    lookAhead: parseInt(modal?.querySelector('#condSolarLookAhead')?.value) || 6,
                    lookAheadUnit: modal?.querySelector('#condSolarLookAheadUnit')?.value || 'hours'
                },
                cloudCover: {
                    enabled: modal?.querySelector('#condCloudEnabled')?.checked || false,
                    checkType: modal?.querySelector('#condCloudCheck')?.value || 'average',
                    operator: modal?.querySelector('#condCloudOp')?.value || '<',
                    value: parseFloat(modal?.querySelector('#condCloudVal')?.value) || 50,
                    lookAhead: parseInt(modal?.querySelector('#condCloudLookAhead')?.value) || 6,
                    lookAheadUnit: modal?.querySelector('#condCloudLookAheadUnit')?.value || 'hours'
                },
                forecastPrice: {
                    enabled: modal?.querySelector('#condForecastEnabled')?.checked || false,
                    type: modal?.querySelector('#condForecastType')?.value || 'feedIn',
                    checkType: modal?.querySelector('#condForecastCheck')?.value || 'average',
                    operator: modal?.querySelector('#condForecastOp')?.value || '>',
                    value: parseFloat(modal?.querySelector('#condForecastVal')?.value) || 0,
                    lookAhead: parseInt(modal?.querySelector('#condForecastLookAhead')?.value) || 1,
                    lookAheadUnit: modal?.querySelector('#condForecastLookAheadUnit')?.value || 'hours'
                },
                time: {
                    enabled: modal?.querySelector('#condTimeEnabled')?.checked || false,
                    startTime: modal?.querySelector('#condTimeStart')?.value || '00:00',
                    endTime: modal?.querySelector('#condTimeEnd')?.value || '23:59'
                }
            };
            
            try {
                // Use update endpoint if editing, create if new
                const endpoint = editingId ? '/api/automation/rule/update' : '/api/automation/rule/create';
                const resp = await authenticatedFetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ruleName,
                        name: name || ruleName,
                        priority,
                        conditions,
                        cooldownMinutes,
                        enabled: document.getElementById('newRuleEnabled')?.checked === true,
                        action: { workMode, durationMinutes, fdPwr, fdSoc, minSocOnGrid, maxSoc }
                    })
                });
                const data = await resp.json();
                
                if (data.errno === 0) {
                    closeAddRuleModal();
                    loadBackendAutomationStatus();
                    showMessage('success', `✅ Rule "${name}" ${editingId ? 'updated' : 'created'} successfully!`, 3000);
                } else {
                    showValidationErrors([`Server error: ${data.error || 'Unknown error'}`]);
                }
            } catch (e) {
                showValidationErrors([`Network error: ${e.message}`]);
            }
        }
        
        async function testNewRule() {
            // Redirect to test page where user can test rule with live data
            // Note: The rule definition is NOT saved until you click "Create Rule"
            alert('📋 Test Rule opens the dedicated test page (test.html).\n\nThere you can:\n• Simulate different conditions\n• See if the rule would trigger\n• Preview what action would execute\n\n⚠️ Your rule is NOT saved until you click "Create Rule" on this page.');
            window.open('/test.html', '_blank');
        }
        
        // Edit an existing rule - opens modal with pre-filled values
        async function editBackendRule(ruleName) {
            try {
                const resp = await authenticatedFetch('/api/automation/status');
                const data = await resp.json();
                const rule = data.result?.rules?.[ruleName];
                if (!rule) {
                    alert('Rule not found');
                    return;
                }
                
                // Open the add modal
                showAddRuleModal();
                
                // Wait for modal to render
                await new Promise(r => setTimeout(r, 50));
                
                // Get modal reference for scoped queries
                const modal = document.getElementById('addRuleModal');
                
                // Change modal title
                const modalTitle = modal?.querySelector('h3');
                if (modalTitle) modalTitle.innerHTML = '✏️ Edit Automation Rule';
                
                // Set editing flag
                document.getElementById('editingRuleId').value = ruleName;
                
                // Fill in basic info (these have unique IDs, OK to use getElementById)
                document.getElementById('newRuleName').value = rule.name || ruleName;
                document.getElementById('newRulePriority').value = rule.priority || 5;
                document.getElementById('newRuleEnabled').checked = rule.enabled !== false;  // Default to enabled if not specified
                document.getElementById('newRuleCooldown').value = rule.cooldownMinutes || 5;
                
                // Fill in conditions using modal-scoped queries
                const conditions = rule.conditions || {};
                if (conditions.feedInPrice) {
                    const el = modal?.querySelector('#condFeedInEnabled'); if (el) el.checked = conditions.feedInPrice.enabled || false;
                    const op = modal?.querySelector('#condFeedInOp'); if (op) op.value = conditions.feedInPrice.operator || '>';
                    const val = modal?.querySelector('#condFeedInVal'); if (val) val.value = conditions.feedInPrice.value || 0;
                }
                if (conditions.buyPrice) {
                    const el = modal?.querySelector('#condBuyEnabled'); if (el) el.checked = conditions.buyPrice.enabled || false;
                    const op = modal?.querySelector('#condBuyOp'); if (op) op.value = conditions.buyPrice.operator || '<';
                    const val = modal?.querySelector('#condBuyVal'); if (val) val.value = conditions.buyPrice.value || 0;
                }
                if (conditions.soc) {
                    const el = modal?.querySelector('#condSocEnabled'); if (el) el.checked = conditions.soc.enabled || false;
                    const op = modal?.querySelector('#condSocOp'); if (op) op.value = conditions.soc.operator || '>';
                    const val = modal?.querySelector('#condSocVal'); if (val) val.value = conditions.soc.value || 50;
                }
                if (conditions.temperature) {
                    const el = modal?.querySelector('#condTempEnabled'); if (el) el.checked = conditions.temperature.enabled || false;
                    const tp = modal?.querySelector('#condTempType'); if (tp) tp.value = conditions.temperature.type || 'battery';
                    const op = modal?.querySelector('#condTempOp'); if (op) op.value = conditions.temperature.operator || '<';
                    const val = modal?.querySelector('#condTempVal'); if (val) val.value = conditions.temperature.value || 40;
                }
                // Solar Radiation condition
                if (conditions.solarRadiation) {
                    const el = modal?.querySelector('#condSolarEnabled'); if (el) el.checked = conditions.solarRadiation.enabled || false;
                    const chk = modal?.querySelector('#condSolarCheck'); if (chk) chk.value = conditions.solarRadiation.checkType || 'average';
                    const op = modal?.querySelector('#condSolarOp'); if (op) op.value = conditions.solarRadiation.operator || '>';
                    const val = modal?.querySelector('#condSolarVal'); if (val) val.value = conditions.solarRadiation.value || 300;
                    const la = modal?.querySelector('#condSolarLookAhead'); if (la) la.value = conditions.solarRadiation.lookAhead || 6;
                    const lau = modal?.querySelector('#condSolarLookAheadUnit'); if (lau) lau.value = conditions.solarRadiation.lookAheadUnit || 'hours';
                }
                // Cloud Cover condition
                if (conditions.cloudCover) {
                    const el = modal?.querySelector('#condCloudEnabled'); if (el) el.checked = conditions.cloudCover.enabled || false;
                    const chk = modal?.querySelector('#condCloudCheck'); if (chk) chk.value = conditions.cloudCover.checkType || 'average';
                    const op = modal?.querySelector('#condCloudOp'); if (op) op.value = conditions.cloudCover.operator || '<';
                    const val = modal?.querySelector('#condCloudVal'); if (val) val.value = conditions.cloudCover.value || 50;
                    const la = modal?.querySelector('#condCloudLookAhead'); if (la) la.value = conditions.cloudCover.lookAhead || 6;
                    const lau = modal?.querySelector('#condCloudLookAheadUnit'); if (lau) lau.value = conditions.cloudCover.lookAheadUnit || 'hours';
                }
                if (conditions.forecastPrice) {
                    const el = modal?.querySelector('#condForecastEnabled'); if (el) el.checked = conditions.forecastPrice.enabled || false;
                    const tp = modal?.querySelector('#condForecastType'); if (tp) tp.value = conditions.forecastPrice.type || 'feedIn';
                    const chk = modal?.querySelector('#condForecastCheck'); if (chk) chk.value = conditions.forecastPrice.checkType || 'average';
                    const op = modal?.querySelector('#condForecastOp'); if (op) op.value = conditions.forecastPrice.operator || '>';
                    const val = modal?.querySelector('#condForecastVal'); if (val) val.value = conditions.forecastPrice.value || 0;
                    const la = modal?.querySelector('#condForecastLookAhead'); if (la) la.value = conditions.forecastPrice.lookAhead || 1;
                    const lau = modal?.querySelector('#condForecastLookAheadUnit'); if (lau) lau.value = conditions.forecastPrice.lookAheadUnit || 'hours';
                    updateForecastLookAheadRange();
                }
                const timeCondition = conditions.time || conditions.timeWindow;
                if (timeCondition && modal) {
                    const timeEnabledEl = modal.querySelector('#condTimeEnabled');
                    const timeStartEl = modal.querySelector('#condTimeStart');
                    const timeEndEl = modal.querySelector('#condTimeEnd');
                    
                    if (timeEnabledEl) timeEnabledEl.checked = timeCondition.enabled || false;
                    if (timeStartEl) timeStartEl.value = timeCondition.startTime || timeCondition.start || '06:00';
                    if (timeEndEl) timeEndEl.value = timeCondition.endTime || timeCondition.end || '18:00';
                }
                
                // Fill in action
                const action = rule.action || {};
                document.getElementById('newRuleWorkMode').value = action.workMode || 'SelfUse';
                document.getElementById('newRuleDuration').value = action.durationMinutes || 30;
                document.getElementById('newRuleFdPwr').value = action.fdPwr || 0;
                document.getElementById('newRuleFdSoc').value = action.fdSoc || 10;
                document.getElementById('newRuleMinSoc').value = action.minSocOnGrid || 10;
                document.getElementById('newRuleMaxSoc').value = action.maxSoc || 100;
                
                // Change button text
                const createBtn = modal?.querySelector('button[onclick="createBackendRule()"]');
                if (createBtn) createBtn.textContent = 'Save Changes';
            } catch (e) {
                alert('Error loading rule: ' + e.message);
            }
        }
        
        async function deleteBackendRule(ruleName) {
            if (!confirm(`Delete rule "${ruleName}"? This cannot be undone.`)) return;
            
            try {
                const resp = await authenticatedFetch('/api/automation/rule/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ruleName })
                });
                const data = await resp.json();
                
                if (data.errno === 0) {
                    // Trigger an immediate cycle to clear any segments from the deleted rule
                    console.log(`[Automation] Rule ${ruleName} deleted - triggering immediate cycle to clear segments`);
                    try {
                        const cycleResp = await authenticatedFetch('/api/automation/cycle', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({})
                        });
                        const cycleData = await cycleResp.json();
                        if (cycleData.errno === 0) {
                            console.log('[Automation] Cycle complete - segments cleared if rule was active');
                        }
                    } catch (cycleErr) {
                        console.warn('[Automation] Failed to run cycle after deleting rule:', cycleErr);
                    }
                    
                    loadBackendAutomationStatus();
                } else {
                    alert('Failed to delete rule: ' + (data.error || 'Unknown error'));
                }
            } catch (e) {
                alert('Error deleting rule: ' + e.message);
            }
        }

        // Toggle backend automation on/off
        async function toggleBackendAutomation() {
            try {
                const statusResp = await authenticatedFetch('/api/automation/status');
                const statusData = await statusResp.json();
                const currentEnabled = statusData.result?.enabled || false;
                
                const resp = await authenticatedFetch('/api/automation/enable', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: !currentEnabled })
                });
                const data = await resp.json();
                if (data.errno === 0) {
                    // Refresh status immediately to show updated state
                    await loadBackendAutomationStatus();
                    
                    // Force an immediate cycle when toggling (to clear segments when disabling,
                    // or trigger rules when enabling)
                    console.log(`[Automation] Master switch toggled to ${data.result.enabled ? 'ENABLED' : 'DISABLED'} - triggering immediate cycle`);
                    try {
                        const cycleResp = await authenticatedFetch('/api/automation/cycle', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({})
                        });
                        const cycleData = await cycleResp.json();
                        if (cycleData.errno === 0) {
                            console.log('[Automation] Cycle result:', cycleData.result);
                            // Refresh status to show updated state
                            await loadBackendAutomationStatus();
                            
                            // Update scheduler warning if present
                            if (typeof checkAutomationStatusForScheduler === 'function') {
                                checkAutomationStatusForScheduler();
                            }
                            
                            if (data.result.enabled) {
                                showMessage('success', '✅ Automation enabled', 2000);
                            } else {
                                showMessage('success', '🔆 Automation disabled and segments cleared', 3000);
                            }
                        }
                    } catch (cycleError) {
                        console.error('[Automation] Error running cycle:', cycleError);
                        showMessage('warning', `Automation ${data.result.enabled ? 'enabled' : 'disabled'} but cycle failed`, 3000);
                    }
                }
            } catch (e) {
                console.error('Failed to toggle backend automation:', e);
                showMessage('error', 'Failed to toggle automation', 2000);
            }
        }

        // Update a backend rule setting
        async function updateBackendRule(ruleName, field, value) {
            try {
                const body = { ruleName };
                body[field] = field === 'enabled' ? !!value : (field === 'threshold' ? parseFloat(value) : parseInt(value));
                
                const resp = await authenticatedFetch('/api/automation/rule/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const data = await resp.json();
                if (data.errno === 0) {
                    console.log(`Rule ${ruleName} updated:`, data.result);
                    
                    // If disabling a rule, trigger an immediate cycle to clear any active segments
                    if (field === 'enabled' && value === false) {
                        console.log(`[Automation] Rule ${ruleName} disabled - triggering immediate cycle to clear segments`);
                        try {
                            const cycleResp = await authenticatedFetch('/api/automation/cycle', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({})
                            });
                            const cycleData = await cycleResp.json();
                            if (cycleData.errno === 0) {
                                console.log('[Automation] Cycle complete - segments cleared if rule was active');
                            }
                        } catch (cycleErr) {
                            console.warn('[Automation] Failed to run cycle after disabling rule:', cycleErr);
                        }
                    }
                    
                    // Refresh UI to show current state
                    loadBackendAutomationStatus();
                }
            } catch (e) {
                console.error('Failed to update backend rule:', e);
            }
        }

        // Update a backend rule action parameter
        async function updateBackendRuleAction(ruleName, field, value) {
            try {
                const body = { 
                    ruleName,
                    action: {}
                };
                // Parse value appropriately
                if (field === 'workMode') {
                    body.action[field] = value;
                } else {
                    body.action[field] = parseInt(value, 10);
                }
                
                const resp = await authenticatedFetch('/api/automation/rule/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const data = await resp.json();
                if (data.errno === 0) {
                    console.log(`Rule ${ruleName} action updated:`, data.result);
                }
            } catch (e) {
                console.error('Failed to update backend rule action:', e);
            }
        }

        // Test trigger a backend rule manually
        async function testBackendRule(ruleName) {
            if (!confirm(`Manually trigger the "${ruleName}" rule? This will immediately apply the automation action.`)) return;
            
            try {
                const resp = await authenticatedFetch('/api/automation/trigger', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ruleName })
                });
                const data = await resp.json();
                
                // Show result
                const resultEl = document.getElementById('result');
                const statusBar = document.getElementById('status-bar');
                if (panelCollapsed) togglePanel();
                statusBar.style.display = 'flex';
                statusBar.querySelector('.endpoint').textContent = `Automation Trigger - ${ruleName}`;
                resultEl.className = data.errno === 0 ? 'success' : 'error';
                resultEl.textContent = JSON.stringify(data, null, 2);
                
                // Reload status to show updated lastTriggered
                loadBackendAutomationStatus();
                // Also reload scheduler to see the changes
                setTimeout(loadSchedulerSegments, 1000);
            } catch (e) {
                console.error('Failed to trigger rule:', e);
                alert('Failed to trigger rule: ' + e.message);
            }
        }

        // Reset backend automation cooldowns
        async function resetBackendAutomation() {
            try {
                const resp = await authenticatedFetch('/api/automation/reset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await resp.json();
                if (data.errno === 0) {
                    loadBackendAutomationStatus();
                }
            } catch (e) {
                console.error('Failed to reset automation:', e);
            }
        }

        function saveAutomationRules() {
            try {
                localStorage.setItem('automationRules', JSON.stringify(automationRules));
                localStorage.setItem('automationEnabled', automationEnabled.toString());
            } catch (e) {
                console.error('Failed to save automation rules:', e);
            }
        }

        function toggleAutomation() {
            automationEnabled = !automationEnabled;
            saveAutomationRules();
            updateAutomationToggle();
        }

        function updateAutomationToggle() {
            // Some builds may not include the legacy DOM elements (automationToggle, automationStatusText)
            // guard access so missing nodes do not throw and break the rest of the page JS.
            const toggle = document.getElementById('automationToggle');
            const text = document.getElementById('automationStatusText');

            if (toggle) {
                try {
                    if (automationEnabled) toggle.classList.add('active');
                    else toggle.classList.remove('active');
                } catch (e) { console.warn('updateAutomationToggle toggle update failed:', e); }
            }

            if (text) {
                try {
                    text.textContent = automationEnabled ? 'Enabled' : 'Disabled';
                    if (automationEnabled) text.classList.add('active');
                    else text.classList.remove('active');
                } catch (e) { console.warn('updateAutomationToggle text update failed:', e); }
            }
        }

        function renderRules() {
            const container = document.getElementById('rulesContainer');
            const emptyMsg = document.getElementById('emptyRulesMessage');
            
            if (!container) return;

            // Clear existing rule cards (keep empty message and add button)
            const existingCards = container.querySelectorAll('.rule-card');
            existingCards.forEach(card => card.remove());
            
            if (automationRules.length === 0) {
                emptyMsg.style.display = 'block';
            } else {
                emptyMsg.style.display = 'none';
                
                // Sort by priority
                const sortedRules = [...automationRules].sort((a, b) => (a.priority || 3) - (b.priority || 3));
                
                sortedRules.forEach(rule => {
                    const card = createRuleCard(rule);
                    container.insertBefore(card, container.querySelector('.add-rule-card'));
                });
            }
        }

        function createRuleCard(rule) {
            const card = document.createElement('div');
            card.className = `rule-card ${rule.enabled === false ? 'disabled' : ''}`;
            card.dataset.ruleId = rule.id;
            
            // Build conditions display
            let conditionsHtml = '';
            if (rule.conditions) {
                if (rule.conditions.price && rule.conditions.price.enabled) {
                    const p = rule.conditions.price;
                    const typeLabel = p.type === 'feedin' ? 'Feed-in' : 'Buy';
                    let valueStr = p.op === 'between' ? `${p.value}¢ - ${p.value2}¢` : `${p.op} ${p.value}¢`;
                    conditionsHtml += `<span class="condition-tag price">💰 ${typeLabel} ${valueStr}</span>`;
                }
                if (rule.conditions.soc && rule.conditions.soc.enabled) {
                    const s = rule.conditions.soc;
                    let valueStr = s.op === 'between' ? `${s.value}% - ${s.value2}%` : `${s.op} ${s.value}%`;
                    conditionsHtml += `<span class="condition-tag soc">🔋 SoC ${valueStr}</span>`;
                }
                if (rule.conditions.temp && rule.conditions.temp.enabled) {
                    const t = rule.conditions.temp;
                    let valueStr = t.op === 'between' ? `${t.value}°C - ${t.value2}°C` : `${t.op} ${t.value}°C`;
                    conditionsHtml += `<span class="condition-tag temp">🌡️ Temp ${valueStr}</span>`;
                }
                if (rule.conditions.weather && rule.conditions.weather.enabled) {
                    const w = rule.conditions.weather;
                    conditionsHtml += `<span class="condition-tag weather">🌤️ ${w.type || 'Any'}</span>`;
                }
                if (rule.conditions.time && rule.conditions.time.enabled) {
                    const tm = rule.conditions.time;
                    conditionsHtml += `<span class="condition-tag weather">🕐 ${tm.start} - ${tm.end}</span>`;
                }
            }
            if (!conditionsHtml) {
                conditionsHtml = '<span style="color:var(--text-muted);font-size:12px">No conditions set</span>';
            }
            
            // Build actions display
            let actionsHtml = '';
            if (rule.action) {
                if (rule.action.workMode) {
                    const modeClass = rule.action.workMode === 'ForceCharge' ? 'charge' : 
                                     rule.action.workMode === 'ForceDischarge' ? 'discharge' : 
                                     rule.action.workMode === 'Feedin' ? 'feedin' : '';
                    actionsHtml += `<span class="action-tag ${modeClass}">⚡ ${rule.action.workMode}</span>`;
                }
                if (rule.action.minSoC) {
                    actionsHtml += `<span class="action-tag">Min ${rule.action.minSoC}%</span>`;
                }
                if (rule.action.maxSoC) {
                    actionsHtml += `<span class="action-tag">Max ${rule.action.maxSoC}%</span>`;
                }
            }
            if (!actionsHtml) {
                actionsHtml = '<span style="color:var(--text-muted);font-size:12px">No action set</span>';
            }
            
            card.innerHTML = `
                <div class="rule-card-header">
                    <div class="rule-card-title">
                        <span style="font-size:11px;color:var(--text-secondary);background:rgba(0,0,0,0.3);padding:2px 6px;border-radius:4px">P${rule.priority || 3}</span>
                        ${rule.name || 'Unnamed Rule'}
                    </div>
                    <div class="rule-card-actions">
                        <button onclick="toggleRuleEnabled('${rule.id}')" title="${rule.enabled !== false ? 'Disable' : 'Enable'}">
                            ${rule.enabled !== false ? '✓' : '○'}
                        </button>
                        <button onclick="editRule('${rule.id}')" title="Edit">✏️</button>
                        <button class="delete" onclick="deleteRule('${rule.id}')" title="Delete">🗑️</button>
                    </div>
                </div>
                <div class="rule-card-body">
                    <div class="rule-conditions">
                        <div class="rule-section-label">📋 When</div>
                        <div>${conditionsHtml}</div>
                    </div>
                    <div class="rule-actions-box">
                        <div class="rule-section-label">⚡ Then</div>
                        <div>${actionsHtml}</div>
                    </div>
                </div>
            `;
            
            return card;
        }

        function openRuleModal(ruleId = null) {
            const modal = document.getElementById('ruleModal');
            const title = document.getElementById('ruleModalTitle');
            const form = document.getElementById('ruleForm');
            
            // Reset form
            form.reset();
            document.getElementById('ruleId').value = '';
            
            // Reset all condition items
            ['Price', 'SoC', 'Temp', 'Weather', 'Time'].forEach(cond => {
                document.getElementById(`cond${cond}Enabled`).checked = false;
                document.getElementById(`condition${cond}`).classList.remove('active');
            });
            
            // Hide "between" value2 fields
            ['condPriceValue2Row', 'condSoCValue2Row', 'condTempValue2Row'].forEach(id => {
                document.getElementById(id).style.display = 'none';
            });
            
            if (ruleId) {
                // Edit existing rule
                title.textContent = 'Edit Automation Rule';
                const rule = automationRules.find(r => r.id === ruleId);
                if (rule) {
                    populateRuleForm(rule);
                }
            } else {
                title.textContent = 'Create Automation Rule';
            }
            
            modal.classList.add('show');
            syncAutomationToggleVisibility();
        }

        function closeRuleModal() {
            document.getElementById('ruleModal').classList.remove('show');
            syncAutomationToggleVisibility();
        }

        function populateRuleForm(rule) {
            document.getElementById('ruleId').value = rule.id;
            document.getElementById('ruleName').value = rule.name || '';
            document.getElementById('rulePriority').value = rule.priority || 3;
            
            // Populate conditions
            if (rule.conditions) {
                if (rule.conditions.price) {
                    const p = rule.conditions.price;
                    document.getElementById('condPriceEnabled').checked = p.enabled;
                    if (p.enabled) document.getElementById('conditionPrice').classList.add('active');
                    document.getElementById('condPriceType').value = p.type || 'buy';
                    document.getElementById('condPriceOp').value = p.op || '<';
                    document.getElementById('condPriceValue').value = p.value || '';
                    if (p.op === 'between') {
                        document.getElementById('condPriceValue2Row').style.display = 'flex';
                        document.getElementById('condPriceValue2').value = p.value2 || '';
                    }
                }
                if (rule.conditions.soc) {
                    const s = rule.conditions.soc;
                    document.getElementById('condSoCEnabled').checked = s.enabled;
                    if (s.enabled) document.getElementById('conditionSoC').classList.add('active');
                    document.getElementById('condSoCOp').value = s.op || '<';
                    document.getElementById('condSoCValue').value = s.value || '';
                    if (s.op === 'between') {
                        document.getElementById('condSoCValue2Row').style.display = 'flex';
                        document.getElementById('condSoCValue2').value = s.value2 || '';
                    }
                }
                if (rule.conditions.temp) {
                    const t = rule.conditions.temp;
                    document.getElementById('condTempEnabled').checked = t.enabled;
                    if (t.enabled) document.getElementById('conditionTemp').classList.add('active');
                    document.getElementById('condTempOp').value = t.op || '<';
                    document.getElementById('condTempValue').value = t.value || '';
                    if (t.op === 'between') {
                        document.getElementById('condTempValue2Row').style.display = 'flex';
                        document.getElementById('condTempValue2').value = t.value2 || '';
                    }
                }
                if (rule.conditions.weather) {
                    const w = rule.conditions.weather;
                    document.getElementById('condWeatherEnabled').checked = w.enabled;
                    if (w.enabled) document.getElementById('conditionWeather').classList.add('active');
                    document.getElementById('condWeatherType').value = w.type || 'any';
                    document.getElementById('condWeatherSolarOp').value = w.solarOp || 'any';
                    document.getElementById('condWeatherSolarValue').value = w.solarValue || '';
                }
                if (rule.conditions.time) {
                    const tm = rule.conditions.time;
                    document.getElementById('condTimeEnabled').checked = tm.enabled;
                    if (tm.enabled) document.getElementById('conditionTime').classList.add('active');
                    document.getElementById('condTimeStart').value = tm.start || '00:00';
                    document.getElementById('condTimeEnd').value = tm.end || '23:59';
                }
            }
            
            // Populate actions
            if (rule.action) {
                document.getElementById('actionWorkMode').value = rule.action.workMode || '';
                document.getElementById('actionMinSoC').value = rule.action.minSoC || '';
                document.getElementById('actionMaxSoC').value = rule.action.maxSoC || '';
                document.getElementById('actionFdPwr').value = rule.action.fdPwr || '';
            }
        }

        function toggleCondition(condName) {
            const checkbox = document.getElementById(`cond${condName}Enabled`);
            const item = document.getElementById(`condition${condName}`);
            if (!item || !checkbox) return;
            
            if (checkbox.checked) {
                item.classList.add('active');
            } else {
                item.classList.remove('active');
            }
        }

        // Handle operator change to show/hide between value2 field
        document.addEventListener('DOMContentLoaded', () => {
            ['Price', 'SoC', 'Temp'].forEach(cond => {
                const opSelect = document.getElementById(`cond${cond}Op`);
                const value2Row = document.getElementById(`cond${cond}Value2Row`);
                if (opSelect && value2Row) {
                    opSelect.addEventListener('change', () => {
                        value2Row.style.display = opSelect.value === 'between' ? 'flex' : 'none';
                    });
                }
            });
            // Allow pressing Enter in the location input to trigger Get Forecast
            try {
                const wInput = document.getElementById('weatherPlace');
                if (wInput) {
                    // Mark as actively typing when user types (preserves their input during session)
                    wInput.addEventListener('input', () => {
                        window.sessionStorage.setItem('weatherInputActive', 'true');
                    });
                    wInput.addEventListener('keydown', (ev) => {
                        if (ev.key === 'Enter') {
                            ev.preventDefault();
                            try { getWeather(); } catch(e) { /* ignore */ }
                        }
                    });
                }
            } catch(e) { /* ignore */ }
        });

        function saveRule() {
            const ruleId = document.getElementById('ruleId').value;
            const ruleName = document.getElementById('ruleName').value.trim();
            
            // Validate rule name
            if (!ruleName) {
                alert('❌ Please enter a rule name');
                return;
            }
            if (ruleName.length < 3) {
                alert('❌ Rule name must be at least 3 characters');
                return;
            }
            if (ruleName.length > 100) {
                alert('❌ Rule name must be less than 100 characters');
                return;
            }
            
            // Validate at least one condition is enabled
            const condPriceEnabled = document.getElementById('condPriceEnabled').checked;
            const condSoCEnabled = document.getElementById('condSoCEnabled').checked;
            const condTempEnabled = document.getElementById('condTempEnabled').checked;
            const condWeatherEnabled = document.getElementById('condWeatherEnabled').checked;
            const condTimeEnabled = document.getElementById('condTimeEnabled').checked;
            
            if (!condPriceEnabled && !condSoCEnabled && !condTempEnabled && !condWeatherEnabled && !condTimeEnabled) {
                alert('❌ Please enable at least one condition');
                return;
            }
            
            // Validate enabled conditions
            if (condPriceEnabled) {
                const priceValue = parseFloat(document.getElementById('condPriceValue').value);
                const priceOp = document.getElementById('condPriceOp').value;
                const priceValue2 = parseFloat(document.getElementById('condPriceValue2').value);
                
                if (isNaN(priceValue) || priceValue < 0 || priceValue > 100) {
                    alert('❌ Price value must be between 0 and 100 ¢');
                    document.getElementById('condPriceValue').focus();
                    return;
                }
                if (priceOp === 'between') {
                    if (isNaN(priceValue2) || priceValue2 < 0 || priceValue2 > 100) {
                        alert('❌ Price range end value must be between 0 and 100 ¢');
                        document.getElementById('condPriceValue2').focus();
                        return;
                    }
                    if (priceValue >= priceValue2) {
                        alert('❌ Price range: first value must be less than second value');
                        return;
                    }
                }
            }
            
            if (condSoCEnabled) {
                const socValue = parseInt(document.getElementById('condSoCValue').value);
                const socOp = document.getElementById('condSoCOp').value;
                const socValue2 = parseInt(document.getElementById('condSoCValue2').value);
                
                if (isNaN(socValue) || socValue < 0 || socValue > 100) {
                    alert('❌ SoC value must be between 0% and 100%');
                    document.getElementById('condSoCValue').focus();
                    return;
                }
                if (socOp === 'between') {
                    if (isNaN(socValue2) || socValue2 < 0 || socValue2 > 100) {
                        alert('❌ SoC range end value must be between 0% and 100%');
                        document.getElementById('condSoCValue2').focus();
                        return;
                    }
                    if (socValue >= socValue2) {
                        alert('❌ SoC range: first value must be less than second value');
                        return;
                    }
                }
            }
            
            if (condTempEnabled) {
                const tempValue = parseInt(document.getElementById('condTempValue').value);
                const tempOp = document.getElementById('condTempOp').value;
                const tempValue2 = parseInt(document.getElementById('condTempValue2').value);
                
                if (isNaN(tempValue) || tempValue < -20 || tempValue > 80) {
                    alert('❌ Temperature must be between -20°C and 80°C');
                    document.getElementById('condTempValue').focus();
                    return;
                }
                if (tempOp === 'between') {
                    if (isNaN(tempValue2) || tempValue2 < -20 || tempValue2 > 80) {
                        alert('❌ Temperature range end must be between -20°C and 80°C');
                        document.getElementById('condTempValue2').focus();
                        return;
                    }
                    if (tempValue >= tempValue2) {
                        alert('❌ Temperature range: first value must be less than second value');
                        return;
                    }
                }
            }
            
            // Validate time window if enabled
            if (condTimeEnabled) {
                const timeStart = document.getElementById('condTimeStart').value;
                const timeEnd = document.getElementById('condTimeEnd').value;
                
                if (!timeStart || !timeEnd) {
                    alert('❌ Please set both start and end times for time window');
                    return;
                }
                if (timeStart >= timeEnd) {
                    alert('❌ Start time must be before end time');
                    return;
                }
            }
            
            // Validate action fields
            const actionWorkMode = document.getElementById('actionWorkMode').value;
            const actionMinSoC = document.getElementById('actionMinSoC').value;
            const actionMaxSoC = document.getElementById('actionMaxSoC').value;
            const actionFdPwr = document.getElementById('actionFdPwr').value;
            
            if (!actionWorkMode && !actionMinSoC && !actionMaxSoC && !actionFdPwr) {
                alert('❌ Please configure at least one action (Work Mode or settings)');
                return;
            }
            
            if (actionMinSoC) {
                const minSoC = parseInt(actionMinSoC);
                if (isNaN(minSoC) || minSoC < 0 || minSoC > 100) {
                    alert('❌ Min SoC must be between 0% and 100%');
                    document.getElementById('actionMinSoC').focus();
                    return;
                }
            }
            
            if (actionMaxSoC) {
                const maxSoC = parseInt(actionMaxSoC);
                if (isNaN(maxSoC) || maxSoC < 0 || maxSoC > 100) {
                    alert('❌ Max SoC must be between 0% and 100%');
                    document.getElementById('actionMaxSoC').focus();
                    return;
                }
            }
            
            if (actionMinSoC && actionMaxSoC) {
                const minSoC = parseInt(actionMinSoC);
                const maxSoC = parseInt(actionMaxSoC);
                if (minSoC >= maxSoC) {
                    alert('❌ Min SoC must be less than Max SoC');
                    return;
                }
            }
            
            if (actionFdPwr) {
                const fdPwr = parseInt(actionFdPwr);
                if (isNaN(fdPwr) || fdPwr < 0 || fdPwr > 10500) {
                    alert('❌ Power must be between 0W and 10500W');
                    document.getElementById('actionFdPwr').focus();
                    return;
                }
            }
            
            const rule = {
                id: ruleId || 'rule_' + Date.now(),
                name: ruleName,
                enabled: true,
                priority: parseInt(document.getElementById('rulePriority').value) || 3,
                conditions: {
                    price: {
                        enabled: document.getElementById('condPriceEnabled').checked,
                        type: document.getElementById('condPriceType').value,
                        op: document.getElementById('condPriceOp').value,
                        value: parseFloat(document.getElementById('condPriceValue').value) || null,
                        value2: parseFloat(document.getElementById('condPriceValue2').value) || null
                    },
                    soc: {
                        enabled: document.getElementById('condSoCEnabled').checked,
                        op: document.getElementById('condSoCOp').value,
                        value: parseInt(document.getElementById('condSoCValue').value) || null,
                        value2: parseInt(document.getElementById('condSoCValue2').value) || null
                    },
                    temp: {
                        enabled: document.getElementById('condTempEnabled').checked,
                        op: document.getElementById('condTempOp').value,
                        value: parseInt(document.getElementById('condTempValue').value) || null,
                        value2: parseInt(document.getElementById('condTempValue2').value) || null
                    },
                    weather: {
                        type: document.getElementById('condWeatherType').value,
                        solarOp: document.getElementById('condWeatherSolarOp').value,
                        solarValue: parseFloat(document.getElementById('condWeatherSolarValue').value) || null
                    },
                    time: {
                        enabled: document.getElementById('condTimeEnabled').checked,
                        start: document.getElementById('condTimeStart').value,
                        end: document.getElementById('condTimeEnd').value
                    }
                },
                action: {
                    workMode: document.getElementById('actionWorkMode').value || null,
                    minSoC: parseInt(document.getElementById('actionMinSoC').value) || null,
                    maxSoC: parseInt(document.getElementById('actionMaxSoC').value) || null,
                    fdPwr: parseInt(document.getElementById('actionFdPwr').value) || null
                }
            };
            
            // Update or add rule
            if (ruleId) {
                const idx = automationRules.findIndex(r => r.id === ruleId);
                if (idx !== -1) {
                    rule.enabled = automationRules[idx].enabled; // Preserve enabled state
                    automationRules[idx] = rule;
                }
            } else {
                automationRules.push(rule);
            }
            
            saveAutomationRules();
            renderRules();
            closeRuleModal();
        }

        function editRule(ruleId) {
            openRuleModal(ruleId);
        }

        function deleteRule(ruleId) {
            if (!confirm('Delete this rule?')) return;
            automationRules = automationRules.filter(r => r.id !== ruleId);
            saveAutomationRules();
            renderRules();
        }

        function toggleRuleEnabled(ruleId) {
            const rule = automationRules.find(r => r.id === ruleId);
            if (rule) {
                rule.enabled = rule.enabled === false ? true : false;
                saveAutomationRules();
                renderRules();
            }
        }

        AppShell.init({
            pageName: 'overview',
            autoMetrics: false,
            onReady: () => {
                try { TourEngine.init(window.apiClient); TourEngine.resume(); } catch(e) {}
                try { 
                    refreshDashboardCardVisibilityPreferencesForCurrentUser();
                    initializePageData(); 
                    checkAutomationStatusForScheduler(); // Check automation status for scheduler warning
                    refreshQuickControlStatus(); // Check quick control status
                } catch (err) { console.error('Failed to initialize dashboard', err); }
            }
        });

        // Re-check automation status when page becomes visible (handles toggle from another tab/page)
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                if (typeof checkAutomationStatusForScheduler === 'function') {
                    checkAutomationStatusForScheduler();
                }
                if (typeof refreshQuickControlStatus === 'function') {
                    refreshQuickControlStatus();
                }
            }
        });

        // WIP Pages visibility - Tesla & Topology Discovery (admin only)
        if (typeof window.auth !== 'undefined' && window.auth) {
            window.auth.onAuthStateChanged((user) => {
                if (user && user.email === 'sardanapalos928@hotmail.com') {
                    const teslaLink = document.getElementById('teslaNavLink');
                    const topologyLink = document.getElementById('topologyNavLink');
                    if (teslaLink) teslaLink.style.display = '';
                    if (topologyLink) topologyLink.style.display = '';
                }
            });
        }
    </script>
</body>
</html>
