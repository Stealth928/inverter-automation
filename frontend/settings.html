<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Settings - FoxESS Control</title>
    <link rel="manifest" href="/manifest.webmanifest">
    <link rel="apple-touch-icon" href="/icons/apple-touch-icon.png">
    <meta name="theme-color" content="#0d1117">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="FoxESS Automation">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="css/shared-styles.css?v=7" />
    <link rel="stylesheet" href="css/tour.css" />
    <script src="js/theme-init.js"></script>
    <!-- Firebase SDK (compat) - must load before firebase-auth.js -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="js/firebase-config.js"></script>
    <script src="js/firebase-auth.js"></script>
    <script src="js/api-client.js"></script>
    <script src="js/shared-utils.js"></script>
    <script src="js/app-shell.js?v=9"></script>
    <script src="js/tour.js?v=7"></script>
    <style>
        /* Page-specific styles */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        .page-header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--accent-blue);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .status-bar {
            background: linear-gradient(135deg, var(--accent-blue) 0%, var(--color-success-dark) 100%);
            padding: 10px 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .status-bar .info {
            display: flex;
            gap: 30px;
            align-items: center;
        }
        .status-bar .info-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .status-bar .label {
            font-size: 11px;
            color: rgba(255,255,255,0.7);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .status-bar .value {
            font-size: 18px;
            font-weight: 700;
            color: #fff;
        }
        .status-bar .actions {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 0;
            padding-top: 0;
            border-top: none;
        }
        .section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 20px;
        }
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-primary);
        }
        .section-title {
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .section-description {
            color: var(--text-secondary);
            font-size: 13px;
            margin-bottom: 20px;
        }
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        .setting-item {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            padding: 16px;
            transition: border-color 0.2s;
        }
        .setting-item:hover {
            border-color: var(--accent-blue);
        }
        .setting-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .setting-hint {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }
        .setting-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .setting-input input {
            flex: 1;
            background: var(--bg-input);
            border: 1px solid var(--border-primary);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            transition: border-color 0.2s;
        }
        .setting-input input:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px var(--accent-blue-bg);
        }
        .setting-input input[style*="border-color: #f85149"] {
            background-color: var(--color-danger-bg);
            border-color: var(--color-danger) !important;
        }
        .setting-input input[style*="border-color: #f85149"]:focus {
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--color-danger) 20%, transparent);
        }
        }
        .setting-input .unit {
            color: var(--text-secondary);
            font-size: 13px;
            min-width: 60px;
        }
        .setting-input .time-display {
            color: var(--color-success);
            font-size: 12px;
            font-weight: 500;
            background: var(--color-success-bg);
            padding: 4px 8px;
            border-radius: 4px;
            min-width: 60px;
            text-align: center;
        }
        .alert {
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
        }
        .alert-info {
            background: var(--color-info-bg);
            border: 1px solid color-mix(in srgb, var(--accent-blue) 30%, transparent);
            color: var(--accent-blue);
        }
        .alert-warning {
            background: var(--color-warning-bg);
            border: 1px solid color-mix(in srgb, var(--color-warning) 30%, transparent);
            color: var(--color-warning);
        }
        .alert-success {
            background: var(--color-success-bg);
            border: 1px solid color-mix(in srgb, var(--color-success-dark) 30%, transparent);
            color: var(--color-success);
        }
        .badge {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }
        .badge-sync {
            background: color-mix(in srgb, var(--accent-blue) 20%, transparent);
            color: var(--accent-blue);
        }
        .badge-modified {
            background: color-mix(in srgb, var(--color-warning) 20%, transparent);
            color: var(--color-warning);
        }
        .actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid var(--border-primary);
        }
        .spinner {
            border: 2px solid color-mix(in srgb, var(--accent-blue) 20%, transparent);
            border-top: 2px solid var(--accent-blue);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 0.8s linear infinite;
            display: inline-block;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden {
            display: none;
        }
        /* FAQ Styles */
        .faq-section {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid var(--border-primary);
        }
        .faq-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: var(--accent-blue);
            font-size: 13px;
            font-weight: 500;
            padding: 8px 0;
            user-select: none;
            transition: color 0.2s ease;
        }
        .faq-toggle:hover {
            color: var(--accent-blue-hover);
        }
        .faq-toggle .arrow {
            transition: transform 0.2s ease;
            font-size: 11px;
            display: inline-block;
            width: 16px;
        }
        .faq-toggle.open .arrow {
            transform: rotate(90deg);
        }
        .faq-content {
            display: none;
            margin-top: 16px;
            animation: slideDown 0.2s ease;
        }
        .faq-content.open {
            display: block !important;
        }
        .faq-item {
            background: var(--bg-input);
            border: 1px solid var(--bg-secondary);
            border-radius: 8px;
            padding: 14px 16px;
            margin-bottom: 10px;
            transition: all 0.2s ease;
            display: block !important;
        }
        .faq-item:hover {
            background: color-mix(in srgb, var(--bg-primary) 80%, transparent);
            border-color: var(--border-primary);
        }
        .faq-question {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            display: block;
            overflow: visible !important;
            max-height: none !important;
            text-overflow: clip;
            white-space: normal;
        }
        .faq-question::before {
            content: '‚ùì ';
            font-size: 12px;
            margin-right: 4px;
        }
        .faq-answer {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-left: 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
            display: block !important;
            padding-top: 10px;
        }
        .faq-answer code {
            background: var(--bg-secondary);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: var(--color-terminal-text);
        }
        .faq-tip {
            background: var(--color-success-bg);
            border-left: 3px solid var(--color-success-dark);
            padding: 10px 12px;
            margin-top: 8px;
            border-radius: 0 6px 6px 0;
            font-size: 12px;
            color: var(--color-success);
        }
        .faq-tip::before {
            content: 'üí° ';
        }
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-8px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        /* Curtailment Toggle Button */
        .curtailment-toggle {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 12px 18px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: 2px solid var(--border-primary);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            transition: all 0.2s ease;
            min-width: 180px;
        }
        .curtailment-toggle:hover {
            border-color: var(--accent-blue);
            background: var(--border-primary);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(88, 166, 255, 0.15);
        }
        .curtailment-toggle:active {
            transform: translateY(0);
        }
        .curtailment-toggle.active {
            background: var(--gradient-success);
            border-color: var(--color-success-dark);
            color: #fff;
            box-shadow: 0 4px 12px rgba(35, 134, 54, 0.25);
        }
        .curtailment-toggle.active:hover {
            filter: brightness(1.1);
            border-color: var(--color-success-dark);
            box-shadow: 0 8px 24px color-mix(in srgb, var(--color-success-dark) 35%, transparent);
        }
        .curtailment-icon {
            font-size: 16px;
            display: inline-block;
            transition: transform 0.3s ease;
        }
        .curtailment-toggle.active .curtailment-icon {
            transform: rotate(180deg);
        }
        .curtailment-state {
            display: inline-block;
            min-width: 70px;
            text-align: left;
        }

        @media (max-width: 768px) {
            .container {
                padding: 12px;
            }

            .status-bar {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }

            .status-bar .info {
                gap: 12px;
                flex-wrap: wrap;
                justify-content: space-between;
            }

            .status-bar .actions {
                width: 100%;
                flex-wrap: wrap;
            }

            .status-bar .actions .btn-primary,
            .status-bar .actions .btn-secondary {
                flex: 1 1 calc(50% - 4px);
                min-width: 0;
                white-space: normal;
            }

            .section-header {
                flex-wrap: wrap;
                align-items: flex-start;
                gap: 10px;
            }

            .section-header button {
                max-width: 100%;
                white-space: normal;
            }

            .setting-input {
                flex-wrap: wrap;
            }

            .setting-input input {
                min-width: 0;
                width: 100%;
            }

            .setting-input .unit,
            .setting-input .time-display {
                min-width: 0;
            }

            .actions {
                flex-wrap: wrap;
                justify-content: stretch;
            }

            .actions .btn-primary,
            .actions .btn-secondary {
                flex: 1 1 100%;
                min-width: 0;
                white-space: normal;
            }
        }
    </style>
</head>
<body>
    <nav class="nav-main">
        <button type="button" class="nav-toggle" data-nav-toggle="1" aria-label="Toggle navigation menu" aria-expanded="false">‚ò∞</button>
        <div class="nav-links">
            <a href="/" class="nav-link">üè† Overview</a>
            <a href="/roi.html" class="nav-link">üí≤ Automation ROI</a>
            <a href="/test.html" class="nav-link">üß™ Automation Lab</a>
            <a href="/history.html" class="nav-link">üìä Reports</a>
            <a href="/control.html" class="nav-link">üéÆ Controls</a>
            <a href="/settings.html" class="nav-link">‚öôÔ∏è Settings</a>
            <a href="/curtailment-discovery.html" class="nav-link" id="topologyNavLink" style="display: none;">üî¨ WIP - Topology Discovery</a>
            <a href="/tesla-integration.html" class="nav-link" id="teslaNavLink" style="display: none;">‚ö° WIP - Tesla Integration</a>
            <a href="/admin.html" class="nav-link" id="adminNavLink" style="display: none;">üõ°Ô∏è Admin</a>
        </div>
        <div class="nav-right">
            <div class="nav-subtitle">Configuration Manager</div>
            <div class="user-menu" data-user-menu>
                <button class="user-avatar" type="button" data-user-avatar>
                    <span data-user-initials>?</span>
                </button>
                <div class="user-dropdown" data-user-dropdown>
                    <div class="user-dropdown-header">
                        <div class="user-name" data-user-name>Guest</div>
                        <div class="user-email" data-user-email>Not signed in</div>
                    </div>
                    <button class="user-dropdown-item" type="button" data-go-settings>‚öôÔ∏è Settings</button>
                    <button class="user-dropdown-item" type="button" data-contact-us>üí¨ Contact Us</button>
                    <button class="user-dropdown-item danger" type="button" data-signout>üö™ Sign Out</button>
                </div>
            </div>
        </div>
    </nav>

    <div class="container page-shell">
        <div class="page-header">
            <h1><span style="font-size:1.8rem">‚öôÔ∏è</span> Settings</h1>
        </div>

        <div class="status-bar">
            <div class="info">
                <div class="info-item">
                    <div class="label">Changes</div>
                    <div class="value" id="configStatus">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="label">Last Saved</div>
                    <div class="value" id="lastSaved">-</div>
                </div>
            </div>
            <div class="actions">
                <button class="btn-secondary" onclick="reloadFromServer()">üîÑ Reload from Server</button>
                <button class="btn-primary" onclick="saveAllSettings()">üíæ Save All Changes</button>
            </div>
        </div>

        <div id="messageArea"></div>

        <!-- Automation Settings -->
        <div class="section">
            <div class="section-header">
                <div>
                    <div class="section-title">
                        ü§ñ Automation Timing
                        <span class="badge badge-sync" id="automationBadge">Synced</span>
                    </div>
                </div>
                <button class="btn-secondary" onclick="resetSection('automation')">Undo Current Changes</button>
            </div>
            <div class="section-description">
                Controls how often the automation engine evaluates rules and triggers actions.
            </div>
            <div class="settings-grid">
                <div class="setting-item">
                    <div class="setting-label">Automation Cycle Interval</div>
                    <div class="setting-hint">How often automation rules are evaluated</div>
                    <div class="setting-input">
                        <input type="number" id="automation_intervalMs" data-section="automation" data-key="intervalMs" min="10000" max="300000" step="1000" value="60000">
                        <span class="unit">ms</span>
                        <span class="time-display" id="automation_intervalMs_display">= 60s</span>
                    </div>
                </div>
                <div class="setting-item">
                    <div class="setting-label">Startup Delay</div>
                    <div class="setting-hint">Delay before automation starts after server boot</div>
                    <div class="setting-input">
                        <input type="number" id="automation_startDelayMs" data-section="automation" data-key="startDelayMs" min="0" max="30000" step="1000" value="5000">
                        <span class="unit">ms</span>
                        <span class="time-display" id="automation_startDelayMs_display">= 5s</span>
                    </div>
                </div>
                <div class="setting-item">
                    <div class="setting-label">Data Gathering Timeout</div>
                    <div class="setting-hint">Max time to wait for API responses during automation cycle</div>
                    <div class="setting-input">
                        <input type="number" id="automation_gatherDataTimeoutMs" data-section="automation" data-key="gatherDataTimeoutMs" min="5000" max="30000" step="1000" value="8000">
                        <span class="unit">ms</span>
                        <span class="time-display" id="automation_gatherDataTimeoutMs_display">= 8s</span>
                    </div>
                </div>
            </div>
            <div class="faq-section">
                <div class="faq-toggle" onclick="toggleFaq(this)">
                    <span class="arrow">‚ñ∂</span> Frequently Asked Questions
                </div>
                <div class="faq-content">
                    <div class="faq-item">
                        <div class="faq-question">What's the best cycle interval for my setup?</div>
                        <div class="faq-answer">
                            For most users, <code>60 seconds</code> is ideal. This balances responsiveness with API rate limits. 
                            If you have time-sensitive price rules, try <code>30 seconds</code>. For battery longevity, <code>120 seconds</code> reduces switching frequency.
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">Why would I change the startup delay?</div>
                        <div class="faq-answer">
                            The startup delay gives your network and external APIs time to stabilize after a server restart. 
                            Increase it if you see errors on boot. Set to <code>0</code> if automation should start immediately.
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">What happens if the data gathering times out?</div>
                        <div class="faq-answer">
                            If APIs don't respond within this timeout, the automation cycle skips that data source and uses cached values. 
                            Increase this if you have a slow internet connection or see frequent timeout warnings in logs.
                            <div class="faq-tip">Check the Logging section and set level to "Debug" to see detailed timeout information.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Blackout Windows (Advanced) -->
        <div class="section">
            <div class="section-header">
                <div>
                    <div class="section-title">
                        üåô Automation Blackout Windows
                        <span class="badge badge-sync" id="blackoutBadge">Synced</span>
                    </div>
                </div>
                <button class="btn-secondary" onclick="addBlackoutWindow()">‚ûï Add Window</button>
            </div>
            <div class="section-description">
                Time periods when automation is paused. Useful for maintenance, peak tariffs, or overnight periods.
            </div>
            <div id="blackoutWindowsList" style="margin-top:16px">
                <!-- Blackout windows will be rendered here -->
                <div style="color:var(--text-secondary);font-size:13px;text-align:center;padding:20px">No blackout windows configured</div>
            </div>
            <div class="faq-section">
                <div class="faq-toggle" onclick="toggleFaq(this)">
                    <span class="arrow">‚ñ∂</span> Frequently Asked Questions
                </div>
                <div class="faq-content">
                    <div class="faq-item">
                        <div class="faq-question">When would I use a blackout window?</div>
                        <div class="faq-answer">
                            Common use cases include:<br>
                            ‚Ä¢ <strong>Overnight quiet hours</strong> ‚Äî Pause automation from 11pm-6am when you don't want mode changes<br>
                            ‚Ä¢ <strong>Scheduled maintenance</strong> ‚Äî Temporarily disable automation during system updates<br>
                            ‚Ä¢ <strong>Peak demand events</strong> ‚Äî Prevent discharge during grid emergencies when you want to keep battery full
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">Do blackout windows work overnight (crossing midnight)?</div>
                        <div class="faq-answer">
                            Yes! A window from <code>22:00</code> to <code>06:00</code> correctly spans midnight. 
                            The system understands that the end time is on the following day.
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">What happens during a blackout window?</div>
                        <div class="faq-answer">
                            Automation cycles are completely skipped ‚Äî no rules are evaluated and no actions are taken. 
                            Your inverter continues running in whatever mode it was in before the blackout started.
                            <div class="faq-tip">Active scheduler segments from before the blackout will continue running until they expire naturally.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Solar Curtailment -->
        <div class="section">
            <div class="section-header">
                <div>
                    <div class="section-title">
                        ‚òÄÔ∏è Solar Curtailment
                        <span class="badge badge-sync" id="curtailmentBadge">Synced</span>
                    </div>
                </div>
            </div>
            <div class="section-description">
                Automatically reduce export power to 0 when feed-in price falls below your threshold. Prevents negative revenue during low or negative price periods.
            </div>
            <div class="settings-grid">
                <div class="setting-item">
                    <div class="setting-label">Solar Curtailment Status</div>
                    <div class="setting-hint" id="curtailmentStatusHint">Click to enable automatic export control</div>
                    <div class="setting-input">
                        <button type="button" id="curtailment_enabled" class="curtailment-toggle btn-secondary" onclick="toggleCurtailmentButton(this)">
                            <span class="curtailment-icon">‚öôÔ∏è</span>
                            <span class="curtailment-state">Disabled</span>
                        </button>
                    </div>
                </div>
                <div class="setting-item">
                    <div class="setting-label">Price Threshold (cents/kWh)</div>
                    <div class="setting-hint">Curtail solar export when feed-in price drops below this value. Range: -999 to +999 cents/kWh. Default: 0 (curtail when price ‚â§ 0)</div>
                    <div class="setting-input">
                        <input type="number" id="curtailment_priceThreshold" placeholder="0" step="0.1" style="width: 120px;" onchange="updateCurtailmentChanges()">
                        <span style="margin-left: 8px; color: var(--text-secondary);">cents/kWh</span>
                    </div>
                </div>
            </div>
            
            <!-- Manual Override Controls -->
            <div class="faq-section" style="margin-top: 16px;">
                <div class="faq-toggle" onclick="toggleFaq(this)">
                    <span class="arrow">‚ñ∂</span> üõ†Ô∏è Manual Override (Advanced)
                </div>
                <div class="faq-content">
                    <div style="padding: 12px; background: rgba(255, 212, 59, 0.08); border: 1px solid rgba(255, 212, 59, 0.3); border-radius: 8px; margin-bottom: 16px;">
                        <div style="font-size: 13px; color: var(--color-warning); font-weight: 600; margin-bottom: 6px;">‚ö†Ô∏è Last Resort Tool</div>
                        <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
                            Use these controls only if curtailment automation fails or your inverter gets stuck at 0W export. 
                            These directly query and modify inverter settings, bypassing normal automation.
                        </div>
                    </div>
                    
                    <div class="settings-grid" style="margin-bottom: 16px;">
                        <div class="setting-item">
                            <div class="setting-label">Current Export Limit</div>
                            <div class="setting-hint">Read the current ExportLimit setting from your inverter</div>
                            <div class="setting-input" style="display: flex; gap: 8px; align-items: center;">
                                <button type="button" class="btn-secondary" onclick="event.preventDefault(); readExportLimit(); return false;" style="padding: 8px 14px;">
                                    üëÅÔ∏è Read Current
                                </button>
                                <span id="currentExportLimit" style="font-size: 13px; color: var(--text-secondary); font-weight: 500;">‚Äî</span>
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="setting-label">Force Set Export Limit</div>
                            <div class="setting-hint">Manually set ExportLimit value (0 = curtailed, 12000 = normal)</div>
                            <div class="setting-input" style="display: flex; gap: 8px; align-items: center;">
                                <input type="number" id="manualExportLimit" placeholder="12000" min="0" max="12000" step="1000" style="width: 100px;" value="12000">
                                <span style="margin-left: 2px; color: var(--text-secondary); font-size: 12px;">W</span>
                                <button type="button" class="btn-danger" onclick="event.preventDefault(); forceSetExportLimit(); return false;" style="padding: 8px 14px; margin-left: 4px;">
                                    üîß Force Set
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div style="padding: 10px; background: rgba(88, 166, 255, 0.08); border-radius: 6px; font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
                        <strong style="color: var(--accent-blue-hover);">üí° Quick Actions:</strong><br>
                        ‚Ä¢ Set to <strong>12000W</strong> to restore normal solar export<br>
                        ‚Ä¢ Set to <strong>0W</strong> to manually curtail export<br>
                        ‚Ä¢ Always read current value first to verify state
                    </div>
                </div>
            </div>
            
            <div class="faq-section">
                <div class="faq-toggle" onclick="toggleFaq(this)">
                    <span class="arrow">‚ñ∂</span> How Solar Curtailment Works
                </div>
                <div class="faq-content">
                    <div class="faq-item">
                        <div class="faq-question">When does curtailment activate?</div>
                        <div class="faq-answer">
                            During each automation cycle (every 1 minute by default), the system checks if:<br>
                            ‚Ä¢ Curtailment is enabled<br>
                            ‚Ä¢ Current feed-in price is below your threshold<br>
                            If both conditions are met, export power is set to 0 watts.
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">When does it restore normal operation?</div>
                        <div class="faq-answer">
                            When the feed-in price rises above your threshold, export power is automatically restored to 12000 watts (normal operation).
                            The system tracks state to avoid sending redundant commands to your inverter.
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">How does this interact with automation rules?</div>
                        <div class="faq-answer">
                            Curtailment runs AFTER automation rules in each cycle. If a rule updates your scheduler segments, 
                            curtailment will execute afterward. Both can operate in the same cycle without conflict.
                            <div class="faq-tip">Curtailment failures won't affect your automation rules ‚Äî they execute independently.</div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">What if curtailment fails?</div>
                        <div class="faq-answer">
                            If the system can't update export power (e.g., inverter offline, API error), an alert will appear on your dashboard. 
                            The automation cycle continues normally ‚Äî curtailment errors don't disrupt rule execution.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Credentials (FoxESS / Amber) -->
        <div class="section">
            <div class="section-header">
                <div>
                    <div class="section-title">
                        üîë Credentials
                        <span class="badge badge-sync" id="credentialsBadge">Synced</span>
                    </div>
                </div>
                <div>
                    <button class="btn-secondary" onclick="loadCredentials()">Reload</button>
                </div>
            </div>
            <div class="section-description">
                Configure your FoxESS device serial number, FoxESS API token, and Amber API key. Tokens are not shown by default for security ‚Äî enter them when you want to update them.
            </div>
            <div class="settings-grid">
                <div class="setting-item">
                    <div class="setting-label">FoxESS Device Serial Number</div>
                    <div class="setting-hint">The serial number of your inverter (visible in FoxESS Cloud)</div>
                    <div class="setting-input">
                        <input type="text" id="credentials_deviceSn" placeholder="e.g., AFTWXK7A123456">
                    </div>
                </div>

                <form id="credentials-form">
                    <div class="setting-item">
                        <div class="setting-label">FoxESS API Token</div>
                        <div class="setting-hint">Enter a FoxESS API token to allow the server to talk to your inverter (kept hidden)</div>
                        <div class="setting-input">
                            <input type="password" id="credentials_foxessToken" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢ (leave blank to keep current)" autocomplete="new-password">
                            <button type="button" class="btn-secondary" id="credentials_toggleFoxess">Show</button>
                        </div>
                    </div>

                    <div class="setting-item">
                        <div class="setting-label">Amber API Key (optional)</div>
                        <div class="setting-hint">Optional API key for Amber electricity pricing (used for automation)</div>
                        <div class="setting-input">
                            <input type="password" id="credentials_amberKey" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢ (optional)" autocomplete="new-password">
                            <button type="button" class="btn-secondary" id="credentials_toggleAmber">Show</button>
                        </div>
                    </div>
                </form>
            </div>

            <div style="margin-top:16px;display:flex;gap:10px;align-items:center">
                <button class="btn-primary" onclick="saveCredentials()" id="credentialsSaveBtn">üíæ Save Credentials</button>
                <button class="btn-secondary" onclick="clearCredentials()">üßπ Clear Credentials</button>
                <div style="margin-left:12px;color:var(--muted);font-size:13px" id="credentialsStatus">Checking...</div>
            </div>
        </div>

        <!-- Preferences (Weather, etc.) -->
        <div class="section" id="preferences">
            <div class="section-header">
                <div>
                    <div class="section-title">
                        üå§Ô∏è Preferences
                        <span class="badge badge-sync" id="preferencesBadge">Synced</span>
                    </div>
                </div>
            </div>
            <div class="section-description">
                Configure your personal preferences for the dashboard, including default weather location. The location also sets the <strong>timezone</strong> used by automation rules.
            </div>
            <div class="settings-grid">
                <div class="setting-item">
                    <div class="setting-label">Default Weather Location <span style="font-size:11px;color:var(--color-orange);font-weight:400">¬∑ sets timezone</span></div>
                    <div class="setting-hint">City and country for local weather forecasts (e.g., "Sydney, Australia") ‚Äî also determines the timezone used by all automation rules</div>
                    <div class="setting-input">
                        <input type="text" id="preferences_weatherPlace" data-section="preferences" data-key="weatherPlace" placeholder="e.g., Sydney, Australia" disabled>
                    </div>
                </div>
                <div class="setting-item">
                    <div class="setting-label">Default Forecast Days</div>
                    <div class="setting-hint">Number of days to display in weather forecast (1-16)</div>
                    <div class="setting-input">
                        <input type="number" id="preferences_forecastDays" data-section="preferences" data-key="forecastDays" min="1" max="16" step="1" disabled>
                        <span class="unit">days</span>
                    </div>
                </div>
            </div>
            <div class="faq-section">
                <div class="faq-toggle" onclick="toggleFaq(this)">
                    <span class="arrow">‚ñ∂</span> Frequently Asked Questions
                </div>
                <div class="faq-content">
                    <div class="faq-item">
                        <div class="faq-question">Why is weather location important?</div>
                        <div class="faq-answer">
                            Your weather location determines the local timezone, sunrise/sunset times, and cloud cover forecasts ‚Äî all critical for solar production predictions. 
                            Getting the location correct ensures automation reacts appropriately to local weather conditions. For example, a forecast heavy rain in your area 
                            will reduce solar output and might trigger battery discharge modes to maximize export during remaining sunny hours.
                            <div class="faq-tip">Use the format "City, Country" (e.g., "Sydney, Australia" or "Melbourne, Australia") for best results.</div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">How does location affect my automation rules?</div>
                        <div class="faq-answer">
                            Location determines the actual sunrise/sunset times and cloud cover for your area. If you set a rule like "Discharge during peak export hours",
                            the system uses your location to calculate when peak sun is expected. Wrong location = wrong time windows = suboptimal discharge timing.
                            Additionally, timezone information from your location is used to align with local electricity markets (e.g., Amber pricing in Australia uses local times).
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">What happens if I change my location?</div>
                        <div class="faq-answer">
                            The system will fetch new weather data for the new location on the next update cycle. Historical weather data for the old location is discarded,
                            and your weather cache resets. Automation rules will immediately start using the new sunrise/sunset times and timezone. No manual adjustment needed.
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">Why does weather data cache for 30 minutes?</div>
                        <div class="faq-answer">
                            Weather forecasts typically update hourly from data providers. A <code>30 minute</code> cache reduces unnecessary API calls while keeping your forecast fresh enough
                            for automation decisions. Shorter caching would hit rate limits; longer caching might miss rapid weather changes like sudden cloud cover.
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">Can I use coordinates instead of a city name?</div>
                        <div class="faq-answer">
                            Currently, the system accepts location names (e.g., "Sydney, Australia"). The weather provider resolves the name to coordinates internally. 
                            Using specific addresses or coordinates isn't supported, but city/state is precise enough for weather forecasting.
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">How many forecast days should I use?</div>
                        <div class="faq-answer">
                            <code>6 days</code> (default) is ideal for most users ‚Äî it's enough to plan weekly without overwhelming the UI. If you want to see longer-term trends,
                            increase to <code>10-16 days</code>. For real-time operation focused on today/tomorrow, reduce to <code>2-3 days</code>.
                            <div class="faq-tip">More forecast days = slightly slower dashboard load times. Balance visibility with performance.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- System Hardware -->
        <div class="section">
            <div class="section-header">
                <div>
                    <div class="section-title">
                        üí™ System Hardware
                        <span class="badge badge-sync" id="hardwareBadge">Synced</span>
                    </div>
                </div>
            </div>
            <div class="section-description">
                Your inverter and battery specifications. These values are used throughout the app for power limits, energy estimates, and time-to-full/empty calculations.
            </div>
            <div class="settings-grid">
                <div class="setting-item">
                    <div class="setting-label">Inverter Capacity</div>
                    <div class="setting-hint">Rated output power of your inverter (sets the maximum for charge/discharge controls)</div>
                    <div class="setting-input">
                        <input type="number" id="hardware_inverterCapacityKw" min="1" max="30" step="0.5" value="10">
                        <span class="unit">kW</span>
                    </div>
                </div>
                <div class="setting-item">
                    <div class="setting-label">Battery Capacity</div>
                    <div class="setting-hint">Usable energy capacity of your battery pack (used for time-to-full/empty estimates on the dashboard)</div>
                    <div class="setting-input">
                        <input type="number" id="hardware_batteryCapacityKwh" min="1" max="500" step="0.01" value="41.93">
                        <span class="unit">kWh</span>
                    </div>
                </div>
            </div>
            <div class="faq-section">
                <div class="faq-toggle" onclick="toggleFaq(this)">
                    <span class="arrow">‚ñ∂</span> Frequently Asked Questions
                </div>
                <div class="faq-content">
                    <div class="faq-item">
                        <div class="faq-question">Where do I find my inverter capacity?</div>
                        <div class="faq-answer">
                            Check the nameplate on your inverter or its datasheet. For FoxESS inverters it is labelled <em>Rated AC Output Power</em>. Common sizes are 5, 8, 10, 12 and 15 kW.
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">What is usable battery capacity?</div>
                        <div class="faq-answer">
                            Usable capacity is the energy available between the minimum and maximum state-of-charge limits (often 10%‚Äì90% of rated capacity). For a 50 kWh pack at 10‚Äì90%, usable = 80% &times; 50 = 40 kWh. Check your battery's technical spec sheet.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Cache Settings -->
        <div class="section">
            <div class="section-header">
                <div>
                    <div class="section-title">
                        üíæ Cache & Refresh Intervals
                        <span class="badge badge-sync" id="cacheBadge">Synced</span>
                    </div>
                </div>
                <button class="btn-secondary" onclick="resetSection('cache')">Undo Current Changes</button>
            </div>
            <div class="section-description">
                Configure how long data is cached before refreshing from external APIs. Longer intervals reduce API calls.
            </div>
            <div class="settings-grid">
                <div class="setting-item">
                    <div class="setting-label">Amber Prices Cache</div>
                    <div class="setting-hint">Amber pricing data refresh interval</div>
                    <div class="setting-input">
                        <input type="number" id="cache_amber" data-section="cache" data-key="amber" min="30000" max="300000" step="5000" value="60000">
                        <span class="unit">ms</span>
                        <span class="time-display" id="cache_amber_display">= 60s</span>
                    </div>
                </div>
                <div class="setting-item">
                    <div class="setting-label">Inverter Data Cache</div>
                    <div class="setting-hint">FoxESS inverter data refresh interval (respect rate limits)</div>
                    <div class="setting-input">
                        <input type="number" id="cache_inverter" data-section="cache" data-key="inverter" min="60000" max="600000" step="30000" value="300000">
                        <span class="unit">ms</span>
                        <span class="time-display" id="cache_inverter_display">= 5m</span>
                    </div>
                </div>
                <div class="setting-item">
                    <div class="setting-label">Weather Data Cache</div>
                    <div class="setting-hint">Weather forecast refresh interval</div>
                    <div class="setting-input">
                        <input type="number" id="cache_weather" data-section="cache" data-key="weather" min="300000" max="3600000" step="300000" value="1800000">
                        <span class="unit">ms</span>
                        <span class="time-display" id="cache_weather_display">= 30m</span>
                    </div>
                </div>
            </div>
            <div class="faq-section">
                <div class="faq-toggle" onclick="toggleFaq(this)">
                    <span class="arrow">‚ñ∂</span> Frequently Asked Questions
                </div>
                <div class="faq-content">
                    <div class="faq-item">
                        <div class="faq-question">Why can't I set the inverter cache below 60 seconds?</div>
                        <div class="faq-answer">
                            FoxESS Cloud API has rate limits. Polling too frequently can get your API key temporarily blocked or cause errors. 
                            <code>5 minutes</code> is the recommended minimum to stay well within limits while keeping data reasonably fresh.
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">How does caching affect my automation rules?</div>
                        <div class="faq-answer">
                            Automation rules use cached data when making decisions. Shorter cache times mean more up-to-date data but more API calls.
                            For price-based rules, <code>60 seconds</code> Amber cache ensures you react quickly to price changes.
                            <div class="faq-tip">Balance responsiveness with API usage ‚Äî aggressive caching can hit rate limits during busy periods.</div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">Why is weather cache so long (30 minutes)?</div>
                        <div class="faq-answer">
                            Weather forecasts don't change frequently and the data is typically updated hourly by providers. 
                            A <code>30 minute</code> cache is sufficient for solar production estimates while minimizing unnecessary API calls.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Default Rule Settings -->
        <div class="section">
            <div class="section-header">
                <div>
                    <div class="section-title">
                        üìã Automation Rule Defaults
                        <span class="badge badge-sync" id="defaultsBadge">Synced</span>
                    </div>
                </div>
                <button class="btn-secondary" onclick="resetSection('defaults')">Undo Current Changes</button>
            </div>
            <div class="section-description">
                Default values used when creating new automation rules. Existing rules are not affected.
            </div>
            <div class="settings-grid">
                <div class="setting-item">
                    <div class="setting-label">Default Cooldown</div>
                    <div class="setting-hint">Minimum time between rule triggers</div>
                    <div class="setting-input">
                        <input type="number" id="defaults_cooldownMinutes" data-section="defaults" data-key="cooldownMinutes" min="0" max="60" step="1" value="5">
                        <span class="unit">minutes</span>
                    </div>
                </div>
                <div class="setting-item">
                    <div class="setting-label">Default Duration</div>
                    <div class="setting-hint">How long scheduler segments run</div>
                    <div class="setting-input">
                        <input type="number" id="defaults_durationMinutes" data-section="defaults" data-key="durationMinutes" min="5" max="120" step="5" value="30">
                        <span class="unit">minutes</span>
                    </div>
                </div>
                <div class="setting-item">
                    <div class="setting-label">Default Power</div>
                    <div class="setting-hint">Battery charge/discharge power setting</div>
                    <div class="setting-input">
                        <input type="number" id="defaults_fdPwr" data-section="defaults" data-key="fdPwr" min="1000" max="10000" step="500" value="5000">
                        <span class="unit">watts</span>
                    </div>
                </div>
            </div>
            <div class="faq-section">
                <div class="faq-toggle" onclick="toggleFaq(this)">
                    <span class="arrow">‚ñ∂</span> Frequently Asked Questions
                </div>
                <div class="faq-content">
                    <div class="faq-item">
                        <div class="faq-question">What is the cooldown and why does it matter?</div>
                        <div class="faq-answer">
                            Cooldown prevents a rule from triggering repeatedly in quick succession. For example, if prices fluctuate around your threshold, 
                            a <code>5 minute</code> cooldown prevents the rule from toggling on/off every cycle. This protects your battery from excessive cycling.
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">How does duration affect my scheduler?</div>
                        <div class="faq-answer">
                            When a rule triggers, it creates a scheduler segment lasting this many minutes. After the duration expires, the inverter returns to its default mode.
                            <code>30 minutes</code> is a good balance for most price arbitrage scenarios.
                            <div class="faq-tip">Set shorter durations (15-20 min) if prices change frequently, longer (45-60 min) for more stable pricing periods.</div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <div class="faq-question">What power setting should I use?</div>
                        <div class="faq-answer">
                            This controls how fast your battery charges/discharges. <code>5000W</code> is typical for most home setups.
                            Lower values (3000W) are gentler on the battery; higher values (7000-10000W) maximize throughput but increase wear.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="actions">
            <!-- Factory Reset button removed for safety -->
            <button class="btn-secondary" onclick="loadSettings()">üîÑ Reload from Server</button>
            <button class="btn-primary" onclick="saveAllSettings()">üíæ Save All Changes</button>
        </div>
    </div>

    <script>
        // Settings page loaded
        let currentConfig = {};
        let originalConfig = {};
        let hasUnsavedChanges = false;
        let originalCredentials = {}; // Track original credential values separately
        
        // apiClient is declared in api-client.js and initialized after Firebase auth is ready

        /**
         * Helper function to make authenticated API calls.
         * Uses apiClient.fetch to include the Authorization header and normalize responses.
         */
        async function authenticatedFetch(url, options = {}) {
            if (window.AppShell && typeof AppShell.authFetch === 'function') {
                return AppShell.authFetch(url, options);
            }
            try {
                if (typeof waitForAPIClient === 'function') {
                    await waitForAPIClient(3000);
                } else {
                    const start = Date.now();
                    while (!apiClient && (Date.now() - start) < 3000) {
                        await new Promise(r => setTimeout(r, 50));
                    }
                }
            } catch (e) {
                console.warn('[API] apiClient not initialized yet');
                throw new Error('API client not ready');
            }
            return apiClient.fetch(url, options);
        }

        AppShell.init({
            pageName: 'settings',
            onReady: () => {
                try { TourEngine.init(window.apiClient); TourEngine.resume(); } catch(e) {}
                try {
                    loadSettings();
                } catch (error) {
                    console.warn('[Settings] loadSettings failed to start', error);
                }
            }
        });
        
        // Toggle FAQ section visibility
        function toggleFaq(element) {
            element.classList.toggle('open');
            const content = element.nextElementSibling;
            if (content) {
                content.classList.toggle('open');
            }
        }

        // Helper to format milliseconds to human-readable
        function formatMs(ms) {
            if (ms === null || ms === undefined || isNaN(ms)) return '?';
            ms = parseInt(ms);
            if (ms < 1000) return `${ms}ms`;
            if (ms < 60000) return `${Math.round(ms/1000)}s`;
            if (ms < 3600000) return `${Math.round(ms/60000)}m`;
            return `${(ms/3600000).toFixed(1)}h`;
        }

        // Update time display for a millisecond input
        function updateTimeDisplay(inputId) {
            const input = document.getElementById(inputId);
            const display = document.getElementById(inputId + '_display');
            if (input && display) {
                display.textContent = '= ' + formatMs(input.value);
            }
        }

        // Update all time displays
        function updateAllTimeDisplays() {
            const msInputs = [
                'automation_intervalMs', 'automation_startDelayMs', 'automation_gatherDataTimeoutMs',
                'cache_amber', 'cache_inverter', 'cache_weather'
            ];
            msInputs.forEach(updateTimeDisplay);
        }

        // Helper to show messages
        function showMessage(type, message) {
            const area = document.getElementById('messageArea');
            const icon = type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            area.innerHTML = `<div class="alert alert-${type}">${icon} ${message}</div>`;
            setTimeout(() => area.innerHTML = '', 5000);
        }

        // Load current settings from server
        async function reloadFromServer() {
            try {
                showMessage('Reloading settings from server...', 'info');
                await loadSettings();
                showMessage('Settings reloaded from server successfully', 'success');
            } catch (err) {
                console.error('Error reloading settings:', err);
                showMessage('Error reloading settings: ' + err.message, 'error');
            }
        }

        async function loadSettings() {
            try {
                document.getElementById('configStatus').innerHTML = '<span class="spinner"></span> Loading...';
                
                const resp = await authenticatedFetch('/api/config?t=' + Date.now());
                // If the server responded 401, treat as unauthorized -> redirect to login after a short delay
                if (resp && resp.status === 401) {
                    console.warn('[Settings] /api/config returned 401 (unauthorized)');
                    document.getElementById('configStatus').textContent = 'Unauthorized';
                    showMessage('warning', 'Not signed in or session expired ‚Äî redirecting to login');
                    // Give the user a moment to see the message and avoid immediate bounce.
                    setTimeout(() => safeRedirect('/login.html'), 700);
                    return;
                }

                // Parse JSON safely (guard against HTML error pages or non-json responses)
                let data;
                try {
                    data = await resp.json();
                } catch (jsonErr) {
                    const text = await (typeof resp.text === 'function' ? resp.text() : Promise.resolve(String(resp)));
                    console.warn('[Settings] Received non-JSON response from /api/config:', text.substring ? text.substring(0, 300) : text);
                    document.getElementById('configStatus').textContent = 'Error';
                    showMessage('warning', 'Invalid response from server ‚Äî check network or server logs');
                    return;
                }

                if (!data || data.errno !== 0 || !data.result) {
                    // Provide clearer message rather than a thrown exception which can cause missing cleanup
                    document.getElementById('configStatus').textContent = 'Error';
                    showMessage('warning', `Failed to load configuration: ${data?.msg || 'Invalid response from server'}`);
                    return;
                }
                
                // Set current config
                currentConfig = data.result;
                
                // Debug: Log what we received to understand location field structure
                console.log('[Settings] Loaded config:', {
                    location: currentConfig.location,
                    weatherPlace: currentConfig.weatherPlace,
                    preferencesWeatherPlace: currentConfig.preferences?.weatherPlace,
                    hasConfig: !!currentConfig.config,
                    timezone: currentConfig.timezone
                });
                
                // Helper to safely set input value
                const setInput = (id, value) => {
                    const input = document.getElementById(id);
                    if (input) {
                        input.value = value;
                    }
                };
                
                // Automation
                if (currentConfig.automation) {
                    setInput('automation_intervalMs', currentConfig.automation.intervalMs);
                    setInput('automation_startDelayMs', currentConfig.automation.startDelayMs);
                    setInput('automation_gatherDataTimeoutMs', currentConfig.automation.gatherDataTimeoutMs);
                }
                
                // Cache
                if (currentConfig.cache) {
                    setInput('cache_amber', currentConfig.cache.amber);
                    setInput('cache_inverter', currentConfig.cache.inverter);
                    setInput('cache_weather', currentConfig.cache.weather);
                }
                
                // Defaults
                if (currentConfig.defaults) {
                    setInput('defaults_cooldownMinutes', currentConfig.defaults.cooldownMinutes);
                    setInput('defaults_durationMinutes', currentConfig.defaults.durationMinutes);
                    setInput('defaults_fdPwr', currentConfig.defaults.fdPwr);
                }
                
                // Preferences
                // PRIORITY: 'location' field (most recently saved) takes precedence over potentially stale preferences.weatherPlace
                // This ensures UI displays what the user just saved, not old data from mismatched fields
                if (currentConfig.location) {
                    // Location field - highest priority (this is what save writes to)
                    setInput('preferences_weatherPlace', currentConfig.location);
                    setInput('preferences_forecastDays', currentConfig.preferences?.forecastDays || 6);
                } else if (currentConfig.preferences?.weatherPlace) {
                    // Fallback: preferences.weatherPlace if location is empty
                    setInput('preferences_weatherPlace', currentConfig.preferences.weatherPlace);
                    setInput('preferences_forecastDays', currentConfig.preferences.forecastDays || 6);
                } else if (currentConfig.weatherPlace) {
                    // Fallback: weatherPlace at root level (legacy)
                    setInput('preferences_weatherPlace', currentConfig.weatherPlace);
                    setInput('preferences_forecastDays', 6);
                } else {
                    // Default fallback
                    setInput('preferences_weatherPlace', 'Sydney, Australia');
                    setInput('preferences_forecastDays', 6);
                }

                // Hardware
                setInput('hardware_inverterCapacityKw', ((currentConfig.inverterCapacityW || 10000) / 1000).toFixed(1));
                setInput('hardware_batteryCapacityKwh', currentConfig.batteryCapacityKWh || 41.93);
                // Update fdPwr max and validation rule dynamically to match user's inverter capacity
                const invCapW = currentConfig.inverterCapacityW || 10000;
                const fdPwrEl = document.getElementById('defaults_fdPwr');
                if (fdPwrEl) {
                    fdPwrEl.max = invCapW;
                    fdPwrEl.title = `Max: ${(invCapW / 1000).toFixed(1)} kW (your inverter capacity)`;
                }
                validationRules['defaults_fdPwr'].max = invCapW;
                validationRules['defaults_fdPwr'].errorMsg = `Power must be 1000‚Äì${invCapW} watts (your inverter capacity)`;

                // Credentials: populate device SN if available. Tokens are intentionally not returned by the API for security.
                try {
                    setInput('credentials_deviceSn', currentConfig.deviceSn || '');
                    // Initialize originalCredentials to reflect what we just loaded so the
                    // UI doesn't consider the credentials section "modified" by default.
                    originalCredentials.deviceSn = currentConfig.deviceSn || '';
                    originalCredentials.deviceSn = currentConfig.deviceSn || '';
                    // For credentials, store masked dots in originalCredentials to match the display
                    // The actual values are stored in the dataset for Show/Hide functionality
                    
                    // Clear credential input fields before reloading to ensure fresh state
                    const foxessInput = document.getElementById('credentials_foxessToken');
                    const amberInput = document.getElementById('credentials_amberKey');
                    if (foxessInput) foxessInput.value = '';
                    if (amberInput) amberInput.value = '';
                    
                    // Store actual credentials in a data attribute for Show/Hide functionality
                    if (foxessInput && currentConfig.foxessToken) {
                        foxessInput.dataset.actualValue = currentConfig.foxessToken;
                    }
                    if (amberInput && currentConfig.amberApiKey) {
                        amberInput.dataset.actualValue = currentConfig.amberApiKey;
                    }
                    
                    // Check presence of both FoxESS token and Amber API key via /api/health endpoint
                    try {
                        const healthResp = await authenticatedFetch('/api/health');
                        const health = await healthResp.json();
                        const credStatusEl = document.getElementById('credentialsStatus');
                        const badge = document.getElementById('credentialsBadge');
                        
                        const hasFoxess = !!(health && health.FOXESS_TOKEN);
                        const hasAmber = !!(health && health.AMBER_API_KEY);
                        
                        // Show masked placeholder in input fields to indicate credentials are saved
                        if (hasFoxess) {
                            if (foxessInput) {
                                foxessInput.value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                                originalCredentials.foxessToken = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';  // Match the display
                            }
                        } else {
                            originalCredentials.foxessToken = '';
                        }
                        
                        if (hasAmber) {
                            if (amberInput) {
                                amberInput.value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                                originalCredentials.amberKey = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';  // Match the display
                            }
                        } else {
                            originalCredentials.amberKey = '';
                        }
                        
                        if (hasFoxess && hasAmber) {
                            // Both credentials present
                            if (credStatusEl) credStatusEl.textContent = 'FoxESS token and Amber API key are present (hidden)';
                            if (badge) { badge.textContent = 'Synced'; badge.className = 'badge badge-sync'; }
                        } else if (hasFoxess && !hasAmber) {
                            // Only FoxESS present
                            if (credStatusEl) credStatusEl.textContent = 'FoxESS token is present (hidden) ‚Äî Amber API key not set';
                            if (badge) { badge.textContent = 'Synced'; badge.className = 'badge badge-sync'; }
                        } else if (!hasFoxess && hasAmber) {
                            // Only Amber present
                            if (credStatusEl) credStatusEl.textContent = 'Amber API key is present (hidden) ‚Äî FoxESS token not set';
                            if (badge) { badge.textContent = 'Synced'; badge.className = 'badge badge-sync'; }
                        } else {
                            // Neither present
                            if (credStatusEl) credStatusEl.textContent = 'No credentials detected';
                            if (badge) { badge.textContent = 'Synced'; badge.className = 'badge badge-sync'; }
                        }
                    } catch (hErr) {
                        console.warn('[Settings] Health check failed:', hErr);
                    }
                } catch (credErr) {
                    console.warn('Failed to populate credentials fields', credErr);
                }
                
                // Blackout windows
                renderBlackoutWindows(currentConfig.automation?.blackoutWindows || []);
                
                // Solar curtailment - ensure defaults are applied
                const curtailmentConfig = currentConfig.curtailment || { enabled: false, priceThreshold: 0 };
                if (currentConfig.curtailment) {
                    const enabledButton = document.getElementById('curtailment_enabled');
                    const thresholdInput = document.getElementById('curtailment_priceThreshold');
                    const isEnabled = curtailmentConfig.enabled === true;
                    
                    // Update button state
                    if (enabledButton) {
                        if (isEnabled) {
                            enabledButton.classList.add('active');
                            enabledButton.querySelector('.curtailment-state').textContent = 'Enabled';
                        } else {
                            enabledButton.classList.remove('active');
                            enabledButton.querySelector('.curtailment-state').textContent = 'Disabled';
                        }
                    }
                    
                    if (thresholdInput) {
                        thresholdInput.value = curtailmentConfig.priceThreshold !== undefined ? curtailmentConfig.priceThreshold : 0;
                    }
                } else {
                    // Initialize defaults if no curtailment config exists
                    const enabledButton = document.getElementById('curtailment_enabled');
                    const thresholdInput = document.getElementById('curtailment_priceThreshold');
                    
                    if (enabledButton) {
                        enabledButton.classList.remove('active');
                        enabledButton.querySelector('.curtailment-state').textContent = 'Disabled';
                    }
                    
                    if (thresholdInput) {
                        thresholdInput.value = 0;
                    }
                }
                
                // NOW set originalConfig to match what we just loaded (so no unsaved changes)
                originalConfig = JSON.parse(JSON.stringify(data.result));
                
                // Ensure all sections exist in originalConfig to prevent undefined errors
                if (!originalConfig.automation) originalConfig.automation = {};
                if (!originalConfig.cache) originalConfig.cache = {};
                if (!originalConfig.defaults) originalConfig.defaults = {};
                if (!originalConfig.api) originalConfig.api = {};
                if (!originalConfig.preferences) originalConfig.preferences = {};
                if (!originalConfig.curtailment) originalConfig.curtailment = { enabled: false, priceThreshold: 0 };
                
                // Fill in missing values from displayed inputs if not in server response
                // This ensures originalConfig matches what was actually displayed to the user
                if (originalConfig.automation.intervalMs === undefined || originalConfig.automation.intervalMs === null) {
                    originalConfig.automation.intervalMs = getInputValue('automation_intervalMs') || 60000;
                }
                if (originalConfig.automation.startDelayMs === undefined || originalConfig.automation.startDelayMs === null) {
                    originalConfig.automation.startDelayMs = getInputValue('automation_startDelayMs') || 5000;
                }
                if (originalConfig.automation.gatherDataTimeoutMs === undefined || originalConfig.automation.gatherDataTimeoutMs === null) {
                    originalConfig.automation.gatherDataTimeoutMs = getInputValue('automation_gatherDataTimeoutMs') || 8000;
                }
                
                if (originalConfig.cache.amber === undefined || originalConfig.cache.amber === null) {
                    originalConfig.cache.amber = getInputValue('cache_amber') || 60000;
                }
                if (originalConfig.cache.inverter === undefined || originalConfig.cache.inverter === null) {
                    originalConfig.cache.inverter = getInputValue('cache_inverter') || 300000;
                }
                if (originalConfig.cache.weather === undefined || originalConfig.cache.weather === null) {
                    originalConfig.cache.weather = getInputValue('cache_weather') || 1800000;
                }
                
                if (originalConfig.defaults.cooldownMinutes === undefined || originalConfig.defaults.cooldownMinutes === null) {
                    originalConfig.defaults.cooldownMinutes = getInputValue('defaults_cooldownMinutes') || 5;
                }
                if (originalConfig.defaults.durationMinutes === undefined || originalConfig.defaults.durationMinutes === null) {
                    originalConfig.defaults.durationMinutes = getInputValue('defaults_durationMinutes') || 30;
                }
                if (originalConfig.defaults.fdPwr === undefined || originalConfig.defaults.fdPwr === null) {
                    originalConfig.defaults.fdPwr = getInputValue('defaults_fdPwr') || 5000;
                }
                
                if (originalConfig.api.retryCount === undefined || originalConfig.api.retryCount === null) {
                    originalConfig.api.retryCount = getInputValue('api_retryCount') || 3;
                }
                if (originalConfig.api.retryDelayMs === undefined || originalConfig.api.retryDelayMs === null) {
                    originalConfig.api.retryDelayMs = getInputValue('api_retryDelayMs') || 1000;
                }
                
                if (originalConfig.preferences.forecastDays === undefined || originalConfig.preferences.forecastDays === null) {
                    originalConfig.preferences.forecastDays = getInputValue('preferences_forecastDays') || 6;
                }
                
                // Save weatherPlace to preferences (primary storage location)
                const weatherPlaceInput = document.getElementById('preferences_weatherPlace')?.value || 'Sydney, Australia';
                originalConfig.preferences.weatherPlace = weatherPlaceInput;
                // Also keep location field in sync for backward compatibility
                originalConfig.location = weatherPlaceInput;
                
                // Sync curtailment only if not already set
                if (originalConfig.curtailment.priceThreshold === undefined) {
                    const thresholdInput = document.getElementById('curtailment_priceThreshold');
                    originalConfig.curtailment.priceThreshold = thresholdInput?.value !== '' && thresholdInput?.value !== null ? parseFloat(thresholdInput.value) : 0;
                }
                
                // Enable all inputs now that data is loaded from server
                document.querySelectorAll('input, select').forEach(input => {
                    input.disabled = false;
                });
                
                updateAllTimeDisplays();
                updateStatus();
                showMessage('success', 'Configuration loaded from server');
            } catch (error) {
                console.error('loadSettings error:', error);
                document.getElementById('configStatus').textContent = 'Error';
                showMessage('warning', `Failed to load: ${error.message}`);
            }
        }

        function setInputValue(id, value) {
            const input = document.getElementById(id);
            if (input) {
                input.value = value !== undefined && value !== null ? value : '';
            }
        }

        function getInputValue(id) {
            const input = document.getElementById(id);
            return input ? parseInt(input.value) : null;
        }

        // Check for unsaved changes
        function checkForChanges() {
            // Don't check if configs aren't loaded yet
            if (!currentConfig || !originalConfig) {
                console.log('checkForChanges: configs not loaded yet');
                return false;
            }
            
            const sections = ['automation', 'cache', 'defaults', 'logging', 'api', 'preferences'];
            let hasChanges = false;
            
            // Check credentials for changes
            const credentialsChanged = checkCredentialsChanged();
            if (credentialsChanged) hasChanges = true;
            
            sections.forEach(section => {
                const badge = document.getElementById(`${section}Badge`);
                let sectionChanged = false;
                
                // Check originalConfig section (which always exists after loading)
                if (originalConfig[section]) {
                    Object.keys(originalConfig[section]).forEach(key => {
                        // Skip blackoutWindows - handled separately
                        if (key === 'blackoutWindows') return;
                        
                        const inputId = `${section}_${key}`;
                        const input = document.getElementById(inputId);
                        if (!input) return;
                        
                        // Handle different input types appropriately
                        let currentValue;
                        if (input.tagName === 'SELECT') {
                            currentValue = input.value;
                        } else if (input.type === 'number') {
                            currentValue = parseInt(input.value);
                        } else {
                            // For text inputs, use the string value as-is
                            currentValue = input.value;
                        }
                        const originalValue = originalConfig[section][key];
                        
                        if (currentValue !== originalValue) {
                            sectionChanged = true;
                            hasChanges = true;
                        }
                    });
                }
                
                if (badge) {
                    if (sectionChanged) {
                        badge.textContent = 'Modified';
                        badge.className = 'badge badge-modified';
                    } else {
                        badge.textContent = 'Synced';
                        badge.className = 'badge badge-sync';
                    }
                }
            });
            
            // Check blackout windows separately
            const currentWindows = JSON.stringify(getBlackoutWindowsFromUI());
            const originalWindows = JSON.stringify(originalConfig.automation?.blackoutWindows || []);
            if (currentWindows !== originalWindows) {
                hasChanges = true;
                const badge = document.getElementById('blackoutBadge');
                if (badge) {
                    badge.textContent = 'Modified';
                    badge.className = 'badge badge-modified';
                }
            } else {
                const badge = document.getElementById('blackoutBadge');
                if (badge) {
                    badge.textContent = 'Synced';
                    badge.className = 'badge badge-sync';
                }
            }
            
            // Check curtailment settings separately
            const enabledButton = document.getElementById('curtailment_enabled');
            const thresholdInput = document.getElementById('curtailment_priceThreshold');
            
            const currentCurtailment = {
                enabled: enabledButton?.classList.contains('active') === true,
                priceThreshold: thresholdInput?.value !== '' && thresholdInput?.value !== null ? parseFloat(thresholdInput.value) : 0
            };
            
            // Normalize original curtailment values to match current format
            const originalCurtailment = originalConfig.curtailment || { enabled: false, priceThreshold: 0 };
            const normalizedOriginal = {
                enabled: originalCurtailment.enabled === true,
                priceThreshold: originalCurtailment.priceThreshold !== undefined ? parseFloat(originalCurtailment.priceThreshold) : 0
            };

            // Compare values directly instead of JSON strings to avoid precision issues
            const curtailmentChanged = 
                currentCurtailment.enabled !== normalizedOriginal.enabled ||
                currentCurtailment.priceThreshold !== normalizedOriginal.priceThreshold;

            if (curtailmentChanged) {
                hasChanges = true;
                const badge = document.getElementById('curtailmentBadge');
                if (badge) {
                    badge.textContent = 'Modified';
                    badge.className = 'badge badge-modified';
                }
            } else {
                const badge = document.getElementById('curtailmentBadge');
                if (badge) {
                    badge.textContent = 'Synced';
                    badge.className = 'badge badge-sync';
                }
            }
            
            // Check location (backend keeps both location and preferences.weatherPlace in sync)
            const currentLocation = document.getElementById('preferences_weatherPlace')?.value || 'Sydney, Australia';
            const originalLocation = originalConfig.location || (originalConfig.preferences?.weatherPlace) || 'Sydney, Australia';
            const locationChanged = currentLocation !== originalLocation;
            
            if (locationChanged) {
                hasChanges = true;
                const badge = document.getElementById('preferencesBadge');
                if (badge) {
                    badge.textContent = 'Modified';
                    badge.className = 'badge badge-modified';
                }
            } else {
                const badge = document.getElementById('preferencesBadge');
                if (badge && !hasChanges) {  // Only update if no other changes in preferences
                    badge.textContent = 'Synced';
                    badge.className = 'badge badge-sync';
                }
            }
            
            // Check hardware settings (stored flat at root level, not nested under a section)
            const currentInvKw = parseFloat(document.getElementById('hardware_inverterCapacityKw')?.value || '10');
            const currentBatKwh = parseFloat(document.getElementById('hardware_batteryCapacityKwh')?.value || '41.93');
            const origInvKw = (originalConfig.inverterCapacityW || 10000) / 1000;
            const origBatKwh = originalConfig.batteryCapacityKWh || 41.93;
            const hardwareChanged = Math.abs(currentInvKw - origInvKw) > 0.001 || Math.abs(currentBatKwh - origBatKwh) > 0.001;
            const hardwareBadgeEl = document.getElementById('hardwareBadge');
            if (hardwareBadgeEl) {
                hardwareBadgeEl.textContent = hardwareChanged ? 'Modified' : 'Synced';
                hardwareBadgeEl.className = hardwareChanged ? 'badge badge-modified' : 'badge badge-sync';
            }
            if (hardwareChanged) hasChanges = true;

            hasUnsavedChanges = hasChanges;
            return hasChanges;
        }

        // Update status display
        function updateStatus() {
            const status = document.getElementById('configStatus');
            if (checkForChanges()) {
                status.innerHTML = '<span style="color:var(--color-warning)">‚ö†Ô∏è Unsaved</span>';
            } else {
                status.innerHTML = '<span style="color:var(--color-success)">‚úì No Changes</span>';
            }
        }

        // Save all settings
        async function saveAllSettings() {
            try {
                // Collect all values
                const newConfig = {
                    automation: {
                        intervalMs: getInputValue('automation_intervalMs'),
                        startDelayMs: getInputValue('automation_startDelayMs'),
                        gatherDataTimeoutMs: getInputValue('automation_gatherDataTimeoutMs'),

                        blackoutWindows: getBlackoutWindowsFromUI()
                    },
                    cache: {
                        amber: getInputValue('cache_amber'),
                        inverter: getInputValue('cache_inverter'),
                        weather: getInputValue('cache_weather')
                    },
                    defaults: {
                        cooldownMinutes: getInputValue('defaults_cooldownMinutes'),
                        durationMinutes: getInputValue('defaults_durationMinutes'),
                        fdPwr: getInputValue('defaults_fdPwr')
                    },
                    api: {
                        retryCount: currentConfig?.api?.retryCount ?? 3,
                        retryDelayMs: currentConfig?.api?.retryDelayMs ?? 1000
                    },
                    preferences: {
                        forecastDays: getInputValue('preferences_forecastDays') || 6,
                        weatherPlace: document.getElementById('preferences_weatherPlace')?.value || 'Sydney, Australia'
                    },
                    // Solar curtailment (price threshold range: -999 to +999 cents/kWh)
                    curtailment: {
                        enabled: document.getElementById('curtailment_enabled')?.classList.contains('active') === true,
                        priceThreshold: (() => {
                            const val = document.getElementById('curtailment_priceThreshold')?.value;
                            return val !== '' && val !== null ? parseFloat(val) : 0;
                        })()
                    },
                    // Also save location at root level for backward compatibility
                    location: document.getElementById('preferences_weatherPlace')?.value || 'Sydney, Australia',
                    // Hardware configuration (per-user inverter/battery specs, stored flat at config root)
                    inverterCapacityW: Math.round(parseFloat(document.getElementById('hardware_inverterCapacityKw')?.value || '10') * 1000),
                    batteryCapacityKWh: parseFloat(document.getElementById('hardware_batteryCapacityKwh')?.value || '41.93')
                };

                // Comprehensive validation
                const validationErrors = [];
                
                // Automation settings validation
                if (newConfig.automation.intervalMs < 10000 || newConfig.automation.intervalMs > 300000) {
                    validationErrors.push('Automation cycle: must be 10s-5m (10,000-300,000ms)');
                }
                if (newConfig.automation.startDelayMs < 0 || newConfig.automation.startDelayMs > 30000) {
                    validationErrors.push('Startup delay: must be 0-30s (0-30,000ms)');
                }
                if (newConfig.automation.gatherDataTimeoutMs < 5000 || newConfig.automation.gatherDataTimeoutMs > 30000) {
                    validationErrors.push('Data timeout: must be 5-30s (5,000-30,000ms)');
                }
                
                // Cache settings validation
                if (newConfig.cache.amber < 10000 || newConfig.cache.amber > 300000) {
                    validationErrors.push('Amber cache: must be 10s-5m (10,000-300,000ms)');
                }
                if (newConfig.cache.inverter < 60000 || newConfig.cache.inverter > 600000) {
                    validationErrors.push('Inverter cache: must be 1m-10m (60,000-600,000ms) - respect API rate limits');
                }
                if (newConfig.cache.weather < 300000 || newConfig.cache.weather > 3600000) {
                    validationErrors.push('Weather cache: must be 5m-1h (300,000-3,600,000ms)');
                }
                
                // Hardware validation
                if (!newConfig.inverterCapacityW || newConfig.inverterCapacityW < 1000 || newConfig.inverterCapacityW > 30000) {
                    validationErrors.push('Inverter capacity: must be 1‚Äì30 kW (1,000‚Äì30,000 watts)');
                }
                if (!newConfig.batteryCapacityKWh || newConfig.batteryCapacityKWh < 1 || newConfig.batteryCapacityKWh > 500) {
                    validationErrors.push('Battery capacity: must be 1‚Äì500 kWh');
                }

                // Defaults validation
                if (newConfig.defaults.cooldownMinutes < 0 || newConfig.defaults.cooldownMinutes > 60) {
                    validationErrors.push('Default cooldown: must be 0-60 minutes');
                }
                if (newConfig.defaults.durationMinutes < 5 || newConfig.defaults.durationMinutes > 120) {
                    validationErrors.push('Default duration: must be 5-120 minutes');
                }
                if (newConfig.defaults.fdPwr < 1000 || newConfig.defaults.fdPwr > (newConfig.inverterCapacityW || 10000)) {
                    validationErrors.push(`Power setting: must be 1000‚Äì${newConfig.inverterCapacityW || 10000} watts (inverter capacity)`);
                }
                
                // Preferences validation
                if (newConfig.preferences.forecastDays < 1 || newConfig.preferences.forecastDays > 16) {
                    validationErrors.push('Forecast days: must be 1-16 days');
                }
                
                // Curtailment validation
                if (newConfig.curtailment.enabled) {
                    if (isNaN(newConfig.curtailment.priceThreshold) || newConfig.curtailment.priceThreshold < -999 || newConfig.curtailment.priceThreshold > 999) {
                        validationErrors.push('Curtailment price threshold: must be -999 to 999 cents/kWh');
                    }
                }
                
                if (validationErrors.length > 0) {
                    showMessage('warning', 'Validation errors:\n‚Ä¢ ' + validationErrors.join('\n‚Ä¢ '));
                    return;
                }

                const statusEl = document.getElementById('configStatus');
                statusEl.innerHTML = '<span class="spinner"></span> Saving...';

                // Add browser timezone for detection (most reliable source)
                const browserTz = apiClient.getBrowserTimezone();
                newConfig.browserTimezone = browserTz;

                const resp = await authenticatedFetch('/api/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newConfig)
                });

                if (!resp.ok) {
                    // Try to extract structured error payload
                    try {
                        const err = await resp.json();
                        throw new Error(err?.msg || err?.error || `HTTP ${resp.status}`);
                    } catch (e) {
                        throw new Error(`HTTP ${resp.status}`);
                    }
                }

                const data = await resp.json();
                if (data.errno !== 0) throw new Error(data.msg || 'Failed to save config');

                // Capture previous location BEFORE overwriting originalConfig
                const prevSavedLoc = (originalConfig.location || originalConfig.preferences?.weatherPlace || '').trim().toLowerCase();

                // Update original config from server response
                originalConfig = JSON.parse(JSON.stringify(data.result));
                
                // Ensure curtailment config is properly initialized in originalConfig
                if (!originalConfig.curtailment) {
                    originalConfig.curtailment = { enabled: false, priceThreshold: 0 };
                }
                
                // Ensure preferences object exists
                if (!originalConfig.preferences) {
                    originalConfig.preferences = {};
                }
                
                currentConfig = data.result;

                // Refresh UI with saved values to prevent revert (backend keeps both fields in sync)
                const savedLocation = data.result.location || (data.result.preferences?.weatherPlace);
                if (savedLocation) {
                    const weatherInput = document.getElementById('preferences_weatherPlace');
                    if (weatherInput) weatherInput.value = savedLocation;
                }

                // Clear weather cache in localStorage if location changed so the dashboard
                // will fetch fresh data and show the correct timezone on next visit
                try {
                    const newSavedLoc = (savedLocation || '').trim().toLowerCase();
                    if (newSavedLoc && prevSavedLoc && newSavedLoc !== prevSavedLoc) {
                        const cs = JSON.parse(localStorage.getItem('cacheState') || '{}');
                        cs.weatherTime = 0;
                        localStorage.setItem('cacheState', JSON.stringify(cs));
                        localStorage.removeItem('cachedWeatherFull');
                    }
                } catch (e) { /* non-fatal */ }

                updateStatus();
                document.getElementById('lastSaved').textContent = new Date().toLocaleTimeString('en-AU', { hour: '2-digit', minute: '2-digit', hour12: false });
                
                showMessage('success', '‚úÖ Configuration saved to server and persisted to disk!');
            } catch (error) {
                showMessage('warning', `Failed to save configuration: ${error.message}`);
                updateStatus();
            }
        }

        // Reset section to defaults
        function resetSection(section) {
            if (!confirm(`Undo changes to ${section} settings?`)) return;
            
            if (originalConfig[section]) {
                Object.keys(originalConfig[section]).forEach(key => {
                    if (key === 'blackoutWindows') return;
                    setInputValue(`${section}_${key}`, originalConfig[section][key]);
                });
            }
            
            updateAllTimeDisplays();
            updateStatus();
        }
        
        // Blackout window functions
        function renderBlackoutWindows(windows) {
            const container = document.getElementById('blackoutWindowsList');
            if (!windows || windows.length === 0) {
                container.innerHTML = '<div style="color:var(--text-secondary);font-size:13px;text-align:center;padding:20px">No blackout windows configured</div>';
                return;
            }
            
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            let html = '';
            windows.forEach((w, idx) => {
                const daysStr = w.days && w.days.length > 0 
                    ? w.days.map(d => dayNames[d]).join(', ')
                    : 'Every day';
                // Store the entire original object in a data attribute so getBlackoutWindowsFromUI can preserve all properties
                const windowData = JSON.stringify(w);
                html += `
                    <div class="setting-item" style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px" data-window-idx="${idx}" data-window-original="${windowData.replace(/"/g, '&quot;')}">
                        <div style="display:flex;align-items:center;gap:12px">
                            <input type="time" class="blackout-start" value="${w.start || '00:00'}" style="background:var(--bg-input);border:1px solid var(--border-primary);color:var(--text-primary);padding:6px;border-radius:4px">
                            <span style="color:var(--text-secondary)">to</span>
                            <input type="time" class="blackout-end" value="${w.end || '23:59'}" style="background:var(--bg-input);border:1px solid var(--border-primary);color:var(--text-primary);padding:6px;border-radius:4px">
                            <span style="color:var(--text-secondary);font-size:12px">(${daysStr})</span>
                        </div>
                        <button onclick="removeBlackoutWindow(${idx})" style="background:var(--color-danger-bg);border:1px solid var(--color-danger);color:var(--color-danger);padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px">üóëÔ∏è Remove</button>
                    </div>
                `;
            });
            container.innerHTML = html;
            
            // Add change listeners
            container.querySelectorAll('input').forEach(input => {
                input.addEventListener('change', updateStatus);
            });
        }
        
        function getBlackoutWindowsFromUI() {
            const container = document.getElementById('blackoutWindowsList');
            const items = container.querySelectorAll('[data-window-idx]');
            const windows = [];
            items.forEach(item => {
                const start = item.querySelector('.blackout-start')?.value;
                const end = item.querySelector('.blackout-end')?.value;
                if (start && end) {
                    // Try to get the original object from the data attribute to preserve all properties
                    const originalData = item.getAttribute('data-window-original');
                    if (originalData) {
                        try {
                            const original = JSON.parse(originalData);
                            // Update only the times, keep everything else
                            windows.push({ ...original, start, end });
                        } catch (e) {
                            // Fallback if parsing fails
                            windows.push({ enabled: true, start, end, days: [] });
                        }
                    } else {
                        // Fallback for new windows that haven't been saved yet
                        windows.push({ enabled: true, start, end, days: [] });
                    }
                }
            });
            return windows;
        }
        
        function addBlackoutWindow() {
            const current = getBlackoutWindowsFromUI();
            current.push({ enabled: true, start: '22:00', end: '06:00', days: [] });
            renderBlackoutWindows(current);
            updateStatus();
        }
        
        function removeBlackoutWindow(idx) {
            const current = getBlackoutWindowsFromUI();
            current.splice(idx, 1);
            renderBlackoutWindows(current);
            updateStatus();
        }
        
        // Curtailment toggle button handler
        function toggleCurtailmentButton(button) {
            button.classList.toggle('active');
            const isActive = button.classList.contains('active');
            button.querySelector('.curtailment-state').textContent = isActive ? 'Enabled' : 'Disabled';
            updateCurtailmentChanges();
        }
        
        // Update curtailment change status
        function updateCurtailmentChanges() {
            updateStatus();
        }
        
        // Factory reset removed for safety ‚Äî endpoint not present in backend
        // If you need a safe reset flow, implement /api/config/reset on the server

        // Define validation rules for each input
        const validationRules = {
            'automation_intervalMs': {
                min: 10000, max: 300000,
                errorMsg: 'Automation cycle must be 10s-5m (10,000-300,000ms)'
            },
            'automation_startDelayMs': {
                min: 0, max: 30000,
                errorMsg: 'Startup delay must be 0-30s (0-30,000ms)'
            },
            'automation_gatherDataTimeoutMs': {
                min: 5000, max: 30000,
                errorMsg: 'Data timeout must be 5-30s (5,000-30,000ms)'
            },
            'cache_amber': {
                min: 10000, max: 300000,
                errorMsg: 'Amber cache must be 10s-5m (10,000-300,000ms)'
            },
            'cache_inverter': {
                min: 60000, max: 600000,
                errorMsg: 'Inverter cache must be 1m-10m (60,000-600,000ms) - respect API rate limits'
            },
            'cache_weather': {
                min: 300000, max: 3600000,
                errorMsg: 'Weather cache must be 5m-1h (300,000-3,600,000ms)'
            },
            'defaults_cooldownMinutes': {
                min: 0, max: 60,
                errorMsg: 'Cooldown must be 0-60 minutes'
            },
            'defaults_durationMinutes': {
                min: 5, max: 120,
                errorMsg: 'Duration must be 5-120 minutes'
            },
            'defaults_fdPwr': {
                min: 1000, max: 10000,
                errorMsg: 'Power must be 1000-10000 watts'
            },
            'api_retryCount': {
                min: 0, max: 10,
                errorMsg: 'Retry count must be 0-10 attempts'
            },
            'api_retryDelayMs': {
                min: 100, max: 10000,
                errorMsg: 'Retry delay must be 100-10000ms (0.1-10 seconds)'
            },
            'preferences_forecastDays': {
                min: 1, max: 16,
                errorMsg: 'Forecast days must be 1-16 days'
            }
        };

        // Validate a numeric input against its rules
        function validateInput(input) {
            const id = input.id;
            
            // Skip validation for disabled inputs (they haven't loaded from server yet)
            if (input.disabled) {
                input.style.borderColor = '';
                input.title = '';
                return true;
            }
            
            const rules = validationRules[id];
            
            if (!rules) return true; // No validation rules defined
            
            const value = parseFloat(input.value);
            if (isNaN(value)) {
                input.style.borderColor = 'var(--color-danger)';
                input.title = 'Invalid number';
                return false;
            }
            
            if (value < rules.min || value > rules.max) {
                input.style.borderColor = 'var(--color-danger)';
                input.title = rules.errorMsg;
                return false;
            }
            
            // Valid
            input.style.borderColor = '';
            input.title = '';
            return true;
        }

        // Add change listeners to all inputs
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM Content Loaded');
            
            // Add change listeners for status and time displays
            document.querySelectorAll('input[type="number"]').forEach(input => {
                input.addEventListener('input', () => {
                    validateInput(input);
                    updateStatus();
                    updateTimeDisplay(input.id);
                });
                input.addEventListener('blur', () => {
                    validateInput(input);
                });
                // Skip validation on page load - all inputs start disabled
            });
            
            // Add change listener for select
            document.querySelectorAll('select').forEach(select => {
                select.addEventListener('change', updateStatus);
            });
            
            // Add change listener for text inputs (especially preferences section)
            document.querySelectorAll('input[type="text"]').forEach(input => {
                input.addEventListener('input', updateStatus);
            });
            
            // Initialize time displays
            updateAllTimeDisplays();
            // Credentials toggles
            const tFox = document.getElementById('credentials_toggleFoxess');
            const tAmber = document.getElementById('credentials_toggleAmber');
            if (tFox) {
                tFox.addEventListener('click', (e) => {
                    togglePasswordField('credentials_foxessToken', tFox);
                });
            }
            if (tAmber) {
                tAmber.addEventListener('click', (e) => {
                    togglePasswordField('credentials_amberKey', tAmber);
                });
            }
        });

        function togglePasswordField(inputId, btn) {
            const input = document.getElementById(inputId);
            if (!input) {
                return;
            }
            
            if (input.type === 'password') {
                // Show actual value when toggling to text
                if (input.dataset.actualValue) {
                    input.value = input.dataset.actualValue;
                }
                input.type = 'text';
                btn.textContent = 'Hide';
            } else {
                // Hide - show masked dots again
                input.value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                input.type = 'password';
                btn.textContent = 'Show';
            }
        }

        // Load only credentials status (reload deviceSn and token presence)
        function checkCredentialsChanged() {
            const deviceSn = (document.getElementById('credentials_deviceSn')?.value || '').trim();
            const foxessToken = (document.getElementById('credentials_foxessToken')?.value || '').trim();
            const amberKey = (document.getElementById('credentials_amberKey')?.value || '').trim();
            
            const changed = (deviceSn !== originalCredentials.deviceSn) || 
                           (foxessToken !== (originalCredentials.foxessToken || '')) || 
                           (amberKey !== (originalCredentials.amberKey || ''));
            
            const badge = document.getElementById('credentialsBadge');
            if (badge) {
                if (changed) {
                    badge.textContent = 'Modified';
                    badge.className = 'badge badge-modified';
                } else {
                    badge.textContent = 'Synced';
                    badge.className = 'badge badge-sync';
                }
            }
            return changed;
        }
        
        async function loadCredentials() {
            try {
                const resp = await authenticatedFetch('/api/config?t=' + Date.now());
                const data = await resp.json();
                if (data.errno === 0 && data.result) {
                    const deviceSn = data.result.deviceSn || '';
                    document.getElementById('credentials_deviceSn').value = deviceSn;
                    originalCredentials.deviceSn = deviceSn;
                }
                
                // Clear token inputs on reload (for security - tokens aren't returned by API)
                // But show masked dots if credentials exist, with actual values stored for Show/Hide
                const healthResp = await authenticatedFetch('/api/health');
                const health = await healthResp.json();
                const foxessPresent = health && health.FOXESS_TOKEN;
                const amberPresent = health && health.AMBER_API_KEY;
                
                // Get actual credential values from config
                const actualFoxess = data.result?.foxessToken || '';
                const actualAmber = data.result?.amberApiKey || '';
                
                const foxessInput = document.getElementById('credentials_foxessToken');
                const amberInput = document.getElementById('credentials_amberKey');
                
                // Show masked credentials if they exist, but store actual values for Show/Hide
                if (foxessPresent && actualFoxess) {
                    foxessInput.value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                    foxessInput.dataset.actualValue = actualFoxess;
                    originalCredentials.foxessToken = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                } else {
                    foxessInput.value = '';
                    delete foxessInput.dataset.actualValue;
                    originalCredentials.foxessToken = '';
                }
                
                if (amberPresent && actualAmber) {
                    amberInput.value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                    amberInput.dataset.actualValue = actualAmber;
                    originalCredentials.amberKey = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                } else {
                    amberInput.value = '';
                    delete amberInput.dataset.actualValue;
                    originalCredentials.amberKey = '';
                }
                
                const credStatusEl = document.getElementById('credentialsStatus');
                
                if (foxessPresent && amberPresent) {
                  credStatusEl.textContent = 'FoxESS token and Amber API key are present (hidden)';
                } else if (foxessPresent) {
                  credStatusEl.textContent = 'FoxESS token is present (hidden) ‚Äî Amber API key not set';
                } else if (amberPresent) {
                  credStatusEl.textContent = 'Amber API key is present (hidden) ‚Äî FoxESS token not set';
                } else {
                  credStatusEl.textContent = 'No credentials detected';
                }
                
                // Update badge after reload
                checkCredentialsChanged();
                updateStatus();
            } catch (e) {
                console.warn('loadCredentials failed', e);
            }
        }

        // Save credentials by calling validate-keys endpoint which also sets them on server when valid
        async function saveCredentials() {
            const deviceSn = (document.getElementById('credentials_deviceSn')?.value || '').trim();
            const foxessInput = document.getElementById('credentials_foxessToken');
            const amberInput = document.getElementById('credentials_amberKey');
            
            // Get the displayed value (either masked dots or actual)
            const foxessDisplayed = (foxessInput?.value || '').trim();
            const amberDisplayed = (amberInput?.value || '').trim();
            
            // Check if values are masked (just dots) - if so, use the stored actual value
            const foxessToken = (foxessDisplayed === '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' && foxessInput?.dataset.actualValue) 
                ? foxessInput.dataset.actualValue 
                : foxessDisplayed;
            const amberKey = (amberDisplayed === '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' && amberInput?.dataset.actualValue) 
                ? amberInput.dataset.actualValue 
                : amberDisplayed;

            // If token fields are empty, use original stored values (user didn't change them)
            const tokenToSend = foxessToken || null;
            const amberToSend = amberKey || null;

            if (!deviceSn) { showMessage('warning', 'Device Serial Number is required'); return; }

            const saveBtn = document.getElementById('credentialsSaveBtn');
            const prevText = saveBtn.innerHTML;
            saveBtn.disabled = true;
            saveBtn.innerHTML = '<span class="spinner"></span> Saving...';

            try {
                const resp = await authenticatedFetch('/api/config/validate-keys', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ device_sn: deviceSn, foxess_token: tokenToSend, amber_api_key: amberToSend })
                });
                const data = await resp.json();
                if (data.errno !== 0) {
                    console.warn('validate-keys errors', data);
                    // Surface first error message
                    const first = (data.errors && (data.errors.foxess_token || data.errors.device_sn || data.msg)) || 'Validation failed';
                    showMessage('warning', first);
                    return;
                }

                // Success - reload credentials to reset display
                await loadCredentials();
                showMessage('success', 'Credentials validated and stored on server');
            } catch (e) {
                console.error('saveCredentials error', e);
                showMessage('warning', 'Failed to save credentials: ' + (e.message || e));
            } finally {
                saveBtn.disabled = false;
                saveBtn.innerHTML = prevText;
                updateStatus();
            }
        }

        async function clearCredentials() {
            if (!confirm('Clear FOXESS token, DEVICE SN, and AMBER API KEY from the running server?')) return;
            try {
                const resp = await authenticatedFetch('/api/config/clear-credentials', { method: 'POST' });
                const data = await resp.json();
                if (data.errno === 0) {
                    document.getElementById('credentials_deviceSn').value = '';
                    document.getElementById('credentials_foxessToken').value = '';
                    document.getElementById('credentials_amberKey').value = '';
                    showMessage('success', 'Credentials cleared from server memory');
                    loadSettings();
                } else {
                    showMessage('warning', 'Failed to clear credentials: ' + (data.msg || 'unknown'));
                }
            } catch (e) {
                console.error('clearCredentials error', e);
                showMessage('warning', 'Failed to clear credentials: ' + (e.message || e));
            }
        }

        // Warn before leaving with unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (hasUnsavedChanges) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
        
        // Track changes to credential fields
        ['credentials_deviceSn', 'credentials_foxessToken', 'credentials_amberKey'].forEach(id => {
            document.getElementById(id)?.addEventListener('input', () => {
                checkCredentialsChanged();
                updateStatus();
            });
        });

        // WIP Pages visibility - Tesla & Topology Discovery (admin only)
        if (typeof window.auth !== 'undefined' && window.auth) {
            window.auth.onAuthStateChanged((user) => {
                if (user && user.email === 'sardanapalos928@hotmail.com') {
                    const teslaLink = document.getElementById('teslaNavLink');
                    const topologyLink = document.getElementById('topologyNavLink');
                    if (teslaLink) teslaLink.style.display = '';
                    if (topologyLink) topologyLink.style.display = '';
                }
            });
        }

        // ==================== CURTAILMENT MANUAL OVERRIDE ====================
        
        async function readExportLimit() {
            const statusEl = document.getElementById('currentExportLimit');
            try {
                statusEl.textContent = '‚è≥ Reading...';
                statusEl.style.color = 'var(--color-yellow)';
                
                const resp = await authenticatedFetch('/api/inverter/settings?key=ExportLimit');
                const data = await resp.json();
                
                if (data.errno === 0 && data.result && data.result.value !== undefined) {
                    const value = data.result.value;
                    statusEl.textContent = `${value}W`;
                    statusEl.style.color = value === 0 ? 'var(--color-danger)' : 'var(--color-success)';
                    
                    // Show user-friendly message
                    if (value === 0) {
                        showMessage('warning', `‚ö†Ô∏è Export is currently CURTAILED (0W). Use Force Set to restore.`);
                    } else {
                        showMessage('success', `‚úÖ Export limit is ${value}W (normal operation)`);
                    }
                } else {
                    statusEl.textContent = '‚ùå Failed';
                    statusEl.style.color = 'var(--color-danger)';
                    showMessage('warning', `Failed to read ExportLimit: ${data.error || data.msg || 'Unknown error'}`);
                }
            } catch (error) {
                statusEl.textContent = '‚ùå Error';
                statusEl.style.color = 'var(--color-danger)';
                showMessage('warning', `Error reading ExportLimit: ${error.message}`);
            }
        }
        
        async function forceSetExportLimit() {
            const input = document.getElementById('manualExportLimit');
            const value = parseInt(input.value);
            
            if (isNaN(value) || value < 0 || value > 12000) {
                showMessage('warning', '‚ö†Ô∏è Please enter a valid value between 0 and 12000');
                return;
            }
            
            const actionDesc = value === 0 ? 'CURTAIL export (0W)' : value === 12000 ? 'RESTORE normal export (12000W)' : `set export to ${value}W`;
            if (!confirm(`‚ö†Ô∏è Force ${actionDesc}?\n\nThis will directly modify your inverter settings, bypassing automation. Only proceed if automation has failed or your system is stuck.`)) {
                return;
            }
            
            try {
                showMessage('info', `‚è≥ Setting ExportLimit to ${value}W...`);
                
                const resp = await authenticatedFetch('/api/device/setting/set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        key: 'ExportLimit',
                        value: value
                    })
                });
                
                const data = await resp.json();
                
                if (data.errno === 0) {
                    showMessage('success', `‚úÖ Export limit successfully set to ${value}W!`);
                    
                    // Update the read display
                    const statusEl = document.getElementById('currentExportLimit');
                    statusEl.textContent = `${value}W`;
                    statusEl.style.color = value === 0 ? 'var(--color-danger)' : 'var(--color-success)';
                    
                    // Show appropriate follow-up message
                    if (value === 12000) {
                        setTimeout(() => {
                            showMessage('info', 'üí° Export restored to normal. Monitor your dashboard to verify operation.', 8000);
                        }, 2000);
                    } else if (value === 0) {
                        setTimeout(() => {
                            showMessage('warning', '‚ö†Ô∏è Export is now curtailed. Set to 12000W to restore normal operation.', 8000);
                        }, 2000);
                    }
                } else {
                    showMessage('warning', `‚ùå Failed to set ExportLimit: ${data.error || data.msg || 'Unknown error'}`);
                }
            } catch (error) {
                showMessage('warning', `‚ùå Error setting ExportLimit: ${error.message}`);
            }
        }
    </script>
</body>
</html>
